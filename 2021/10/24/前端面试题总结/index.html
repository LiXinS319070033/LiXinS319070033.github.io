<!DOCTYPE html>
<html lang="en">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="Nice">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="Nice">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog">
    
    <meta name="description" content="">
    <meta name="description" content="前端面试题总结4以下对 Ajax 描述不正确的是( A )A.readyState 属性请求的状态值，当值为 3 时是正在加载。 B.使用 XML 和 XSLT 进⾏行数据交换及相关操作。 C.总共有 8 种 callback（onSuccess onFailure onUninitialized onloading onloaded onInteractive onComplete onExce">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试题总结">
<meta property="og:url" content="https://lixins319070033.github.io/2021/10/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="前端面试题总结4以下对 Ajax 描述不正确的是( A )A.readyState 属性请求的状态值，当值为 3 时是正在加载。 B.使用 XML 和 XSLT 进⾏行数据交换及相关操作。 C.总共有 8 种 callback（onSuccess onFailure onUninitialized onloading onloaded onInteractive onComplete onExce">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-10-24T11:48:46.000Z">
<meta property="article:modified_time" content="2021-10-31T15:41:56.303Z">
<meta property="article:author" content="Nice">
<meta name="twitter:card" content="summary">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    
    <title>前端面试题总结 · 煜成&#39;s Studio</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: 3;
        width: 100%;
        /* height: 50vh; */
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
<meta name="generator" content="Hexo 5.2.0"></head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/" >煜成&#39;s Studio.</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">前端面试题总结</a>
            </div>
    </div>
    
    <a class="home-link" href=/>煜成's Studio.</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:50vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/chi.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            前端面试题总结
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                
                    <div class="post-intro-read">
                        <span>Word count: <span class="post-count word-count">36.1k</span>Reading time: <span class="post-count reading-time">151 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2021/10/24</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <h1 id="前端面试题总结"><a href="#前端面试题总结" class="headerlink" title="前端面试题总结"></a>前端面试题总结</h1><h3 id="4以下对-Ajax-描述不正确的是-A"><a href="#4以下对-Ajax-描述不正确的是-A" class="headerlink" title="4以下对 Ajax 描述不正确的是( A )"></a>4以下对 Ajax 描述不正确的是( A )</h3><p>A.readyState 属性请求的状态值，当值为 3 时是正在加载。</p>
<p>B.使用 XML 和 XSLT 进⾏行数据交换及相关操作。</p>
<p>C.总共有 8 种 callback（onSuccess onFailure onUninitialized onloading onloaded onInteractive onComplete onException）</p>
<p> D.abort()⽅法，停⽌当前请求</p>
<p>XML，Extensible Markup Language，可扩展标记语言，是一种用于标记电子文件使其具有结构性的标记语言。</p>
<p>XSLT，EXtensible Stylesheet Language，可扩展样式表转换语言，是一种样式转换标记语言，可以将XML数据档转换为另外的XML或其它格式，如HTML网页，纯文字。</p>
<p>readyState表示xhr对象的请求状态，取值范围是0——4，分别表示5个不同的状态。<br>0：（未初始化）xhr对象已经创建，但还没有调用open()方法。值为0表示对象已经存在，否则浏览器会报错：对象不存在。<br>1 :（载入/发送请求）调用open()方法对xhr对象进行初始化，根据参数(method,url,true)，完成对象状态的设置。并调用send()方法开始向服务端发送请求。值为1表示正在向服务端发送请求。<br>2 ：（载入完成/响应接收）接收服务器端响应回的数据。但获得的还只是服务端响应的原始数据，并不能直接在客户端使用。值为2表示send()请求方法执行完成，并已经接收完全部的响应数据（未解析）。<br>3 － （交互/解析数据）正在解析从服务器端接收到的响应数据。即根据服务器端响应头部返回的MIME类型把数据转换成能通过responseBody、responseText或responseXML属性存取的格式，为在客户端调用作好准备。值为3表示正在解析数据。<br>4 － （后台处理完成）响应内容解析完成，可以在客户端调用了。此阶段确认全部数据都已经解析为客户端可用的格式，解析已经完成。值为4表示数据解析完毕，可以通过XMLHttpRequest对象的相应属性取得数据。</p>
<p>总之，整个XMLHttpRequest对象的生命周期应该包含如下阶段：<br>创建－0初始化请求－1发送请求－2接收数据－3解析数据－4完成 。</p>
<h4 id="Ajax原理"><a href="#Ajax原理" class="headerlink" title="Ajax原理"></a>Ajax原理</h4><p>Ajax 的原理简单来说是在⽤户和服务器之间加了—个中间层( AJAX 引擎)，通过XmlHttpRequest 对象来向服务器发异步请求，从服务器获得数据，然后⽤ javascript来操作 DOM ⽽更新⻚⾯。使⽤户操作与服务器响应异步化。这其中最关键的⼀步就是从服务器获得请求数据<br>Ajax 的过程只涉及 JavaScript 、 XMLHttpRequest 和 DOM 。 XMLHttpRequest 是ajax的核⼼机制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** 1. 创建连接 **&#x2F;</span><br><span class="line">var xhr &#x3D; null;</span><br><span class="line">xhr &#x3D; XMLHTTPRequest ? new XMLHttpRequest() : new window.ActiveXObject(&#39;Microsoft.XMLHTTP&#39;);</span><br><span class="line">&#x2F;** 2. 连接服务器 **&#x2F;</span><br><span class="line">xhr.open(&#39;get&#39;, url, true)</span><br><span class="line">&#x2F;** 3. 发送请求 **&#x2F;</span><br><span class="line">xhr.send(null);</span><br><span class="line">&#x2F;** 4. 接受请求 **&#x2F;</span><br><span class="line">xhr.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">    if(xhr.readyState &#x3D;&#x3D; 4)&#123;</span><br><span class="line">        if(xhr.status &#x3D;&#x3D; 200)&#123;</span><br><span class="line">        	success(xhr.responseText);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;** false **&#x2F;</span><br><span class="line">            fail &amp;&amp; fail(xhr.status);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ajax 有那些优缺点?<br>优点：<br>通过异步模式，提升了⽤户体验.<br>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占⽤.<br>Ajax 在客户端运⾏，承担了⼀部分本来由服务器承担的⼯作，减少了⼤⽤户量下的服务器负载。<br>Ajax 可以实现动态不刷新（局部刷新）<br>缺点：<br>安全问题 AJAX 暴露了与服务器交互的细节。<br>对搜索引擎的⽀持⽐较弱。<br>不容易调试。</p>
<h3 id="5typeOf（null）-Object"><a href="#5typeOf（null）-Object" class="headerlink" title="5typeOf（null）//Object"></a>5typeOf（null）//Object</h3><p>null是一个只有一个值的特殊类型。表示一个空对象引用。</p>
<h3 id="6alert-null-instanceof-Object-返回值为false-null表示为空的引用；instanceof-表示某个变量是否是某个对象的实例"><a href="#6alert-null-instanceof-Object-返回值为false-null表示为空的引用；instanceof-表示某个变量是否是某个对象的实例" class="headerlink" title="6alert(null instanceof Object); 返回值为false,( null表示为空的引用；instanceof 表示某个变量是否是某个对象的实例)"></a>6alert(null instanceof Object); 返回值为false,( null表示为空的引用；instanceof 表示某个变量是否是某个对象的实例)</h3><h3 id="8HTTP的GET和POST有什么区别"><a href="#8HTTP的GET和POST有什么区别" class="headerlink" title="8HTTP的GET和POST有什么区别?"></a>8HTTP的GET和POST有什么区别?</h3><h3 id="9HTTP状态码200、302、401、404、500分别代表什么意思"><a href="#9HTTP状态码200、302、401、404、500分别代表什么意思" class="headerlink" title="9HTTP状态码200、302、401、404、500分别代表什么意思?"></a>9HTTP状态码200、302、401、404、500分别代表什么意思?</h3><h3 id="10一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些图片优化这些图片的加载，给用户更好"><a href="#10一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些图片优化这些图片的加载，给用户更好" class="headerlink" title="10一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些图片优化这些图片的加载，给用户更好"></a>10一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些图片优化这些图片的加载，给用户更好</h3><p>图⽚懒加载，在⻚⾯上的未可视区域可以添加⼀个滚动事件，判断图⽚位置与浏览器顶端的距离与⻚⾯的距离，如果前者⼩于后者，优先加载。<br>如果为幻灯⽚、相册等，可以使⽤图⽚预加载技术，将当前展示图⽚的前⼀张和后⼀张优先下载。<br>如果图⽚为css图⽚，可以使⽤ CSSsprite ， SVGsprite ， Iconfont 、 Base64 等技术。<br>如果图⽚过⼤，可以使⽤特殊编码的图⽚，加载时会先加载⼀张压缩的特别厉害的缩略图，以提⾼⽤户体验。<br>如果图⽚展示区域⼩于图⽚的真实⼤⼩，则因在服务器端根据业务需要先⾏进⾏图⽚压缩，图⽚压缩后⼤⼩与展示⼀致。</p>
<h3 id="14base64的原理及优缺点"><a href="#14base64的原理及优缺点" class="headerlink" title="14base64的原理及优缺点"></a>14base64的原理及优缺点</h3><p>优点:可以加密，减少了 HTTP 请求<br>缺点:是需要消耗 CPU 进⾏编解码</p>
<h3 id="11说一说前端性能优化有哪些方法"><a href="#11说一说前端性能优化有哪些方法" class="headerlink" title="11说一说前端性能优化有哪些方法"></a>11说一说前端性能优化有哪些方法</h3><h3 id="12Vue有哪些生命周期函数"><a href="#12Vue有哪些生命周期函数" class="headerlink" title="12Vue有哪些生命周期函数?"></a>12Vue有哪些生命周期函数?</h3><h3 id="15关于类型转换，下列说法错误的有-以下三个都是错的"><a href="#15关于类型转换，下列说法错误的有-以下三个都是错的" class="headerlink" title="15关于类型转换，下列说法错误的有?以下三个都是错的"></a>15关于类型转换，下列说法错误的有?以下三个都是错的</h3><p>A null + 1 === 1             B undefined + 1 === 1      C !”0” == false</p>
<p>undefined + 1 === NaN，undefined将它强制转换成数值会返回NaN</p>
<h3 id="16请完成代码，点击按钮“button”后，以弹窗的方式显示按钮“button”的值"><a href="#16请完成代码，点击按钮“button”后，以弹窗的方式显示按钮“button”的值" class="headerlink" title="16请完成代码，点击按钮“button”后，以弹窗的方式显示按钮“button”的值"></a>16请完成代码，点击按钮“button”后，以弹窗的方式显示按钮“button”的值</h3><p>&lt;input type=”button” id=”text” value=”点击一下” /&gt;</p>
<p>oText.onclick = function (e) {</p>
<p>​    alert(e.target.value);</p>
<p>}</p>
<h3 id="17完成function-a-代码，实现点击“这是第N条”列表项的时候alert-n-n-gt-0-amp-amp-n-lt-2"><a href="#17完成function-a-代码，实现点击“这是第N条”列表项的时候alert-n-n-gt-0-amp-amp-n-lt-2" class="headerlink" title="17完成function a()代码，实现点击“这是第N条”列表项的时候alert n (n &gt;= 0 &amp;&amp; n &lt;= 2)"></a>17完成function a()代码，实现点击“这是第N条”列表项的时候alert n (n &gt;= 0 &amp;&amp; n &lt;= 2)</h3><!--<ul id ="test">
    <li onclick="a();"这是第一条</li>
    <li onclick="a();"这是第二条</li>
    <li onclick="a();"这是第三条</li>
</ul>-->

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type &#x3D; &quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">    function a () &#123;</span><br><span class="line">        &#x2F;&#x2F;补充代码</span><br><span class="line">        var oLi &#x3D; document.getElementByTagName(&quot;li&quot;);</span><br><span class="line">        for (let i &#x3D; 0; i &lt; oLi.length; i++) &#123;</span><br><span class="line">        	oLi[i].index &#x3D; i;</span><br><span class="line">        	oLi[i].onClick &#x3D; function () &#123;</span><br><span class="line">				alert(this.index + 1);</span><br><span class="line">			&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F;闭包实现</span><br><span class="line">var lis&#x3D;document.querySelectorAll(&#39;li&#39;);</span><br><span class="line">for (var i &#x3D; 0; i &lt; lis.length; i++) &#123;</span><br><span class="line">    var li &#x3D; lis[i];</span><br><span class="line">    li.onclick&#x3D;(function(index)&#123;</span><br><span class="line">        return function(e)&#123;</span><br><span class="line">        	alert(index);</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;)(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="18请编写一个JavaScript函数parseQueryString，把URL参数解析为一个对象，var-url-“http-witmax-cn-index-php-key0-0-amp-key1-1-amp-key2-2-quot"><a href="#18请编写一个JavaScript函数parseQueryString，把URL参数解析为一个对象，var-url-“http-witmax-cn-index-php-key0-0-amp-key1-1-amp-key2-2-quot" class="headerlink" title="18请编写一个JavaScript函数parseQueryString，把URL参数解析为一个对象，var url = “http://witmax.cn/index.php?key0=0&amp;key1=1&amp;key2=2&quot;;"></a>18请编写一个JavaScript函数parseQueryString，把URL参数解析为一个对象，var url = “<a target="_blank" rel="noopener" href="http://witmax.cn/index.php?key0=0&amp;key1=1&amp;key2=2&quot;">http://witmax.cn/index.php?key0=0&amp;key1=1&amp;key2=2&quot;</a>;</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function serilizeUrl (url) &#123;</span><br><span class="line">	var result &#x3D; &#123;&#125;;</span><br><span class="line">	url &#x3D; url.split(&quot;?&quot;)[1];</span><br><span class="line">	var map &#x3D; url.split(&quot;&amp;&quot;);</span><br><span class="line">	for (var i &#x3D; 0, len &#x3D; map.length; i &lt; len; i++) &#123;</span><br><span class="line">		result[map[i].split(&quot;&#x3D;&quot;)[0]] &#x3D; map[i].split(&quot;&#x3D;&quot;)[1];</span><br><span class="line">	&#125;</span><br><span class="line">	return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21有哪些方法可以解决跨域-三种以上（考虑到兼容性的话用哪种）"><a href="#21有哪些方法可以解决跨域-三种以上（考虑到兼容性的话用哪种）" class="headerlink" title="21有哪些方法可以解决跨域?三种以上（考虑到兼容性的话用哪种）"></a>21有哪些方法可以解决跨域?三种以上（考虑到兼容性的话用哪种）</h3><h3 id="21补-vue和react内部是怎么实现数据的双向绑定的？react钩子的状态的实现"><a href="#21补-vue和react内部是怎么实现数据的双向绑定的？react钩子的状态的实现" class="headerlink" title="*21补 vue和react内部是怎么实现数据的双向绑定的？react钩子的状态的实现???"></a>*21补 vue和react内部是怎么实现数据的双向绑定的？react钩子的状态的实现???</h3><p>vue.js 则是采⽤数据劫持结合发布者-订阅者模式的⽅式，通过Object.defineProperty() 来劫持各个属性的 setter ， getter ，在数据变动时发布消息给订阅者，触发相应的监听回调</p>
<p>vue objectDefined proxy v-model</p>
<h4 id="React并没有自带的双向绑定，需要自己实现，结合setState-以及onChange事件来实现，每次文本框改变文本（即触发onChange事件），就使用setState-改变state数据"><a href="#React并没有自带的双向绑定，需要自己实现，结合setState-以及onChange事件来实现，每次文本框改变文本（即触发onChange事件），就使用setState-改变state数据" class="headerlink" title="React并没有自带的双向绑定，需要自己实现，结合setState()以及onChange事件来实现，每次文本框改变文本（即触发onChange事件），就使用setState()改变state数据"></a>React并没有自带的双向绑定，需要自己实现，结合setState()以及onChange事件来实现，每次文本框改变文本（即触发onChange事件），就使用setState()改变state数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;</span><br><span class="line">import ReactDOM from &quot;react-dom&quot;</span><br><span class="line"> </span><br><span class="line">export default class DataBind extends Component&#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state &#x3D; &#123;</span><br><span class="line">            value: &quot;Name&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    handleChange(e)&#123;</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            value : e.target.value</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    render()&#123;</span><br><span class="line">        return(</span><br><span class="line">        &lt;div style&#x3D;&#123;&#123;color:&#39;black&#39;&#125;&#125;&gt;</span><br><span class="line">		 &lt;input value&#x3D;&#123;this.state.value&#125; onChange&#x3D;&#123;this.handleChange.bind(this)&#125;&gt;&lt;&#x2F;input&gt;</span><br><span class="line">		 &lt;p&gt;&#123;this.state.value&#125;&lt;&#x2F;p&gt;</span><br><span class="line">		&lt;&#x2F;div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="99Vue-和-React-之间的区别"><a href="#99Vue-和-React-之间的区别" class="headerlink" title="99Vue 和 React 之间的区别"></a><strong>99Vue</strong> <strong>和 React</strong> <strong>之间的区别</strong></h3><p>Vue 的表单可以使⽤ v-model ⽀持双向绑定，相⽐于 React 来说开发上更加⽅便，当然了 v-model 其实就是个语法糖，本质上和 React 写表单的⽅式没什么区别</p>
<p>改变数据⽅式不同， Vue 修改状态相⽐来说要简单许多， React 需要使⽤ setState来改变状态，并且使⽤这个 API 也有⼀些坑点。并且 Vue 的底层使⽤了依赖追踪，⻚⾯更新渲染已经是最优的了，但是 React 还是需要⽤户⼿动去优化这⽅⾯的问题。</p>
<p>React 16 以后，有些钩⼦函数会执⾏多次，这是因为引⼊ Fiber 的原因。React 需要使⽤ JSX ，有⼀定的上⼿成本，并且需要⼀整套的⼯具链⽀持，但是完全可以通过 JS 来控制⻚⾯，更加的灵活。 Vue 使⽤了模板语法，相⽐于 JSX 来说没有那么灵活，但是完全可以脱离⼯具链，通过直接编写 render 函数就能在浏览器中运⾏。</p>
<p>在⽣态上来说，两者其实没多⼤的差距，当然 React 的⽤户是远远⾼于 Vue 的</p>
<h3 id="102发布-订阅模式"><a href="#102发布-订阅模式" class="headerlink" title="102发布-订阅模式"></a><strong>102</strong>发布-订阅模式</h3><p>发布-订阅模式也叫做观察者模式。通过⼀对⼀或者⼀对多的依赖关系，当对象发⽣改变时，订阅⽅都会收到通知。在现实⽣活中，也有很多类似场景，⽐如我需要在购物⽹站上购买⼀个产品，但是发现该产品⽬前处于缺货状态，这时候我可以点击有货通知的按钮，让⽹站在产品有货的时候通过短信通知我。在实际代码中其实发布-订阅模式也很常⻅，⽐如我们点击⼀个按钮触发了点击事件就是使⽤了该模式</p>
<p>vue数据双向绑定也用到了发布订阅模式 </p>
<p>观察者模式和发布订阅模式最大的区别就是发布订阅模式有个**事件调度中心 **</p>
<p>观察者模式中观察者和目标直接进行交互，而发布订阅模式中统一由调度中心进行处理，订阅者和发布者互不干扰。这样一方面实现了解耦，还有就是可以实现更细粒度的一些控制。比如发布者发布了很多消息，但是不想所有的订阅者都接收到，就可以在调度中心做一些处理，类似于权限控制之类的。还可以做一些节流操作。</p>
<h3 id="22函数的哪些原生方法可以改变其执行的上下文-call-apply-bind"><a href="#22函数的哪些原生方法可以改变其执行的上下文-call-apply-bind" class="headerlink" title="22函数的哪些原生方法可以改变其执行的上下文 call apply bind"></a>22函数的哪些原生方法可以改变其执行的上下文 call apply bind</h3><h3 id="25-ES6新增了哪些特性至少五个"><a href="#25-ES6新增了哪些特性至少五个" class="headerlink" title="25 ES6新增了哪些特性至少五个"></a>25 ES6新增了哪些特性至少五个</h3><p>1.新增了块级作用域（let，const）</p>
<p>2.提供了定义类的语法糖（class）</p>
<p>3.新增了一种基本数据类型（Symbol）</p>
<p>4.新增了变量的解构赋值</p>
<p>5.函数参数允许设置默认值，新增了箭头函数。</p>
<p>6.数组新增了一些API，如isArray / from / of 方法；数组实例新增了 entries()，keys() 和 values() 等方法。</p>
<p>7.对象和数组新增了扩展运算符</p>
<p>8.ES6新增了模块化（import / export）</p>
<p>9.ES6新增了Set和Map数据结构。</p>
<p>10.ES6原生提供Proxy构造函数，用来生成Proxy实例</p>
<p>11.ES6新增了生成器（Generator）和遍历器（Iterator）</p>
<h3 id="26浅拷贝"><a href="#26浅拷贝" class="headerlink" title="26浅拷贝"></a>26浅拷贝</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. ...实现</span><br><span class="line">let copy1 &#x3D; &#123;...&#123;x:1&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. Object.assign实现</span><br><span class="line"></span><br><span class="line">let copy2 &#x3D; Object.assign(&#123;&#125;, &#123;x:1&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="深拷贝（遍历一个对象用for-in）"><a href="#深拷贝（遍历一个对象用for-in）" class="headerlink" title="深拷贝（遍历一个对象用for in）"></a>深拷贝（遍历一个对象用for in）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">deepClone &#x3D; (initalObj) &#x3D;&gt; &#123;</span><br><span class="line">    const obj &#x3D; &#123;&#125;;</span><br><span class="line">    if(typeof initalObj !&#x3D;&#x3D; &#39;object&#39;)&#123;</span><br><span class="line">    	return initalObj</span><br><span class="line">    &#125;</span><br><span class="line">    for (const key in initalObj) &#123;</span><br><span class="line">        if (typeof initalObj[key] &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class="line">            &#x2F;&#x2F;对数组特殊处理</span><br><span class="line">            if (Array.isArray(initalObj[key])) &#123;</span><br><span class="line">                &#x2F;&#x2F;用map方法返回新数组，将数组中的元素递归</span><br><span class="line">                obj[key] &#x3D; initalObj[key].map(item &#x3D;&gt; deepClone(item))</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;递归返回新的对象</span><br><span class="line">            	obj[key] &#x3D; deepClone(initalObj[key]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if (typeof initalObj[key] &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">            &#x2F;&#x2F;返回新函数</span><br><span class="line">            obj[key] &#x3D; initalObj[key].bind(obj);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            &#x2F;&#x2F;基本类型直接返回</span><br><span class="line">            obj[key] &#x3D; initalObj[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">JSON.parse(JSON.stringify(obj))</span><br></pre></td></tr></table></figure>

<h3 id="111扁平化数组"><a href="#111扁平化数组" class="headerlink" title="111扁平化数组"></a><strong>111扁平化数组</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ES6</span><br><span class="line">var arr &#x3D; [1, [2, [3]], 4, [5]];</span><br><span class="line">arr.flat(Infinity);</span><br><span class="line">&#x2F;&#x2F;ES5第一种</span><br><span class="line">function flatArr (arr) &#123;	</span><br><span class="line">    var resultArr &#x3D; [];	</span><br><span class="line">    arr.forEach(function (item) &#123; </span><br><span class="line">        &#x2F;&#x2F;数组遍历最好用forEach		</span><br><span class="line">        var str &#x3D; Object.prototype.toString.call(item);		</span><br><span class="line">        if (str.indexOf(&quot;Array&quot;) !&#x3D;&#x3D; -1) &#123;			</span><br><span class="line">        	resultArr &#x3D; resultArr.concat(flatArr(item));		</span><br><span class="line">        &#125;else &#123;			</span><br><span class="line">        	resultArr &#x3D; resultArr.concat(item);		</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;);	</span><br><span class="line">    return resultArr;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;迭代</span><br><span class="line">&#x2F;&#x2F;对于把递归转换成迭代，很多情况下都需要一个stack来模拟函数调用。先看代码：</span><br><span class="line">function flatten2(arr) &#123;</span><br><span class="line">  const stack &#x3D; [...arr];</span><br><span class="line">  const res &#x3D; [];</span><br><span class="line">  while (stack.length) &#123;</span><br><span class="line">    &#x2F;&#x2F; 从栈里取出</span><br><span class="line">    const next &#x3D; stack.pop();</span><br><span class="line">    if (Array.isArray(next)) &#123;</span><br><span class="line">      &#x2F;&#x2F; 把next扁平化，然后放入stack中</span><br><span class="line">      stack.push(...next);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      res.push(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; reverse to restore input order</span><br><span class="line">  return res.reverse();</span><br><span class="line">&#125;</span><br><span class="line">console.log(flatten2(arr))</span><br><span class="line">递归是重复调用函数自身实现循环。迭代是函数内某段代码实现循环，循环代码中参与运算的变量同时是保存结果的变量，当前保存的结果作为下一次循环计算的初始值。</span><br><span class="line">递归循环中，遇到满足终止条件的情况时逐层返回来结束。迭代则使用计数器结束循环。当然很多情况都是多种循环混合采用，这要根据具体需求。</span><br><span class="line">结构不同：递归与迭代都是基于控制结构：迭代用重复结构，而递归用选择结构。</span><br><span class="line">&#x2F;&#x2F;第二种</span><br><span class="line">var tempArr &#x3D; arr.toString().split(&quot;,&quot;); </span><br><span class="line">&#x2F;&#x2F;arr.toString()的结果是&quot;1, 2, 3, 4, 5&quot;，</span><br><span class="line">&#x2F;&#x2F;arr.toString().split(&quot;,&quot;)结果为[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span><br><span class="line">var resultArr &#x3D; tempArr.map(function (item) &#123;	</span><br><span class="line">	return parseInt(item);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(resultArr);</span><br><span class="line">&#x2F;&#x2F;第三种</span><br><span class="line">var tempArr &#x3D; arr.join().split(&quot;,&quot;);</span><br><span class="line">var resultArr &#x3D; tempArr.map(function (item) &#123;	</span><br><span class="line">	return parseInt(item);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(resultArr);</span><br></pre></td></tr></table></figure>

<h3 id="27请基于vue框架，实现一个父组件调用子组件方法的示例"><a href="#27请基于vue框架，实现一个父组件调用子组件方法的示例" class="headerlink" title="27请基于vue框架，实现一个父组件调用子组件方法的示例"></a>27请基于vue框架，实现一个父组件调用子组件方法的示例</h3><p> 方案一：通过ref直接调用子组件的方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件中</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;Button @click&#x3D;&quot;handleClick&quot;&gt;点击调用子组件方法&lt;&#x2F;Button&gt;</span><br><span class="line">        &lt;Child ref&#x3D;&quot;child&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;    </span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">import Child from &#39;.&#x2F;child&#39;;</span><br><span class="line">export default &#123;</span><br><span class="line">    methods: &#123;</span><br><span class="line">        handleClick() &#123;</span><br><span class="line">              this.$refs.child.sing();</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&#x2F;&#x2F;子组件中</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div&gt;我是子组件&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  methods: &#123;</span><br><span class="line">    sing() &#123;</span><br><span class="line">      console.log(&#39;我是子组件的方法&#39;);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>方案二：通过组件的$emit、$on方法；</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;父组件中&lt;template&gt;    &lt;div&gt;        &lt;Button @click&#x3D;&quot;handleClick&quot;&gt;点击调用子组件方法&lt;&#x2F;Button&gt;        &lt;Child ref&#x3D;&quot;child&quot;&#x2F;&gt;    &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;    &lt;script&gt;import Child from &#39;.&#x2F;child&#39;;export default &#123;    methods: &#123;        handleClick() &#123;               this.$refs.child.$emit(&quot;childmethod&quot;)    &#x2F;&#x2F;子组件$on中的名字        &#125;,    &#125;,&#125;&lt;&#x2F;script&gt;&#x2F;&#x2F;子组件中&lt;template&gt;    &lt;div&gt;我是子组件&lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;    mounted() &#123;        this.$nextTick(function() &#123;            this.$on(&#39;childmethods&#39;, function() &#123;                console.log(&#39;我是子组件方法&#39;);            &#125;);        &#125;);     &#125;,&#125;;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>至于项目中的$emit，是父子组件间传值</p>
<h3 id="29请实现对数组-a-2-a-1-a-0-a-10-a-2-1-按属性a从小到大排序。"><a href="#29请实现对数组-a-2-a-1-a-0-a-10-a-2-1-按属性a从小到大排序。" class="headerlink" title="29请实现对数组[{a:2},{a:1},{a:0},{a:10},{a:2.1}]按属性a从小到大排序。"></a>29请实现对数组[{a:2},{a:1},{a:0},{a:10},{a:2.1}]按属性a从小到大排序。</h3><h3 id="js实现二维数组去重"><a href="#js实现二维数组去重" class="headerlink" title="js实现二维数组去重"></a>js实现二维数组去重</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const removeRepeat1 &#x3D; (arr) &#x3D;&gt; &#123;  const obj&#x3D;&#123;&#125;;  return arr.filter(item&#x3D;&gt;&#123;    if(!obj[item.toString()]) &#123;      obj[item.toString()]&#x3D;item.toString();      return true;    &#125;  &#125;);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数组去重⽅法总结"><a href="#数组去重⽅法总结" class="headerlink" title="数组去重⽅法总结"></a>数组去重⽅法总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">⽅法⼀、利⽤ES6 Set去重（ES6中最常⽤）function unique (arr) &#123;	return Array.from(new Set(arr))&#125;或者[...new Set(arr)]⽅法⼆、利⽤for嵌套for，然后splice去重（ES5中最常⽤）function unique(arr)&#123;     for(var i&#x3D;0; i&lt;arr.length; i++)&#123;        for(var j&#x3D;i+1; j&lt;arr.length; j++)&#123;            if(arr[i]&#x3D;&#x3D;arr[j])&#123; &#x2F;&#x2F;第⼀个等同于第⼆个，splice⽅法删除                arr.splice(j,1);                j--;            &#125;        &#125;    &#125;    return arr;&#125;⽅法三、利⽤indexOf去重var array &#x3D; [];for (var i &#x3D; 0; i &lt; arr.length; i++) &#123;    if (array .indexOf(arr[i]) &#x3D;&#x3D;&#x3D; -1) &#123;    	array .push(arr[i])    &#125;    return array;&#125;⽅法四、利⽤includesvar array &#x3D;[];for(var i &#x3D; 0; i &lt; arr.length; i++) &#123;    if( !array.includes( arr[i]) ) &#123;&#x2F;&#x2F;includes 检测数组是否有某个值    	array.push(arr[i]);    &#125;    return array&#125;⽅法五、利⽤filterfunction unique(arr) &#123;    return arr.filter(function(item, index, arr) &#123;    	&#x2F;&#x2F;当前元素，在原始数组中的第⼀个索引&#x3D;&#x3D;当前索引值，否则返回当前元素    	return arr.indexOf(item, 0) &#x3D;&#x3D;&#x3D; index;    &#125;);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="32使用setTimeout模拟实现一个setInterval的功能"><a href="#32使用setTimeout模拟实现一个setInterval的功能" class="headerlink" title="32使用setTimeout模拟实现一个setInterval的功能"></a>32使用setTimeout模拟实现一个setInterval的功能</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setInterval &#x3D; () &#x3D;&gt;&#123;	    console.log(1)     &#x2F;&#x2F;使用递归	    setTimeout(setInterval,1000);&#125;;setInterval()</span><br></pre></td></tr></table></figure>

<h3 id="34请写出React16的新特性，至少五个"><a href="#34请写出React16的新特性，至少五个" class="headerlink" title="34请写出React16的新特性，至少五个"></a>34请写出React16的新特性，至少五个</h3><p>render方法新增返回类型</p>
<p>render方法支持直接返回string，number，boolean，null，portal，以及fragments(带有key属性的数组)，这可以在一定程度上减少页面的DOM层级</p>
<p>新的组件生命周期钩子</p>
<p>static getDerivedStateFromProps(nextProps, prevState)</p>
<p>componentDidCatch(error, info)</p>
<p>如果错误在组件的渲染或者生命周期方法中被抛出，则会触发该函数。</p>
<p>性能方面</p>
<p>lazy / Suspense</p>
<p>React.lazy() 提供了动态 import 组件的能力，实现代码分割。</p>
<p>Suspense 作用是在等待组件时 suspend（暂停）渲染，并显示加载标识。</p>
<p>React.Fragments</p>
<p>这样并不会在DOM中增加额外节点，相当于 render 返回数组元素。</p>
<h3 id="35请简述display-none和visibility-hidden对比的优缺点"><a href="#35请简述display-none和visibility-hidden对比的优缺点" class="headerlink" title="35请简述display: none和visibility: hidden对比的优缺点"></a>35请简述display: none和visibility: hidden对比的优缺点</h3><h3 id="36介绍下vuex以及应用的场景"><a href="#36介绍下vuex以及应用的场景" class="headerlink" title="36介绍下vuex以及应用的场景***"></a>36介绍下vuex以及应用的场景***</h3><p>Vuex 是一个专为 Vue.js应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到Vue 的官方调试工具 devtools extension ，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。当我们构建中大型SPA(单页面应用)项目时，Vuex则从中具有非常大的作用。</p>
<p>Vuex的应用场景</p>
<p>涉及到非父子组件之间的传值，例如兄弟关系、祖孙关系，甚至更远的关系组件之间的联系，如果使用传统父子组件之间传值的方式时，对开发人员来说可能是噩梦；</p>
<p>中大型单页应用，考虑如何更好地在组件外部管理状态；</p>
<h3 id="39闭包是什么-有什么特性-请简单书写一个简单实例"><a href="#39闭包是什么-有什么特性-请简单书写一个简单实例" class="headerlink" title="39闭包是什么,有什么特性,请简单书写一个简单实例"></a>39闭包是什么,有什么特性,请简单书写一个简单实例</h3><p>特性：闭包是能够读取其他函数内部变量的函数，即在外面可以调用函数中的函数的变量，其实他就是将函数内外部连接起来的桥梁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;事例：&lt;script type&#x3D;&#39;text&#x2F;javascript&#39;&gt;    function a()&#123;            var i &#x3D; 99;            iAdd &#x3D; function()&#123;            	i++;    	    &#125;            function b()&#123;                	alert(i);            &#125;    	    return b;    &#125;    var result &#x3D; a();    result();&#x2F;&#x2F;结果为99    iAdd();    result();&#x2F;&#x2F;结果为100&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="40ES5-的继承和-ES6-的继承有什么区别-？"><a href="#40ES5-的继承和-ES6-的继承有什么区别-？" class="headerlink" title="40ES5 的继承和 ES6 的继承有什么区别 ？"></a>40ES5 的继承和 ES6 的继承有什么区别 ？</h3><p>ES5 的继承时通过 prototype 或构造函数机制来实现。ES5 的继承实质上是先创建子类的实例对象，然后再将父类的方法添加到 this 上（Parent.apply(this)）。ES6 的继承机制完全不同，实质上是先创建父类的实例对象 this（所以必须先调用父类的 super()方法），然后再用子类的构造函数修改this。具体的：ES6 通过 class 关键字定义类，里面有构造方法，类之间通过 extends 关键字实现继承。子类必须在 constructor 方法中调用 super 方法，否则新建实例报错。因为子类没有自己的 this 对象，而是继承了父类的 this 对象，然后对其进行加工。如果不调用 super 方法，子类得不到 this 对象。ps：super 关键字指代父类的实例，即父类的 this 对象。在子类构造函数中，调用 super 后，才可使用 this 关键字，否则报错。</p>
<h3 id="107vue-router"><a href="#107vue-router" class="headerlink" title="107vue-router"></a><strong>107vue-router</strong></h3><p>方式 hash history </p>
<p>跳转 this.$router.push()   &lt;router-link to=””&gt;&lt;/router-link&gt;</p>
<p>占位 &lt;router-view&gt;&lt;/router-view&gt;</p>
<h3 id="84动态路由hash-history区别"><a href="#84动态路由hash-history区别" class="headerlink" title="84动态路由hash history区别"></a><strong>84</strong>动态路由hash history区别</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/LazyPet/p/12170995.html">https://www.cnblogs.com/LazyPet/p/12170995.html</a></p>
<p>前端路由原理？两种实现⽅式有什么区别？</p>
<p>前端路由实现起来其实很简单，本质就是监听 URL 的变化，然后匹配路由规则，显示相应的⻚⾯，并且⽆须刷新⻚⾯。⽬前前端使⽤的路由就只有两种实现⽅式</p>
<p>Hash 模式</p>
<p><a target="_blank" rel="noopener" href="http://www.test.com/#/">www.test.com/#/</a> 就是 Hash URL ，当 # 后⾯的哈希值发⽣变化时，可以通过 onhashchange 事件来监听到 URL 的变化，从⽽进⾏跳转⻚⾯，并且⽆论哈希值如何变化，服务端接收到的 URL 请求永远是 <a target="_blank" rel="noopener" href="http://www.test.com/">www.test.com</a> </p>
<p>window.addEventListener(‘hashchange’, () =&gt; {</p>
<p>// … 具体逻辑</p>
<p>})</p>
<p>Hash 模式相对来说更简单，并且兼容性也更好</p>
<p>History 模式 History 模式是 HTML5 新推出的功能，主要使⽤ history.pushState和 history.replaceState 改变 URL 通过 History 模式改变 URL 同样不会引起⻚⾯的刷新，只会更新浏览器的历史记录。当⽤户做出浏览器动作时，⽐如点击后退按钮时会触发 popState 事件</p>
<p>两种模式对⽐</p>
<p>Hash 模式只可以更改 # 后⾯的内容， History 模式可以通过 API 设置任意的同源URL</p>
<p>History 模式可以通过 API 添加任意类型的数据到历史记录中， Hash 模式只能更改哈希值，也就是字符串</p>
<p>Hash 模式⽆需后端配置，并且兼容性好。 History 模式在⽤户⼿动输⼊地址或者刷新⻚⾯的时候会发起 URL 请求，后端需要配置 index.html ⻚⾯⽤于匹配不到静态资源的时候</p>
<p><strong>补</strong></p>
<p>computed 和 watch 区别</p>
<p>computed 是计算属性，依赖其他属性计算值，并且 computed 的值有缓存，只有当计算值变化才会返回内容。</p>
<p>watch 监听到值的变化就会执⾏回调，在回调中可以进⾏⼀些逻辑操作。</p>
<p>所以⼀般来说需要依赖别的属性来动态获得值的时候可以使⽤ computed ，对于监听到值的变化需要做⼀些复杂业务逻辑的情况可以使⽤ watch 。</p>
<p>另外 computer 和 watch 还都⽀持对象的写法，这种⽅式知道的⼈并不多。</p>
<p><strong>补</strong></p>
<p>keep-alive 组件有什么作⽤</p>
<p>如果你需要在组件切换的时候，保存⼀些组件的状态防⽌多次渲染，就可以使⽤ keepalive 组件包裹需要保存的组件。</p>
<p>对于 keep-alive 组件来说，它拥有两个独有的⽣命周期钩⼦函数，分别为 activated和 deactivated 。⽤ keep-alive 包裹的组件在切换时不会进⾏销毁，⽽是缓存到内存中并执⾏ deactivated 钩⼦函数，命中缓存渲染后会执⾏ actived 钩⼦函数。</p>
<h3 id="41怎么定义vue-router的动态路由-怎么获取传过来的动态参数"><a href="#41怎么定义vue-router的动态路由-怎么获取传过来的动态参数" class="headerlink" title="41怎么定义vue-router的动态路由?怎么获取传过来的动态参数?"></a>41怎么定义vue-router的动态路由?怎么获取传过来的动态参数?</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/m0_48560510/article/details/110354840">https://blog.csdn.net/m0_48560510/article/details/110354840</a><br>进入首页时两次加载一个文档，优化代码当是登录页面跳转过来的才加载，可以通过导航守卫来实现，还可以有三种方法，query传参 params传参和直接路径拼接this.$router.push(‘/index?from=login’)，说明是从登录页面过来的，带有login的参数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query传参，其实是get传参，在地址栏里会拼接登录地址this.$router.push(&#123; path: &#39;&#x2F;index&#39;, query: &#123;  from: &#39;login&#39; &#125;&#125;)params传参，路径没有进行拼接，但是是由参数的this.$router.push(&#123; name: &#39;index&#39;,不是路径，应该是路由的名称 params: &#123;  from: &#39;login&#39; &#125;</span><br></pre></td></tr></table></figure>

<p>})<br>获取参数时用this.$route，$route是路由实例，而$router是全局路由，整个路由都在里面（11-4）</p>
<p>可以通过<code>query</code>，<code>param</code>两种方式<br>区别：<code>query</code>通过<code>url</code>传参，刷新页面还在；<code>params</code>属性页面不在</p>
<p>params的类型：</p>
<ol>
<li><p>配置路由格式:<code>/router/:id</code></p>
</li>
<li><p>传递的方式：在<code>path</code>后面跟上对应的值</p>
</li>
<li><p>传递后形成的路径：<code>/router/123</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 动态路由params在App.vue中&lt;router-link :to&#x3D;&quot;&#39;&#x2F;user&#x2F;&#39;+userId&quot; replace&gt;用户&lt;&#x2F;router-link&gt;在index.js	&#123;	path:&quot;&#x2F;user&#x2F;:userid&quot;,	component:User,	&#125;</span><br></pre></td></tr></table></figure>

<p>跳转方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法1：&lt;router-link :to&#x3D;&quot;&#123; name: &#39;users&#39;, params: &#123; uname: wade &#125;&#125;&quot;&gt;按钮&lt;&#x2F;router-link&gt;&#x2F;&#x2F; 方法2：this.$router.push(&#123;name:&#39;users&#39;,params:&#123;uname:wade&#125;&#125;)&#x2F;&#x2F; 方法3：this.$router.push(&#39;&#x2F;user&#x2F;&#39; + wade)</span><br></pre></td></tr></table></figure>

<p>可以通过$route.params.userid 获取你说传递的值</p>
<p>query的类型</p>
<ol>
<li>配置路由格式:/router,也就是普通配置</li>
<li>传递的方式:对象中使用query的key作为传递方式</li>
<li>传递后形成的路径:/route?id=123</li>
</ol>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--动态路由-query --&gt;&#x2F;&#x2F;01-直接在router-link 标签上以对象的形式&lt;router-link :to&#x3D;&quot;&#123;path:&#39;&#x2F;profile&#39;,query:&#123;name:&#39;why&#39;,age:28,height:188&#125;&#125;&quot;&gt;档案&lt;&#x2F;router-link&gt;&#x2F;*    02-或者写成按钮以点击事件形式    &lt;button @click&#x3D;&#39;profileClick&#39;&gt;我的&lt;&#x2F;button&gt;    *&#x2F;  &#x2F;&#x2F;点击事件 profileClick()&#123;   this.$router.push(&#123;            path: &quot;&#x2F;profile&quot;,            query: &#123;                  name: &quot;kobi&quot;,                  age: &quot;28&quot;,                  height: 198            &#125;      &#125;); </span><br></pre></td></tr></table></figure>

<p>跳转方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法1：&lt;router-link :to&#x3D;&quot;&#123; name: &#39;users&#39;, params: &#123; uname: wade &#125;&#125;&quot;&gt;按钮&lt;&#x2F;router-link&gt;&#x2F;&#x2F; 方法2：this.$router.push(&#123;name:&#39;users&#39;,params:&#123;uname:wade&#125;&#125;)&#x2F;&#x2F; 方法3：this.$router.push(&#39;&#x2F;user&#x2F;&#39; + wade)</span><br></pre></td></tr></table></figure>

<p>可以通过$route.query 获取你所传递的值</p>
<h3 id="44vue-router有哪几种导航钩子，导航钩子的作用是什么？"><a href="#44vue-router有哪几种导航钩子，导航钩子的作用是什么？" class="headerlink" title="44vue-router有哪几种导航钩子，导航钩子的作用是什么？"></a>44vue-router有哪几种导航钩子，导航钩子的作用是什么？</h3><p>vue-router提供的导航钩子主要用来拦截导航，让它完成跳转或取消。</p>
<p>导航钩子的分类</p>
<ul>
<li>全局守卫        简单点说就是触发路由就会触发这些钩子函数。钩子函数执行顺序包括beforeEach、beforeResolve、afterEach三个。</li>
<li>路由独享守卫</li>
<li>局部守卫</li>
</ul>
<h3 id="93如何配置React-Router"><a href="#93如何配置React-Router" class="headerlink" title="93如何配置React-Router"></a>93如何配置React-Router</h3><p>yarn add react-router-dom</p>
<p>在最外面的App.js里</p>
<p>import { BrowserRouter, Route } from ‘react-router-dom’；</p>
<p>在组件的render()里</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BrowserRouter&gt;	&lt;div&gt;		&lt;Route path&#x3D;&#39;&#x2F;&#39; exact render&#x3D;&#123;()&#x3D;&gt;&lt;div&gt;home&lt;&#x2F;div&gt;&#125;&gt;&lt;&#x2F;Route&gt;		&lt;Route path&#x3D;&#39;&#x2F;detail&#39; exact render&#x3D;&#123;()&#x3D;&gt;&lt;div&gt;detail&lt;&#x2F;div&gt;&#125;&gt;&lt;&#x2F;Route&gt;	&lt;&#x2F;div&gt; &lt;&#x2F;BrowserRouter&gt;</span><br></pre></td></tr></table></figure>

<p>代表的是路由说明里面内容要用路由了，它里面只能有一个children</p>
<p>Route代表的是路由规则</p>
<p>exact指只有路径完全相同才显示，否则只要路径包含就显示（8-1）</p>
<p>单页面应用就不能用&lt;a href=’/detail’&gt;…&lt;/a&gt;</p>
<p>要使用Link</p>
<p>import { Link } from ‘react-router-dom’；</p>
<p>&lt;Link to=’/detail’&gt;…&lt;/Link&gt;</p>
<p>注意:使用Link标签的组件必须放在总的文件&lt;BrowserRouter&gt;&lt;/BrowserRouter&gt;内部（8-10）</p>
<h3 id="96react-router⾥的-lt-Link-gt-标签和-lt-a-gt-标签有什么区别"><a href="#96react-router⾥的-lt-Link-gt-标签和-lt-a-gt-标签有什么区别" class="headerlink" title="96react-router⾥的&lt;Link&gt;标签和&lt;a&gt;标签有什么区别"></a><strong>96react-router</strong>⾥的&lt;Link&gt;标签和&lt;a&gt;标签有什么区别</h3><p>对比&lt;a&gt;,Link组件避免了不必要的重渲染 react-router：只更新变化的部分从而减少DOM性能消耗</p>
<p>react的创新之处在于，它利用虚拟DOM的概念和diff算法实现了页面的“按需加载”</p>
<h3 id="42Vue引入了虚拟Dom主要解决了什么问题"><a href="#42Vue引入了虚拟Dom主要解决了什么问题" class="headerlink" title="42Vue引入了虚拟Dom主要解决了什么问题"></a>42Vue引入了虚拟Dom主要解决了什么问题</h3><h3 id="43输出结果"><a href="#43输出结果" class="headerlink" title="43输出结果"></a>43输出结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var test &#x3D; (function (a) &#123;	    this.a &#x3D; a;	    return function (b) &#123;		        return this.a + b;	    &#125;&#125;(function(a, b) &#123;	        return a;&#125;(1, 2)));console.log(test(4));</span><br></pre></td></tr></table></figure>

<p>输出结果：5（1+4）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function(a, b) &#123;		return a;&#125;(1, 2))回的是1，传给atest相当于test &#x3D; function (b) &#123;		return this.a + b;&#125;b是4</span><br></pre></td></tr></table></figure>

<h3 id="45vue-loader是什么？使用它的途径有哪些？"><a href="#45vue-loader是什么？使用它的途径有哪些？" class="headerlink" title="45vue-loader是什么？使用它的途径有哪些？"></a>45vue-loader是什么？使用它的途径有哪些？</h3><p>一、vue-loader作用：</p>
<p>解析和转换.vue文件。提取出其中的逻辑代码 script,样式代码style,以及HTML 模板template，再分别把他们交给对应的loader去处理</p>
<p>二、用途</p>
<p>js可以写es6,style样式可以写scss或less、template可以加jade等</p>
<p>三、</p>
<p>css-loader：加载由vue-loader提取出的CSS代码</p>
<p>vue-template-compiler：把vue-loader提取出的HTML模板编译成可执行的javascript代码</p>
<h3 id="30请写出删除数组元素的几种原生算法"><a href="#30请写出删除数组元素的几种原生算法" class="headerlink" title="30请写出删除数组元素的几种原生算法"></a>30请写出删除数组元素的几种原生算法</h3><p>splice(index,len,[item])  注释：该方法会改变原始数组。注：concat不会改变原数组，需要有个变量来承接一下。</p>
<p>delete arr[1] delete删除掉数组中的元素后，会把该下标出的值置为undefined,数组的长度不会变</p>
<h3 id="46delete和Vue-delete删除数组的区别"><a href="#46delete和Vue-delete删除数组的区别" class="headerlink" title="46delete和Vue.delete删除数组的区别"></a>46delete和Vue.delete删除数组的区别</h3><p>delete只是被删除的元素变成了 empty/undefined 其他的元素的键值还是不变。</p>
<p>Vue.delete 直接删除了数组 改变了数组的键值。</p>
<h3 id="50使用选择排序或冒泡排序方法对数组let-arr-3-5-1-9-4-2-进行排序"><a href="#50使用选择排序或冒泡排序方法对数组let-arr-3-5-1-9-4-2-进行排序" class="headerlink" title="50使用选择排序或冒泡排序方法对数组let arr = [3, 5, 1, 9, 4, 2]进行排序"></a>50使用选择排序或冒泡排序方法对数组let arr = [3, 5, 1, 9, 4, 2]进行排序</h3><h3 id="52介绍一下Vue组件的生命周期"><a href="#52介绍一下Vue组件的生命周期" class="headerlink" title="52介绍一下Vue组件的生命周期"></a>52介绍一下Vue组件的生命周期</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/qidh/p/11431998.html">https://www.cnblogs.com/qidh/p/11431998.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/wangjiachen666/p/9497749.html">https://www.cnblogs.com/wangjiachen666/p/9497749.html</a></p>
<hr>
<h3 id="53使用CSS的flexbox布局，不能实现以下哪一个效果："><a href="#53使用CSS的flexbox布局，不能实现以下哪一个效果：" class="headerlink" title="53使用CSS的flexbox布局，不能实现以下哪一个效果："></a>53使用CSS的flexbox布局，不能实现以下哪一个效果：</h3><p>A、三列布局，随容器宽度等宽弹性伸缩</p>
<p>B、多列布局，每列的高度按内容最高的一列等高</p>
<p>C、三列布局，左列宽度像素数确定，中、右列随容器宽度等宽弹性伸缩</p>
<p>D、多个宽高不等的元素，实现无缝瀑布流布局</p>
<p><strong>答案：D</strong></p>
<h3 id="54下面关于this的说法错误的是A"><a href="#54下面关于this的说法错误的是A" class="headerlink" title="54下面关于this的说法错误的是A"></a>54下面关于this的说法错误的是A</h3><p>A．严格模式下，普通函数中没有直接调用者的函数中this指向window</p>
<p>B.普通函数中this指向它的直接调用者</p>
<p>C.普通函数中使用call绑定的this指向绑定的对象</p>
<p>D.箭头函数中的this指向定义它时所处的宿主对象</p>
<p>A为undefined</p>
<h3 id="55new-Date-‘yyyy-mm-dd’-返回本地时间，new-Date-‘yyyy-mm-dd’-返回UTC时间"><a href="#55new-Date-‘yyyy-mm-dd’-返回本地时间，new-Date-‘yyyy-mm-dd’-返回UTC时间" class="headerlink" title="55new Date(‘yyyy-mm-dd’)返回本地时间，new Date(‘yyyy/mm/dd’)返回UTC时间"></a>55new Date(‘yyyy-mm-dd’)返回本地时间，new Date(‘yyyy/mm/dd’)返回UTC时间</h3><h3 id="56返回a1-undefined-a2"><a href="#56返回a1-undefined-a2" class="headerlink" title="56返回a1 undefined a2"></a>56返回a1 undefined a2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; &#123;  a: &#39;a1&#39;,  b: function () &#123;return this.a&#125;,  c: function (obj) &#123;    obj &#x3D; &#123;a : &#39;a2&#39;&#125;;    return this.a;  &#125;&#125;var getFunctionB &#x3D; obj1.b;var res1 &#x3D; obj1.b();var res2 &#x3D; getFunctionB();var res3 &#x3D; obj1.c(obj1);</span><br></pre></td></tr></table></figure>

<h3 id="57"><a href="#57" class="headerlink" title="57"></a>57</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var dateStr &#x3D; &#39;Friday&#39;;(function () &#123;  if (typeOf dateStr &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;    var dateStr &#x3D; &#39;Staurday&#39;;    console.log(&#39;Hello&#39; + dateStr);  &#125;else &#123;    console.log(&#39;Happy&#39; + dateStr);  &#125;&#125;)();输出’Hello Staurday’var str &#x3D; &#39;World!&#39;;    (function (name) &#123;  if (typeof name &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;    var name &#x3D; &#39;Jack&#39;;    console.log(&#39;Goodbye &#39; + name);  &#125; else &#123;    console.log(&#39;Hello &#39; + name);  &#125;&#125;)(str);输出Hello World 因为name已经变成函数内局部变量</span><br></pre></td></tr></table></figure>

<h3 id="58ES6内部使用严格相等运算符（-），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。"><a href="#58ES6内部使用严格相等运算符（-），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。" class="headerlink" title="58ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。"></a>58<a target="_blank" rel="noopener" href="http://www.51code.com/">ES6</a>内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</h3><p>var [x, y = “b”] = [“a”, undefined];//x = “a”, y = “b” </p>
<p>var [x = 1] = [undefined];//x = 1</p>
<p>var [y = 1] = [null];//y = null</p>
<h3 id="59冒泡排序、选择排序、快速排序"><a href="#59冒泡排序、选择排序、快速排序" class="headerlink" title="59冒泡排序、选择排序、快速排序"></a>59冒泡排序、选择排序、快速排序</h3><p>排序算法的稳定性，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj, Ai原来在位置前，排序后Ai还是要在Aj位置前。</p>
<h3 id="60div嵌套，居中布局有几种方式，各自的适合范围和问题"><a href="#60div嵌套，居中布局有几种方式，各自的适合范围和问题" class="headerlink" title="60div嵌套，居中布局有几种方式，各自的适合范围和问题"></a>60div嵌套，居中布局有几种方式，各自的适合范围和问题</h3><p>margin： auto;</p>
<p>flex</p>
<p>绝对定位，反方向平移宽和高的一半</p>
<p>table vertical-align: middle;</p>
<h3 id="20-如何垂直居中⼀个浮动元素-？"><a href="#20-如何垂直居中⼀个浮动元素-？" class="headerlink" title="20 如何垂直居中⼀个浮动元素***？"></a>20 如何垂直居中⼀个浮动元素***？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**⽅法⼀：已知元素的⾼宽**&#x2F;\#div1&#123; background-color:#6699FF; width:200px; height:200px; position: absolute; &#x2F;&#x2F;⽗元素需要相对定位 top: 50%; left: 50%; margin-top:-100px ; &#x2F;&#x2F;⼆分之⼀的height，width margin-left: -100px;&#125;&#x2F;&#x2F;不知道宽高  width: 78px;  height: 78px;  position: absolute;  left: 50%;  top: 50%;  transform: translateX(-50%) translateY(-50%);&#x2F;&#x2F;display:flex;justify-content: center;align-items: center; &#x2F;**⽅法⼆:**&#x2F;\#div1&#123; width: 200px; height: 200px; background-color: #6699FF; margin:auto; position: absolute; &#x2F;&#x2F;⽗元素需要相对定位***</span><br></pre></td></tr></table></figure>

<p>如何垂直居中⼀个 &lt;img&gt; ?（⽤更简便的⽅法。）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#container &#123;	display: table-cell;	text-align: center;	verticle-align: middle;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h5><ul>
<li>行内元素: <code>text-align: center</code></li>
<li>块级元素: <code>margin: 0 auto</code></li>
<li>position:absolute +left:50%+ transform:translateX(-50%)</li>
<li><code>display:flex + justify-content: center</code></li>
</ul>
<h5 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a><strong>垂直居中</strong></h5><ul>
<li>设置line-height 等于height</li>
<li>position：absolute +top:50%+ transform:translateY(-50%)</li>
<li><code>display:flex + align-items: center</code></li>
<li>display:table+display:table-cell + vertical-align: middle;</li>
</ul>
<h3 id="62http返回的状态有几种，403、401、302、304"><a href="#62http返回的状态有几种，403、401、302、304" class="headerlink" title="62http返回的状态有几种，403、401、302、304"></a>62http返回的状态有几种，403、401、302、304</h3><h3 id="64输入1返回2，输入2返回1，有几种方法"><a href="#64输入1返回2，输入2返回1，有几种方法" class="headerlink" title="64输入1返回2，输入2返回1，有几种方法"></a>64输入1返回2，输入2返回1，有几种方法</h3><h3 id="65自适应布局几种方法，使用范围，左侧200px，右侧自适应"><a href="#65自适应布局几种方法，使用范围，左侧200px，右侧自适应" class="headerlink" title="65自适应布局几种方法，使用范围，左侧200px，右侧自适应"></a>65自适应布局几种方法，使用范围，左侧200px，右侧自适应</h3><h3 id="71sort排序"><a href="#71sort排序" class="headerlink" title="71sort排序"></a>71sort排序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;升序arr.sort((a, b) &#x3D;&gt; &#123;return a-b;&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="79不用组件怎么实现轮播图，当鼠标停留在图片上时怎么实现图片轮播不动"><a href="#79不用组件怎么实现轮播图，当鼠标停留在图片上时怎么实现图片轮播不动" class="headerlink" title="79不用组件怎么实现轮播图，当鼠标停留在图片上时怎么实现图片轮播不动"></a><strong>79</strong>不用组件怎么实现轮播图，当鼠标停留在图片上时怎么实现图片轮播不动</h3><p>可以使用js和无序列表的方式;CSS动画过渡的方式，仔细看这两种实现方式的代码</p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/bd1f34e7e953">https://www.jianshu.com/p/bd1f34e7e953</a></p>
<h3 id="80v-if-v-show-区别"><a href="#80v-if-v-show-区别" class="headerlink" title="80v-if v-show 区别"></a><strong>80v-if v-show</strong> <strong>区别</strong></h3><p>v-show 只是在 display: none 和 display: block 之间切换。⽆论初始条件是什么</p>
<p>都会被渲染出来，后⾯只需要切换 CSS ， DOM 还是⼀直保留着的。所以总的来说 v-show 在初始渲染时有更⾼的开销，但是切换开销很⼩，更适合于频繁切换的场景。</p>
<p>v-if 的话就得说到 Vue 底层的编译了。当属性初始为 false 时，组件就不会被渲染，直到条件为 true ，并且切换条件时会触发销毁/挂载组件，所以总的来说在切换时开销更⾼，更适合不经常切换的场景。并且基于 v-if 的这种惰性渲染机制，可以在必要的时候才去渲染组件，减少整个⻚⾯的初始渲染开销。</p>
<h3 id="81key作用"><a href="#81key作用" class="headerlink" title="81key作用"></a><strong>81key</strong>作用</h3><h3 id="85-都有哪些指令"><a href="#85-都有哪些指令" class="headerlink" title="85 都有哪些指令"></a><strong>85</strong> <strong>都有哪些指令</strong></h3><h3 id="86如何判断类型"><a href="#86如何判断类型" class="headerlink" title="86如何判断类型"></a><strong>86</strong>如何判断类型</h3><h3 id="87置换元素-哈希-require-js-common-js-AMD-CMD"><a href="#87置换元素-哈希-require-js-common-js-AMD-CMD" class="headerlink" title="87置换元素  哈希  require.js common.js AMD CMD"></a><strong>87</strong>置换元素  哈希  require.js common.js AMD CMD</h3><p><strong>置换元素</strong>是指根据标签和属性来决定元素的具体显示内容，置换元素在其显示中生成了框，这就是有的内嵌元素能够设置宽高的原因。元素img input textarea select object。大多数元素都是不可置换。label p</p>
<p>一个对象在其生命周期内，保持不变就是可哈希的hashable，例如字符串。可改变的就是不可哈希的unhashable，列表</p>
<p>require.js是js的轻量化框架，用于提高代码质量</p>
<p>CommonJS、AMD、CMD是用于JavaScript模块管理的三大规范</p>
<p>CommonJS定义的是模块的同步加载，是一个更偏向于服务器端的规范（也可以在浏览器中使用），主要用于Nodejs，根据CommonJS规范，一个单独的文件就是一个模块，加载模块使用require()方法，该方法读取一个文件并执行，最后返回文件内部的exports对象。</p>
<p>AMD和CMD则是定义模块异步加载适用于浏览器端，都是为了 JavaScript 的模块化开发，（这里说一下为什要有异步加载，因为浏览器如果使用common.js同步加载模块的话，就会导致性能等问题，所以针对这个问题，又出了一个规范，这个规范可以实现异步加载依赖模块）</p>
<p>AMD规范会提前加载依赖模块，AMD规范是通过requireJs 在推广过程中对模块定义的规范化产出。RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。推崇依赖前置。AMD 推荐的⻛格通过返回⼀个对象做为模块对象</p>
<p>CMD规范会延迟加载依赖模块， CMD 规范是 SeaJs 在推广过程中对模块定义的规范化产出。推崇依赖就近。 CommonJS 的⻛格通过对module.exports 或 exports 的属性赋值来达到暴露模块对象的⽬的</p>
<h3 id="88对async、await的理解，内部原理"><a href="#88对async、await的理解，内部原理" class="headerlink" title="88对async、await的理解，内部原理"></a>88对async、await的理解，内部原理</h3><p>async函数就是generator函数的语法糖。</p>
<p>async函数，就是将generator函数的*换成async，将yield替换成await。</p>
<p>async函数对generator的改进</p>
<p>(1)内置执行器，不需要使用next()手动执行。</p>
<p>(2)await命令后面可以是Promise对象或原始类型的值，yield命令后面只能是Thunk函数或Promise对象。</p>
<p>(3)返回值是Promise。返回非Promise时，async函数会把它包装成Promise返回。(Promise.resolve(value))</p>
<p>作用</p>
<p>异步编程的终极解决方案。</p>
<p>通俗理解</p>
<p>async/await，就是异步编程回调函数写法的替代方法。（使代码以同步方式的写法完成异步操作）函数执行时，一旦遇到await就会返回。等到触发的异步操作完成（并且调用栈清空），再接着执行函数体内后面的语句。</p>
<p>await语句后面的代码，相当于回调函数。（即：await的下一行开始，都视作回调函数的内容）</p>
<p>回调函数会被压入microtask队列，当主线程调用栈被清空时，去microtask队列里取出各个回调函数，逐个执行。</p>
<h3 id="91redux的设计思想-接⼊redux的过程-绑定connect的过程"><a href="#91redux的设计思想-接⼊redux的过程-绑定connect的过程" class="headerlink" title="91redux的设计思想 接⼊redux的过程 绑定connect的过程"></a><strong>91redux的设计思想</strong> <strong>接⼊redux的过程</strong> <strong>绑定connect的过程</strong></h3><p>Redux是什么呢？一个状态管理工具。那是干嘛用的呢？都知道，React可以进行单页应用(SPA)的开发，可以对页面中各个模块进行分割形成组件，而组件之间就避免不了事件的传递或数据的交互，那Redux就是用来对这些组件的状态进行管理的。</p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000008736866">https://segmentfault.com/a/1190000008736866</a></p>
<h3 id="92webpack介绍"><a href="#92webpack介绍" class="headerlink" title="92webpack介绍"></a><strong>92webpack介绍</strong></h3><p>WebPack 是⼀个模块打包⼯具，你可以使⽤ WebPack 管理你的模块依赖，并编绎输出模块们所需的静态⽂件。它能够很好地管理、打包 Web 开发中所⽤到的 HTML 、Javascript 、 CSS 以及各种静态⽂件（图⽚、字体等），让开发过程更加⾼效。对于不同类型的资源， webpack 有对应的模块加载器。 webpack 模块打包器会分析模块间的依赖关系，最后⽣成了优化且合并后的静态资源</p>
<h3 id="95promise、async有什么区别"><a href="#95promise、async有什么区别" class="headerlink" title="95promise、async有什么区别"></a>95promise、async有什么区别</h3><p> 函数前面多了一个async关键字。await关键字只能用在async定义的函数内。async函数会引式返回一个promise,改promise的resolve值就是函数return的值。</p>
<p> 简洁：使用async和await明显节约了不少代码，不需要.then,不需要写匿名函数处理promise的resolve的值，不需要定义多余的data变量，还避免了嵌套代码。</p>
<p> async/await让try/catch 可以同时处理同步和异步错误。try/catch不能处理JSON.parse的错误，因为他在promise中。此时需要.catch，这样的错误处理代码非常冗余。并且，在我们的实际生产代码会更加复杂</p>
<p> 条件语句</p>
<h3 id="97cookie放哪⾥"><a href="#97cookie放哪⾥" class="headerlink" title="97cookie放哪⾥"></a>97cookie放哪⾥</h3><p>设置过期时间失效(只要设置了过期时间cookie就会存储在硬盘里面)</p>
<p>当会话结束时失效，即关闭浏览器窗口(如果没有设置Expires，cookie就会存储在内存里面)</p>
<h3 id="103-es5异步编码的方式"><a href="#103-es5异步编码的方式" class="headerlink" title="103 es5异步编码的方式"></a><strong>103 es5异步编码的方式</strong></h3><p>回调函数，这是异步编程最基本的方法。</p>
<p>事件监听，另一种思路是采用事件驱动模式。任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>
<p>发布/订阅</p>
<p>Promises对象，Promises 对象是CommonJS 工作组提出的一种规范，目的是为异步编程提供统一接口。</p>
<p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1499717">https://cloud.tencent.com/developer/article/1499717</a></p>
<h4 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h4><p>promise  generator  async</p>
<h3 id="104js常见的内存泄漏"><a href="#104js常见的内存泄漏" class="headerlink" title="104js常见的内存泄漏"></a><strong>104js常见的内存泄漏</strong></h3><p>意外的全局变量引起的内存泄露leak=”xxx”;<em>//leak**成为一个全局变量，不会被回收</em></p>
<p>闭包</p>
<p>没有清理的DOM元素引用</p>
<p>定时器的第一个参数不是函数而是字符串</p>
<p>循环(在两个对象彼此引用且彼此保留时，就会产生一个循环)</p>
<p>子元素存在引起的内存泄露</p>
<p>可⽤ chrome 中的 timeline 进⾏内存标记，可视化查看内存的变化情 况，找出异常点。</p>
<p>怎样避免内存泄露</p>
<p>1）减少不必要的全局变量，或者生命周期较长的对象，及时对无用的数据进行垃圾回收；</p>
<p>2）注意程序逻辑，避免“死循环”之类的 ；</p>
<p>3）避免创建过多的对象 原则：不用了的东西要及时归还。</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/michael8512/article/details/77888000">https://blog.csdn.net/michael8512/article/details/77888000</a></p>
<h3 id="105前端工程化"><a href="#105前端工程化" class="headerlink" title="105前端工程化"></a><strong>105前端工程化</strong></h3><p>模块化 js scss </p>
<p>组件化 </p>
<p>规范化 HTML css js规范 命名规范 前后端接口规范</p>
<p>自动化</p>
<h3 id="106函数调用的方式"><a href="#106函数调用的方式" class="headerlink" title="106函数调用的方式"></a><strong>106函数调用的方式</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;方法调用模式var blogInfo&#x3D;&#123;　　blogId:123,　　blogName:&quot;werwr&quot;,　　showBlog:function()&#123;alert(this.blogId);&#125;&#125;;blogInfo.showBlog();&#x2F;&#x2F;函数调用模式var myfunc &#x3D; function(a,b)&#123;　　return a+b;&#125;alert(myfunc(3,4));&#x2F;&#x2F;构造器调用模式var myfunc &#x3D; function(a)&#123;　　this.a &#x3D; a;&#125;;myfunc.prototype &#x3D; &#123;　　show:function()&#123;alert(this.a);&#125;&#125;var newfunc &#x3D; new myfunc(&quot;123123123&quot;);newfunc.show();&#x2F;&#x2F;apply,call调用模式var myobject&#x3D;&#123;&#125;;var sum &#x3D; function(a,b)&#123;　　return a+b;&#125;;var sum2 &#x3D; sum.call(myobject,10,30); &#x2F;&#x2F;var sum2 &#x3D; sum.apply(myobject,[10,30]); alert(sum2);</span><br></pre></td></tr></table></figure>

<h3 id="108动画的例子，好好看一下，会手写"><a href="#108动画的例子，好好看一下，会手写" class="headerlink" title="108动画的例子，好好看一下，会手写"></a><strong>108动画的例子，好好看一下，会手写</strong></h3><p>#div:hover {} //hover的位置</p>
<h3 id="110"><a href="#110" class="headerlink" title="110"></a><strong>110</strong></h3><p>var cityData = [{</p>
<p>​    id: 1,</p>
<p>​    name: ‘广东省’,</p>
<p>​    children: [{</p>
<p>​      id: 11,</p>
<p>​      name: ‘深圳’}]</p>
<p>}]</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;直接想到用递归来做吧~，先获取最外层的元素，判断id是否相等，不相等就继续判断是否含有子节点，然后继续递归循坏const recursion &#x3D; (cityData, id) &#x3D;&gt; &#123;    if (!cityData || !cityData.length) &#123;    	return;    &#125;    &#x2F;&#x2F;先循坏cityData    for (let i &#x3D; 0; i &lt; cityData.length; i++) &#123;        const childs &#x3D; cityData[i].children;        if (cityData[i].id &#x3D;&#x3D;&#x3D; id) &#123;        	result &#x3D; cityData[i].name;        &#125;        if (childs &amp;&amp; childs.length &gt; 0) &#123;        	recursion(childs, id);        &#125;    &#125;      return result;&#125;console.log(recursion(cityData, 122))&#x2F;&#x2F;灵芝</span><br></pre></td></tr></table></figure>

<h3 id="113vue模板语法底层是怎么实现的"><a href="#113vue模板语法底层是怎么实现的" class="headerlink" title="113vue模板语法底层是怎么实现的"></a>113vue模板语法底层是怎么实现的</h3><p> Vue的MVVM模型讲的是 model（数据模型），view（视图、模板），VM-&gt; ViewModel，VM是M和V之间的桥梁</p>
<p>响应式 ：vue如何监听到data的每个属性变化？</p>
<p>利用Object.defineProperty定义属性，将data里面的属性代理到vm上</p>
<p>模板解析： vue的模板如何被解析，指令如何处理？</p>
<ol>
<li>vue里面为什么要解析模板？</li>
</ol>
<p>这个模板里的html有逻辑，v-for, v-if等等，最终必须解析成html来显示，模板最终必须转换成 JS 代码</p>
<p>因为：</p>
<p>有逻辑（v-if v-for）,必须用 JS 才能实现( 图灵完备)</p>
<p>转换为 html 渲染页面，必须用 JS 才能实现</p>
<p>因此，模板最重要转换成一个 JS 函数</p>
<ol start="2">
<li>render函数</li>
</ol>
<p>with 用法：with 语句可以方便地用来引用某个特定对象中已有的属性，但是不能用来给对象添加属性。要给对象创建新的属性，必须明确地引用该对象。</p>
<p>render 函数</p>
<p>VUE一般使用template来创建HTML，然后在有的时候，我们需要使用javascript来创建html，这时候我们需要使用render函数。</p>
<p><strong>Vue的实现流程</strong></p>
<p>1、首先模板解析器解析成render函数</p>
<p>2、响应式监听</p>
<p>3、将数据渲染进模板里</p>
<p>4、data属性变化，触发render</p>
<h3 id="114-vue中action和mutation的区别"><a href="#114-vue中action和mutation的区别" class="headerlink" title="114 vue中action和mutation的区别"></a>114 vue中action和mutation的区别</h3><p>action是处理异步任务的或者繁琐的同步任务的</p>
<p>mutation是处理同步任务的</p>
<h3 id="115https是怎么加密的"><a href="#115https是怎么加密的" class="headerlink" title="115https是怎么加密的"></a>115https是怎么加密的</h3><p><strong>对称加密</strong></p>
<p><strong>非对称加密</strong></p>
<p><strong>对称加密+非对称加密结合</strong></p>
<p> <a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_29996285/article/details/84284524">https://blog.csdn.net/qq_29996285/article/details/84284524</a></p>
<h3 id="116-rem-em相关知识（看书）"><a href="#116-rem-em相关知识（看书）" class="headerlink" title="116 rem em相关知识（看书）"></a>116 rem em相关知识（看书）</h3><h3 id="117url页面流程"><a href="#117url页面流程" class="headerlink" title="117url页面流程"></a>117url页面流程</h3><p>浏览器先查找当前的url是否存在缓存，并比较缓存是否过期</p>
<p>没有缓存，浏览器将当前的url发送给DNS服务器解析url对应的IP地址</p>
<p>根据IP地址建立TCP连接</p>
<p>HTTP发起请求</p>
<p>服务器处理请求，浏览器接收HTTP响应</p>
<p>渲染页面，构建DOM树</p>
<p>关闭TCP连接</p>
<h3 id="118-vue中nextTick-process-nextTick"><a href="#118-vue中nextTick-process-nextTick" class="headerlink" title="118 vue中nextTick()   process.nextTick"></a>118 vue中nextTick()   process.nextTick</h3><p>vue中nextTick()方法是将回调函数延迟在下一次dom更新数据后调用，简单的理解是：<strong>当数据更新了，在dom中渲染后，自动执行该函数，</strong></p>
<p>process.nextTick()的意思就是定义出一个动作，并且让这个动作在下一个事件轮询的时间点上执行。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;    console.error(&#x27;foo&#x27;);&#125;process.nextTick(foo);console.error(&#x27;bar&#x27;);//先输出&#x27;bar&#x27;，再输出&#x27;foo&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="119HTTP-2-0"><a href="#119HTTP-2-0" class="headerlink" title="119HTTP / 2.0"></a>119HTTP / 2.0</h3><p>因为浏览器会有并发请求限制，在 HTTP / 1.1 时代，每个请求都需要建⽴和断开，消耗了好⼏个 RTT 时间，并且由于 TCP 慢启动的原因，加载体积⼤的⽂件会需要更多的时间<br>在 HTTP / 2.0 中引⼊了多路复⽤，能够让多个请求使⽤同⼀个 TCP 链接，极⼤的加快了⽹⻚的加载速度。</p>
<p>并且还⽀持 Header 压缩，进⼀步的减少了请求的数据⼤⼩</p>
<h3 id="120查找两个字符串的最长公共子串的JavaScript函数"><a href="#120查找两个字符串的最长公共子串的JavaScript函数" class="headerlink" title="120查找两个字符串的最长公共子串的JavaScript函数"></a>120查找两个字符串的最长公共子串的JavaScript函数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function findLongestCommonStr(s1, s2) &#123;    var commonStr &#x3D; &#39;&#39;, L1 &#x3D; s1.length, L2 &#x3D; s2.length;    var shortStr &#x3D; L1&gt;L2 ? s2 : s1;    var longStr &#x3D; L1&gt;L2 ? s1 : s2;    var strLen &#x3D; shortStr.length;    for (let j &#x3D; strLen; j &gt; 0; j--) &#123;        for (let i &#x3D; 0, k &#x3D; j; i &lt;&#x3D; strLen - j; i++, k++) &#123;            commonStr &#x3D; shortStr.subString(i, k);            if (longStr.indexOf(commonStr) &gt;&#x3D; 0) return commonStr;        &#125;    &#125;    return &#39;&#39;;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="121"><a href="#121" class="headerlink" title="121"></a>121</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;主线程直接执行console.log(&#39;1&#39;);&#x2F;&#x2F;丢到宏事件队列中setTimeout(function() &#123;    console.log(&#39;2&#39;);    process.nextTick(function() &#123;        console.log(&#39;3&#39;);    &#125;)    new Promise(function(resolve) &#123;        console.log(&#39;4&#39;);        resolve();    &#125;).then(function() &#123;        console.log(&#39;5&#39;)    &#125;)&#125;)&#x2F;&#x2F;微事件1process.nextTick(function() &#123;    console.log(&#39;6&#39;);&#125;)&#x2F;&#x2F;主线程直接执行new Promise(function(resolve) &#123;    console.log(&#39;7&#39;);    resolve();&#125;).then(function() &#123;    &#x2F;&#x2F;微事件2    console.log(&#39;8&#39;)&#125;)&#x2F;&#x2F;丢到宏事件队列中setTimeout(function() &#123;    console.log(&#39;9&#39;);    process.nextTick(function() &#123;        console.log(&#39;10&#39;);    &#125;)    new Promise(function(resolve) &#123;        console.log(&#39;11&#39;);        resolve();    &#125;).then(function() &#123;        console.log(&#39;12&#39;)    &#125;)&#125;)&#x2F;&#x2F;1 7 6 8 2 4 3 5 9 11 10 12</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async function async1() &#123;  console.log(&#39;async1 start&#39;)  await async2()  console.log(&#39;async1 end&#39;)&#125; async function async2() &#123;  console.log(&#39;async2&#39;)&#125; console.log(&#39;script start&#39;)setTimeout(function() &#123;  console.log(&#39;setTimeout&#39;)&#125;, 0) async1();    new Promise( function( resolve ) &#123; console.log(&#39;promise1&#39;) resolve();&#125; ).then( function() &#123; console.log(&#39;promise2&#39;)&#125; ) console.log(&#39;script end&#39;)script startasync1 startasync2promise1script endpromise2async1 endsetTimeout首先，事件循环从宏任务（macrostack）队列开始，这个时候，宏任务队列中，只有一个 script (整体代码)任务。从宏任务队列中取出一个任务来执行。首先执行 console.log(&#39;script start&#39;)，输出 ‘script start&#39;遇到 setTimeout 把 console.log(&#39;setTimeout&#39;) 放到 macrotask 队列中执行 aync1() 输出 ‘async1 start&#39; 和 &#39;async2&#39; ,把 console.log(&#39;async1 end&#39;) 放到 micro 队列中执行到 promise ，输出 &#39;promise1&#39; ，把 console.log(&#39;promise2&#39;) 放到  micro 队列中执行 console.log(&#39;script end&#39;)，输出 ‘script end&#39;macrotask 执行完成会执行 microtask ，把 microtask quene 里面的 microtask 全部拿出来一次性执行完，所以会输出 &#39;async1 end&#39; 和 ‘promise2&#39;开始新一轮的事件循环，去除执行一个 macrotask 执行，所以会输出 ‘setTimeout&#39;</span><br></pre></td></tr></table></figure>

<h3 id="122哪些数组方法改变自身数组：splice-sort-pop-push"><a href="#122哪些数组方法改变自身数组：splice-sort-pop-push" class="headerlink" title="122哪些数组方法改变自身数组：splice sort pop push"></a>122哪些数组方法改变自身数组：splice sort pop push</h3><h3 id="哪些不改变：concat"><a href="#哪些不改变：concat" class="headerlink" title="哪些不改变：concat"></a>哪些不改变：concat</h3><h3 id="124对于实现双向数据绑定，Object-defineProperty-有什么缺点？有没有更好的方法来实现？"><a href="#124对于实现双向数据绑定，Object-defineProperty-有什么缺点？有没有更好的方法来实现？" class="headerlink" title="124对于实现双向数据绑定，Object.defineProperty()有什么缺点？有没有更好的方法来实现？"></a>124对于实现双向数据绑定，Object.defineProperty()有什么缺点？有没有更好的方法来实现？</h3><p>  Object.defineProperty()有以下2个非常明显的缺点：</p>
<p> （1）无法监听数组的变化。</p>
<p> （2）只能劫持对象的属性，无法劫持一个完整的对象。</p>
<p>  对于实现双向数据绑定，更好的方法是使用Proxy对象来实现，如何实现</p>
<p>两种方式都要手撕代码</p>
<h4 id="129定义一个矩形类Rectangle，它是由宽width和长height两个参数构造的，然后在类中定义一个getArea-方法，用来计算矩形的面积。"><a href="#129定义一个矩形类Rectangle，它是由宽width和长height两个参数构造的，然后在类中定义一个getArea-方法，用来计算矩形的面积。" class="headerlink" title="129定义一个矩形类Rectangle，它是由宽width和长height两个参数构造的，然后在类中定义一个getArea()方法，用来计算矩形的面积。"></a>129定义一个矩形类Rectangle，它是由宽width和长height两个参数构造的，然后在类中定义一个getArea()方法，用来计算矩形的面积。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class Rectangle &#123;    constructor(width, height) &#123;        this.width &#x3D; width;        this.height &#x3D; height;    &#125;    getArea() &#123;        return this.width * this.height;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="130vue的作用和核心功能"><a href="#130vue的作用和核心功能" class="headerlink" title="130vue的作用和核心功能"></a>130vue的作用和核心功能</h3><p>Vue是渐进式的JavaScript框架</p>
<p>优点：压缩后体积小，效率高（虚拟DOM）、双向绑定、成熟框架</p>
<p>功能：v-bind v-on v-if v-show v-text v-html 组件 双向绑定</p>
<h3 id="132URL-URI区别"><a href="#132URL-URI区别" class="headerlink" title="132URL URI区别"></a>132URL URI区别</h3><p>URI 是统一资源标识符,而 URL 是统一资源定位符。</p>
<p>每个 URL 都是 URI,但不一定每个 URI 都是 URL。这是因为 URI 还包括一个子类,即统一资源名称 (URN),它命名资源但不指定如何定位资源。</p>
<h3 id="133ajax过程，代码"><a href="#133ajax过程，代码" class="headerlink" title="133ajax过程，代码"></a>133ajax过程，代码</h3><h3 id="134-email正则表达式"><a href="#134-email正则表达式" class="headerlink" title="134 email正则表达式"></a>134 email正则表达式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(\.[a-zA-Z0-9_-]+)+$&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="137-UDP和TCP的区别"><a href="#137-UDP和TCP的区别" class="headerlink" title="137 UDP和TCP的区别"></a>137 UDP和TCP的区别</h3><p>TCP和UDP都是传输层的协议</p>
<p>UDP提供了<strong>不可靠的无连接</strong>传输服务；TCP提供了<strong>可靠的面向连接的</strong>字节流传输协议</p>
<h3 id="138给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标"><a href="#138给定一个整数数组-nums-和一个目标值-target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标" class="headerlink" title="138给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标"></a>138给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var towSum &#x3D; function(nums, target)&#123;  for(let i&#x3D;0, len &#x3D; nums.length; i&lt; len; i++) &#123;    if(nums.indexOf(target - nums[i]) &gt; -1 ) &#123;      return [i, nums.indexOf(target - nums[i])]    &#125;  &#125;&#125;&#x2F;&#x2F;var towSum &#x3D; function(nums, target)&#123;  let obj &#x3D; &#123;&#125;;  for(let i&#x3D;0, len&#x3D;nums.length; i&lt; len; i++)&#123;    let mult &#x3D; target - nums[i];    if(mult in obj)&#123;      return [obj[mult], i];    &#125;    obj[nums[i]] &#x3D; i;  &#125;&#125;&#x2F;&#x2F;var towSum &#x3D; function(nums, target)&#123;  for(let i&#x3D;0, len &#x3D; nums.length; i&lt;len; i++) &#123;    for(let j &#x3D; i+1; j &lt; nums.length; j++) &#123;      if(nums[i] + nums[j] &#x3D;&#x3D; target) &#123;        return [i, j]      &#125;    &#125;  &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="140-react中pureComponent的作用，处理异步操作用什么（react-thunk的作用，dispatch的升级）"><a href="#140-react中pureComponent的作用，处理异步操作用什么（react-thunk的作用，dispatch的升级）" class="headerlink" title="140 react中pureComponent的作用，处理异步操作用什么（react-thunk的作用，dispatch的升级）"></a>140 react中pureComponent的作用，处理异步操作用什么（react-thunk的作用，dispatch的升级）</h3><p>对于多个组件的connect和store进行连接，一旦store内部修改了，那么每个组件都会重新渲染，也就是每个组件的render都会重新执行，解决这个问题可以使用之前的shouldComponentUpdate，react内部有PureComponent解决这个问题，只要把之前的引入包括使用Component的地方都改为PureComponent<br>import React, { PureComponent } from ‘react’；<br>因为使用了immutable.js这个框架，PureComponent和immutable.js能完美结合，但是如果不使用immutable.js就使用PureComponent的话，那么会遇到一些底层问题的坑，所以如果不使用immutable.js，最好自己写一个shouldCompomentUpdate来进行代码优化，不要使用PureComponent</p>
<h3 id="141-vue中父beforeCreate-gt-父created-gt-父beforeMount-gt-子beforeCreate-gt-子created-gt-子beforeMount-gt-子mounted-gt-父mounted"><a href="#141-vue中父beforeCreate-gt-父created-gt-父beforeMount-gt-子beforeCreate-gt-子created-gt-子beforeMount-gt-子mounted-gt-父mounted" class="headerlink" title="141 vue中父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted"></a>141 vue中父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</h3><h3 id="142-max-age-0"><a href="#142-max-age-0" class="headerlink" title="142 max-age=0"></a>142 max-age=0</h3><p>no-cache</p>
<p>如果request headers中，Cache-Control为no-cache。表示不管服务端有没有设置Cache-Control，都必须从重新去获取请求。 浏览器缓存，但是认为是过期缓存</p>
<p>max-age=0</p>
<p>max-age=0表示不管response怎么设置，在重新获取资源之前，先检验ETag/Last-Modified</p>
<p> 不管是max-age=0还是no-cache，都会返回304（资源无修改的情况下），no-store才是真正的不进行缓存。</p>
<h3 id="144闭包的好处"><a href="#144闭包的好处" class="headerlink" title="144闭包的好处"></a>144闭包的好处</h3><p>1.减少全局变量</p>
<p>//达到每次调用函数add()，a都不断加1</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function add()&#123;	var a &#x3D; 0;	a++;	alert(a);&#125;add();add();&#x2F;&#x2F;这样做每次调用a都从0开始&#x2F;&#x2F;这样可以实现累加效果var a &#x3D; 0;function add() &#123;	a++;	alert(a);&#125;add();add();&#x2F;&#x2F;但这样做就增加全局变量&#x2F;&#x2F;改为闭包的方式function f()&#123;	var a &#x3D; 0;	return function()&#123;		a++;		alert(a);	&#125;&#125;var result &#x3D; f();result();result();</span><br></pre></td></tr></table></figure>

<p>2.减少传递给函数的参数数量</p>
<p>//实现例如基数为2，最大数为3，返回值为2+ 1+2+3的值</p>
<p>//可以这样实现</p>
<p>function add(base,max){…}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;用闭包function calFactory(base)&#123;	return function(max)&#123;		var total &#x3D; 0;		for(var i &#x3D; 1, i &lt;&#x3D; max, i++ )&#123;			total +&#x3D;i;		&#125;		return total + base;	&#125;&#125;var adder &#x3D; calFactory(2);adder(3);&#x2F;&#x2F;8&#x2F;&#x2F;2+1+2+3adder(4);&#x2F;&#x2F;12&#x2F;&#x2F;2+1+2+3+4</span><br></pre></td></tr></table></figure>

<p>3.起到封装的作用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123;	var m &#x3D; 0;	function getM()&#123;&#x2F;&#x2F;闭包		return m;	&#125; 	function setM()&#123;&#x2F;&#x2F;闭包		m &#x3D; val;	&#125;	window.g &#x3D; getM;&#x2F;&#x2F;通向外部的接口	window.s &#x3D; setM;&#125;)();&#x2F;&#x2F;立即调用的匿名函数s(12);alert(g());</span><br></pre></td></tr></table></figure>

<h4 id="闭包的注意事项："><a href="#闭包的注意事项：" class="headerlink" title="闭包的注意事项："></a>闭包的注意事项：</h4><p>1.对于捕获到的变量只是个饮用，不是复制</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;	var num &#x3D; 1;	function g()&#123;		alert(num);&#x2F;&#x2F;引用父的num	&#125;	num++;	g();&#x2F;&#x2F;2&#125;</span><br></pre></td></tr></table></figure>

<p>2.父函数每调用一次，会产生不同的闭包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;	var num &#x3D; 1;	return function()&#123;		num++;		alert(num);	&#125;&#125;var result1 &#x3D; f();&#x2F;&#x2F;由函数的预处理可知，每次调用一个函数的时候会创建一个新的词法环境result1();&#x2F;&#x2F;2result1();&#x2F;&#x2F;3var result2 &#x3D; f();&#x2F;&#x2F;创建一个新的词法环境result2();&#x2F;&#x2F;2result2();&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>

<p>3.循环中的问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;&lt;div id &#x3D; “1”&gt;1&lt;&#x2F;div&gt;&lt;div id &#x3D; “2”&gt;2&lt;&#x2F;div&gt;&lt;div id &#x3D; “3”&gt;3&lt;&#x2F;div&gt;for(var i &#x3D; 1;i &lt;&#x3D;3;i++)&#123;	var ele &#x3D; document.getElementById(”i”);	ele.onclick &#x3D; function()&#123;		alert(i);	&#125;&#125;&lt;&#x2F;body&gt;&#x2F;&#x2F;点击1 2 3 都会弹出4，因为没有块级作用域，所以i相当于全局变量&#x2F;&#x2F;解决办法，可以用闭包&lt;body&gt;&lt;div id &#x3D; “1”&gt;1&lt;&#x2F;div&gt;&lt;div id &#x3D; “2”&gt;2&lt;&#x2F;div&gt;&lt;div id &#x3D; “3”&gt;3&lt;&#x2F;div&gt;(for(var i &#x3D; 1;i &lt;&#x3D;3;i++)&#123;	var ele &#x3D; document.getElementById(”i”);	ele.onclick &#x3D; (function(id)&#123;		return function()&#123;		alert(id);	&#125;&#125;)(i);&#x2F;&#x2F;每次点击1或2或3都会立即执行函数，从而达到点击几弹出几的效果&#x2F;&#x2F;每被调用一次函数，父函数的i都会被捕获，都会重新产生一个闭包&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h3 id="145this"><a href="#145this" class="headerlink" title="145this"></a>145this</h3><p>this永远指向对象</p>
<p>this可以直接写在全局里面，并且此时永远指向window对象；this也可以写在函数里面，此时氛围三种情况：</p>
<p>第一种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var ele &#x3D; document.getElementById(”id”);ele.addElementListener(”click”,function&#123;	console.log(this);&#x2F;&#x2F;这种情况this永远指向引发事件的对象ele&#125;)</span><br></pre></td></tr></table></figure>

<p>第二种情况：</p>
<p>//this的指向是运行时决定，不是编写代码时决定</p>
<p>//运行时函数是谁调用的，this就指向谁</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;	name:”nice”;	print:function()&#123;		console.log(this.name);	&#125;&#125;o.print();&#x2F;&#x2F;nice&#x2F;&#x2F;函数是o调用的var ff &#x3D; o.print;ff();&#x2F;&#x2F;undefined&#x2F;&#x2F;此时相当于window.ff()，函数是window调用的</span><br></pre></td></tr></table></figure>

<p>第三种情况：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;	this.name &#x3D; “nice”;&#125;</span><br></pre></td></tr></table></figure>

<p>上面第二种情况改变了this的指向，还可以使用call或apply或bind改变this指向,call和apply和bind都是函数对象都会有的东西</p>
<h4 id="call和apply的区别："><a href="#call和apply的区别：" class="headerlink" title="call和apply的区别："></a>call和apply的区别：</h4><p>传参的时候call使用参数列表的形式，一个一个地传，而apply使用参数数组的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;	name:”nice”;	print:function()&#123;		console.log(this.name);	&#125;&#125;var ff &#x3D; o.print;ff();&#x2F;&#x2F;undefinedthis.name &#x3D; “global”;this.age &#x3D; 22;ff();&#x2F;&#x2F;globalfunction log(a,b)&#123;	console.log(this[a]);	console.log(this[b]);&#125;log(”name”,”age”);&#x2F;&#x2F;global 22log.call(o,”name”);&#x2F;&#x2F;nice&#x2F;&#x2F;改变了this的指向，相当于o.log(“name”)log.call(o,”name”,”age”);&#x2F;&#x2F;nice undefined&#x2F;&#x2F;undefined因为在o对象中没有age变量log.apply(o,[’’name”,”age”])&#x2F;&#x2F;nice undefined</span><br></pre></td></tr></table></figure>

<h3 id="146算法题：去除字符串中的连续重复字母"><a href="#146算法题：去除字符串中的连续重复字母" class="headerlink" title="146算法题：去除字符串中的连续重复字母"></a>146算法题：去除字符串中的连续重复字母</h3><p>用迭代</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; &quot;1122333455&quot;;var cc &#x3D; s.match(&#x2F;(\d)\1+&#x2F;g);    &#x2F;&#x2F;11,22,333,55 s1 &#x3D; s.replace(cc[i], &quot;&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="147js-不增加变量，怎么实现两个变量值的互换"><a href="#147js-不增加变量，怎么实现两个变量值的互换" class="headerlink" title="147js 不增加变量，怎么实现两个变量值的互换"></a>147js 不增加变量，怎么实现两个变量值的互换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ES6的解构let a &#x3D; 1,b &#x3D; 2;[a, b] &#x3D; [b, a];var a &#x3D; 1,b &#x3D; 2;a &#x3D; [a, b];b &#x3D; a[0];a &#x3D; a[1];</span><br></pre></td></tr></table></figure>

<h3 id="148js中的基本类型与包装类型"><a href="#148js中的基本类型与包装类型" class="headerlink" title="148js中的基本类型与包装类型"></a>148js中的基本类型与包装类型</h3><p>ECMAScript 提供了 3 个特殊的引用类型：Boolean、Number和 String。这些类型与其他引用类型相似，但同时也具有与各自的基本类型相应的特殊行为。</p>
<p>实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而能够调用一些方法来操作这些数据。</p>
<p>包装对象：<br>包装对象，就是当基本类型以对象的方式去使用时，JavaScript会转换成对应的包装类型，相当于new一个对象，内容和基本类型的内容一样，然后当操作完成再去访问的时候，这个临时对象会被销毁，然后再访问时候就是undefined。number,string,boolean都有对应的包装类型。 number,string,boolean都有对应的包装类型</p>
<p> 因为有了基本包装类型,所以JS中的基本类型值可以被当作对象来访问;<br> 基本类型特征:<br> 1.每个包装类型都映射到同名的基本类型;<br> 2.在读取模式下访问基本类型值时,就会创建对应的基本包装类型的一个对象,从而方便了数据操作;<br> 3.操作基本类型值的语句一经执行完毕,就会立即销毁新创建的包装对象;<br>引用类型和基本包装类型的主要区别就是对象的生存期;<br>自动创建的基本包装类型的对象,则只存在于一行代码的执行瞬间,然后立即被销毁;<br>这意味着我们不能在运行时为基本类型值添加属性和方法;</p>
<h3 id="149-document-write-eval-“2-2”-4"><a href="#149-document-write-eval-“2-2”-4" class="headerlink" title="149 document.write(eval(“2+2”))//4"></a>149 document.write(eval(“2+2”))//4</h3><h3 id="150-域名分发"><a href="#150-域名分发" class="headerlink" title="150 域名分发"></a>150 域名分发</h3><h3 id="151自适应布局的方法"><a href="#151自适应布局的方法" class="headerlink" title="151自适应布局的方法"></a>151自适应布局的方法</h3><p>@media</p>
<p>meta viewport</p>
<p>html标签中设置font-size: …px，然后下面的尺寸都用rem进行设计  62.5%</p>
<p>vm vh</p>
<h3 id="152数组乱序"><a href="#152数组乱序" class="headerlink" title="152数组乱序"></a>152数组乱序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function reArr (arr) &#123;    return arr.sort(() &#x3D;&gt; &#123;    	return Math.random() - 0.5;    &#125;)&#125;&#x2F;&#x2F; console.log(reArr([2, 3, 1, 5]));function isReArr (n, reArr, arr) &#123;    var arr1 &#x3D; [0, 0, 0, 0];    var length &#x3D; arr.length;    for (var i &#x3D; 0; i &lt; n; i++) &#123;        var arr2 &#x3D; reArr(arr);        for (var j &#x3D; 0; j &lt; length; j++) &#123;        	arr1[j] +&#x3D; arr2[j];        &#125;    &#125;    arr1.forEach((item) &#x3D;&gt; &#123;    return item &#x2F; n;    &#125;)&#125;isReArr(500, reArr, [2, 3, 1, 5]);数组乱序function reArr (arr) &#123;    return arr.sort(() &#x3D;&gt; &#123;    	return Math.random() - 0.5;    &#125;)&#125;var list &#x3D; [1,2,3,4,5,6,7,8,9,10];var newlist &#x3D; [];for(var i&#x3D;0;i&lt;10;i++)&#123;    var num &#x3D;  Math.floor(Math.random()*list.length) ;    newlist.push(list[num]);    list.splice(num,1)&#125;&#x2F;&#x2F;  forEach遍历，随机生成下标，交换位置function disorderArr(arr) &#123;       arr.forEach((e, i, a) &#x3D;&gt; &#123;         let randomIndex &#x3D; Math.floor(Math.random()*list.length)          let temp &#x3D; a[randomIndex]         a[randomIndex] &#x3D; a[i]         a[i] &#x3D; temp     &#125;)     return arr &#125;&#x2F;&#x2F; 洗牌原理：从数组的最后位置开始，从前面随机一个位置，对两个数进行交换，直到循环完毕 function shuffleSort(arr) &#123;     let i &#x3D; arr.length - 1     while(i&gt;0) &#123;         let rIndex &#x3D; Math.floor(Math.random()*i)         let temp &#x3D; arr[rIndex]         arr[rIndex] &#x3D; arr[i]         arr[i] &#x3D; temp         i--     &#125;     return arr &#125;</span><br></pre></td></tr></table></figure>

<h3 id="153输出结果"><a href="#153输出结果" class="headerlink" title="153输出结果"></a>153输出结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foo ();function foo () &#123;	console.log(&quot;foo1&quot;);&#125;foo ();function foo () &#123;	console.log(&quot;foo2&quot;);&#125;foo ();&#x2F;&#x2F;foo2 foo2 foo2</span><br></pre></td></tr></table></figure>

<h3 id="154"><a href="#154" class="headerlink" title="154"></a>154</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var abc &#x3D; function foo () &#123;&#125;console.log(typeof(foo));&#x2F;&#x2F;undefinedconsole.log(typeof(foo()));&#x2F;&#x2F;报错console.log(typeof(abc));&#x2F;&#x2F;functionconsole.log(typeof(abc()));&#x2F;&#x2F;undefined，因为函数没有返回值</span><br></pre></td></tr></table></figure>

<h3 id="155-http中put和patch的区别"><a href="#155-http中put和patch的区别" class="headerlink" title="155 http中put和patch的区别"></a>155 http中put和patch的区别</h3><p>PATCH方法是新引入的，是对PUT方法的补充，用来对已知资源进行<strong>局部更新</strong></p>
<h3 id="156"><a href="#156" class="headerlink" title="156"></a>156</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const d &#x3D; new Date();const year &#x3D; d.getFullYear();let month &#x3D; (d.getMonth() + 1).toString().padStart(2, &quot;0&quot;);let day &#x3D; d.getDate().toString().padStart(2, &quot;0&quot;);const time &#x3D; &#96;$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;&#96;;console.log(time);const d &#x3D; new Date();const year &#x3D; d.getFullYear();let month &#x3D; d.getMonth() + 1;let day &#x3D; d.getDate();if (month.toString().length &lt; 2) &#123;    month &#x3D; &quot;0&quot; + month;&#125;if (day.toString().length &lt; 2) &#123;    day &#x3D; &quot;0&quot; + day;&#125;const time &#x3D; year + &quot;-&quot; + month + &quot;-&quot; + day;console.log(time);</span><br></pre></td></tr></table></figure>

<h3 id="157typeof-typeof-123-返回的是string类型"><a href="#157typeof-typeof-123-返回的是string类型" class="headerlink" title="157typeof typeof 123 返回的是string类型"></a>157typeof typeof 123 返回的是string类型</h3><p>var temp=typeof 123;//==&gt;temp=’number’<br>typeof typeof 123;//==&gt;typeof ‘number’==&gt;’string’</p>
<h3 id="158getElementById-返回的是什么？"><a href="#158getElementById-返回的是什么？" class="headerlink" title="158getElementById()返回的是什么？"></a>158getElementById()返回的是什么？</h3><p> “object HTMLDivElement”，即 HTMLDivElement 对象</p>
<h3 id="159-ts-js-TypeScript和JavaScript的对比："><a href="#159-ts-js-TypeScript和JavaScript的对比：" class="headerlink" title="159 ts js TypeScript和JavaScript的对比："></a>159 ts js TypeScript和JavaScript的对比：</h3><p>typescript ts是微软牵头主导的，主要来自C#<br>ts需要静态编译，它提供了强类型与更多面向对象的内容。<br>ts最终仍要编译为弱类型的js文件，基于对象的原生的js，再运行。故ts相较java/C#这样天生面向对象语言是有区别和局限的</p>
<p>TypeScript是一个应用程序级的JavaScript开发语言。（这也表示TypeScript比较牛逼，可以开发大型应用，或者说更适合开发大型应用）<br>TypeScript是JavaScript的超集，可以编译成纯JavaScript。这个和我们CSS离的Less或者Sass是很像的<br>TypeScript跨浏览器、跨操作系统、跨主机、且开源。由于最后他编译成了JavaScript所以只要能运行<br>TypeScript始于JavaScript，终于JavaScript。遵循JavaScript的语法和语义<br>TypeScript提供了类、模块和接口，更易于构建组件和维护。typescript与javascript关系<br>typescript是javascript的超集，即你可以在ts中使用原生js语法，扩展了javascript的语法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typescript必须声明变量类型如：var message &#x3D; “article”; &#x2F;&#x2F;javascriptvar message:string &#x3D; “article”; &#x2F;&#x2F;typescript函数声明不同&#x2F;&#x2F;javascriptfunction test()&#123;return ‘article’&#125;&#x2F;&#x2F;typescript:需声明返回值类型function test():string&#123;return ‘article’&#125;基本数据类型不同：javascript：boolean类型、number类型、string类型、array类型、undefined、nulltypescript：除了上面类型外，还包含tuple类型（元组类型）、enum类型（枚举类型）、any类型（任意类型）ts增加的语法静态类型:有利于检查代码错误，运行前检查类型错误函数缺省参数值：类:模块:可以把声明、数据、函数和类封装在模块中接口:类型注解:通过类型注解来增加编译时静态类型检查</span><br></pre></td></tr></table></figure>

<h3 id="160将两个有序的数组合并成一个有序数组"><a href="#160将两个有序的数组合并成一个有序数组" class="headerlink" title="160将两个有序的数组合并成一个有序数组"></a>160将两个有序的数组合并成一个有序数组</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function arrSort(arr1, arr2) &#123;    var [i,j] &#x3D; [0,0];    let newArr &#x3D; [];    while(i &lt; arr1.length || j &lt;arr2.length) &#123;        if (arr1[i] &lt; arr2[j]) &#123;            newArr.push(arr1[i]);            i++        &#125; else if (arr1[i] &gt; arr2[j]) &#123;            newArr.push(arr2[j])            j++        &#125; else &#123;        	&#x2F;&#x2F;i或者j到头了，进行判断一下            if(arr1[i] !&#x3D;&#x3D; undefined) newArr.push(arr1[i]);            if(arr2[j] !&#x3D;&#x3D; undefined) newArr.push(arr2[j]);            i++;            j++        &#125;    &#125;    return newArr&#125;</span><br></pre></td></tr></table></figure>

<h3 id="23请简述数组的基础操作读写与新增的性能对比"><a href="#23请简述数组的基础操作读写与新增的性能对比" class="headerlink" title="23请简述数组的基础操作读写与新增的性能对比"></a>23请简述数组的基础操作读写与新增的性能对比</h3><p>数组性能我首先想到的就是从两方面,一是数组的迭代二是向数组中添加元素.</p>
<p>迭代的话是最普通的for循环效率最高,而且普通的for循环还可以继续优化；向数据中添加元素是用索引的方式添加元素最快,而且不同的浏览器各种方法效率有差异.但是利用索引添加元素最快无疑.</p>
<p>map和forEach对比:</p>
<p>1、map速度比foreach快</p>
<p>2、map会返回一个新数组，不对原数组产生影响,foreach不会产生新数组，foreach返回undefined</p>
<p>3、map因为返回数组所以可以链式操作，foreach不能</p>
<p>4, map它会返回⼀个新的数组，所以需要有 return 值，如果没有，会返回 undefined ;而foreach里用return不起作用，foreach不能用break，会直接报错。</p>
<ol>
<li>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</li>
<li>map() 方法按照原始数组元素顺序依次处理元素。</li>
<li><strong>注意：</strong> map() 不会对空数组进行检测。</li>
<li><strong>注意：</strong> map() 不会改变原始数组。</li>
</ol>
<h3 id="161正则表达式需要转义的字符"><a href="#161正则表达式需要转义的字符" class="headerlink" title="161正则表达式需要转义的字符"></a>161正则表达式需要转义的字符</h3><p> .    |  $ ?  *  +  ^  \ 转义需要用这个 ( )  [ ] { }</p>
<h3 id="162-Tab选项卡的实现、flex知识、懒加载、吸顶功能"><a href="#162-Tab选项卡的实现、flex知识、懒加载、吸顶功能" class="headerlink" title="162 Tab选项卡的实现、flex知识、懒加载、吸顶功能"></a>162 Tab选项卡的实现、flex知识、懒加载、吸顶功能</h3><h5 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h5><p>一张图片就是一个&lt;img&gt;标签，浏览器是否发起请求图片是根据&lt;img&gt;\的src属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给&lt;img&gt;的src赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给src赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">元素到浏览器顶部的距离 e.offsetTopwindow.innerHeight;&#x2F;&#x2F;获取可视高度(屏幕高度)var scrollHeight &#x3D; document.documentElement.scrollTop || document.body.scrollTop;&#x2F;&#x2F;获取滚动的值if ((viewHeight + scrollHeight) &gt; 元素到浏览器顶部的距离) &#123;	设置一个定时器，制造懒加载的延迟加载的效果&#125;</span><br></pre></td></tr></table></figure>

<p>提高首屏的加载速度，提高用户体验，减小带宽<br>npm i vue-lazyload -s<br>import VueLazyload from ‘vue-lazyload’；<br>Vue.use(VueLazyload)或者<br>Vue.use(VueLazyload, {<br>  error: ‘dist/error.png’,图片不存在时展示的错误图片<br>  load: ‘dist/loading.gif或者.svg也行’,图片没加载出来时显示的样式<br>})还有其他options<br>&lt; img v-load=”图片路径”/&gt;</p>
<h5 id="吸顶功能"><a href="#吸顶功能" class="headerlink" title="吸顶功能"></a>吸顶功能</h5><p>谷歌获取滚动的高度<br>document.documentElement.scrollTop<br>Y轴偏移量window.pageYOffset和上面是一样的<br>IE浏览器document.body.scrollTop<br>这三个总归有一个是能取到的</p>
<h3 id="163Object-assign实现"><a href="#163Object-assign实现" class="headerlink" title="163Object.assign实现"></a>163Object.assign实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.myAssign &#x3D; function (target, ...src) &#123;  for (let i &#x3D; 0; i &lt; src.length; i++) &#123;    if (src[i] !&#x3D;&#x3D; null || src[i] !&#x3D;&#x3D; undefined) &#123;      &#x2F;&#x2F; 过滤掉源对象为null和undefined的情况      for (let key in src[i]) &#123;        &#x2F;&#x2F; in运算符会查找原型对象上的可枚举属性，所以需要通过Object.prototype.hasOwnProperty方法过滤掉对象原型对象上的属性        if (src[i].hasOwnProperty(key)) &#123;          target[key] &#x3D; src[i][key];        &#125;      &#125;     &#125;  &#125;  return target&#125;</span><br></pre></td></tr></table></figure>

<h3 id="164"><a href="#164" class="headerlink" title="164"></a>164</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const p &#x3D; Promise.resolve(1);p.then(console.log)p.then(console.log)&#x2F;&#x2F;输出结果  1  1</span><br></pre></td></tr></table></figure>

<h3 id="165"><a href="#165" class="headerlink" title="165"></a>165</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; new Array(1, 1, 1);&#x2F;&#x2F;[1 1 1]var a &#x3D; new Array(5);&#x2F;&#x2F;长度为5的空数组var a &#x3D; [1, 1, 1]&#x2F;&#x2F;报错</span><br></pre></td></tr></table></figure>

<h3 id="166冒泡排序具体的次数"><a href="#166冒泡排序具体的次数" class="headerlink" title="166冒泡排序具体的次数"></a>166冒泡排序具体的次数</h3><p>总的比较次数=(n-1)+(n-2)+.+1=n(n-1)/2</p>
<h3 id="167原生indexOf的实现"><a href="#167原生indexOf的实现" class="headerlink" title="167原生indexOf的实现"></a>167原生indexOf的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function MyIndexOf(str2,str1,n)&#123;&#x2F;&#x2F;n为起始位置    let i;&#x2F;&#x2F;循环变量    let len1&#x3D;str1.length;&#x2F;&#x2F;子串长度    let len2&#x3D;str2.length;&#x2F;&#x2F;父串长度    if(n&#x3D;&#x3D;undefined ||n&#x3D;&#x3D;null||n&lt;&#x3D;-1) &#123;&#x2F;&#x2F;没有传入起始位置时，从第一位开始        i&#x3D;0;    &#125;else if(n&gt;len2-1)&#123;&#x2F;&#x2F;如果起始位置大于字符串最后一位，返回-1，不存在        return -1;     &#125;else&#123;&#x2F;&#x2F;如果不存在上述2种情况，从第n位开始        i&#x3D;n;    &#125;    if(len1&gt;len2)&#123;&#x2F;&#x2F;如果子串长大于父串，那么肯定不存在，返回-1        return -1;    &#125;else if(len1&#x3D;&#x3D;len2)&#123;&#x2F;&#x2F;如果相等，就对比2个字符串的内容        if(str1&#x3D;&#x3D;str2)&#123;&#x2F;&#x2F;如果内容相等，那么就是从第一位开始，返回0            return 0;        &#125;else&#123;&#x2F;&#x2F;长度相等，内容不相等，那么肯定不存在啦            return -1;        &#125;    &#125;else&#123;        let str21&#x3D;&#39;&#39;;        while(i&lt;len2 - len1)&#123;         &#x2F;&#x2F;拼合对比的父串，i到len1         str21&#x3D;str2.substr(i,len1);&#x2F;&#x2F;每次都拿出和子串长度一样的字符串去对比         if(str21&#x3D;&#x3D;str1)&#123;            return i;&#x2F;&#x2F;这里返回的就是第一次子串出现的位置，符合indexOf         &#125;         if(i&#x3D;&#x3D;len2 - len1)&#123;&#x2F;&#x2F;如果循环到父串最后一位还是没有出现相等，那么就是-1不存在            return -1;         &#125;         i++;        &#125;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="168"><a href="#168" class="headerlink" title="168"></a>168</h3><p>阻止默认事件： </p>
<p>e.preventDefault() </p>
<p>e.returnValue = false (IE) </p>
<p>阻止冒泡： </p>
<p>e.stopPropagation() </p>
<p>e.cancelBubble = true (IE)</p>
<h3 id="169"><a href="#169" class="headerlink" title="169"></a>169</h3><p>substr(start,length)是从起始索引号开始提取指定长度的字符串；</p>
<p>substring(start,stop)是提取字符串中两个指定索引号之间的字符；（跟Java中一样），数学上相当于提取 [start,stop) 之间的字符。</p>
<h3 id="170"><a href="#170" class="headerlink" title="170"></a>170</h3><p>执行上下文有且只有三类，全局执行上下文，函数上下文，与eval上下文</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/echolun/p/11438363.html">https://www.cnblogs.com/echolun/p/11438363.html</a></p>
<h3 id="171请用原生-js-实现一个函数-给页面制定的任意一个元素添加一个透明遮罩-透明度可变-默认-0-2-使这个区域点击无效-要求兼容-IE8-及各主流浏览器"><a href="#171请用原生-js-实现一个函数-给页面制定的任意一个元素添加一个透明遮罩-透明度可变-默认-0-2-使这个区域点击无效-要求兼容-IE8-及各主流浏览器" class="headerlink" title="171请用原生 js 实现一个函数,给页面制定的任意一个元素添加一个透明遮罩(透明度可变,默认 0.2),使这个区域点击无效,要求兼容 IE8+及各主流浏览器"></a>171请用原生 js 实现一个函数,给页面制定的任意一个元素添加一个透明遮罩(透明度可变,默认 0.2),使这个区域点击无效,要求兼容 IE8+及各主流浏览器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;style&gt;#target &#123;    width: 200px;    height: 300px;    margin: 40px;    background-color: tomato;&#125;&lt;&#x2F;style&gt; &lt;div id&#x3D;&quot;target&quot;&gt;&lt;&#x2F;div&gt; &lt;script&gt;function addMask(elem, opacity) &#123;    opacity &#x3D; opacity || 0.2;     var rect &#x3D; elem.getBoundingClientRect();    var style &#x3D; getComputedStyle(elem, null);     var mask &#x3D; document.createElement(&#39;div&#39;);    mask.style.position &#x3D; &#39;absolute&#39;;    var marginLeft &#x3D; parseFloat(style.marginLeft);    mask.style.left &#x3D; (elem.offsetLeft - marginLeft) + &#39;px&#39;;    var marginTop &#x3D; parseFloat(style.marginTop);    mask.style.top &#x3D; (elem.offsetTop - marginTop) + &#39;px&#39;;    mask.style.zIndex &#x3D; 9999;    mask.style.opacity &#x3D; &#39;&#39; + opacity;    mask.style.backgroundColor &#x3D; &#39;#000&#39;;     mask.style.width &#x3D; (parseFloat(style.marginLeft) +        parseFloat(style.marginRight) + rect.width) + &#39;px&#39;;    mask.style.height &#x3D; (parseFloat(style.marginTop) +        parseFloat(style.marginBottom) + rect.height) + &#39;px&#39;;     elem.parentNode.appendChild(mask);&#125; var target &#x3D; document.getElementById(&#39;target&#39;);addMask(target); target.addEventListener(&#39;click&#39;, function () &#123;    console.log(&#39;click&#39;);&#125;, false);&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CareChere/article/details/51312215">https://blog.csdn.net/CareChere/article/details/51312215</a></p>
<p>offsetLeft  offsetWidth</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/willard_cui/article/details/81712989">https://blog.csdn.net/willard_cui/article/details/81712989</a></p>
<h3 id="172"><a href="#172" class="headerlink" title="172"></a>172</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Promise.reject(2).catch(r &#x3D; &gt; &#123;	console.log(&#39;catch1&#39;);&#x2F;&#x2F;捕获到错误，执行&#125;).then(v &#x3D;&gt; &#123;&#x2F;&#x2F;错误已经被捕获，后面的&#39;then&#39;都顺序执行，且	console.log(&#39;then1&#39;);&#125;, r &#x3D;&gt; &#123;	console.log(&#39;catch2&#39;);&#125;).catch(r &#x3D;&gt; &#123;	console.log(&#39;catch3&#39;);&#x2F;&#x2F;前面没有未捕获的错误，未执行&#125;).then(v &#x3D;&gt; &#123;	console.log(&#39;then2&#39;);&#125;, r &#x3D;&gt; &#123;	console.log(&#39;catch4&#39;);&#125;)&#x2F;&#x2F;catch1  then1  then2</span><br></pre></td></tr></table></figure>

<h3 id="173斐波那契数列的其他实现形式"><a href="#173斐波那契数列的其他实现形式" class="headerlink" title="173斐波那契数列的其他实现形式"></a>173斐波那契数列的其他实现形式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用循环迭代方式实现function fb2(n)&#123;    var res1 &#x3D; 1;    var res2 &#x3D; 1;    var sum;      var sum &#x3D; res2;    for(var i &#x3D; 2;i &lt; n;i ++)&#123;        sum &#x3D; res1 + res2;        res1 &#x3D; res2;        res2 &#x3D; sum;    &#125;    return sum;&#125;    &#x2F;&#x2F;还可以用数组存数据的方式</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shine1234/p/13356457.html">https://www.cnblogs.com/shine1234/p/13356457.html</a></p>
<h3 id="174求两个数的最大公约数"><a href="#174求两个数的最大公约数" class="headerlink" title="174求两个数的最大公约数"></a>174求两个数的最大公约数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function countDivior(a,b) &#123;      if(b&#x3D;&#x3D;&#x3D;0) &#123;           return a;     &#125; else &#123;          countDivior(b,a%b);     &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="175vue中的异步操作"><a href="#175vue中的异步操作" class="headerlink" title="175vue中的异步操作"></a>175vue中的异步操作</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">async mounted () &#123;	const data &#x3D; await this.$axios.get(&quot;xxx&quot;);	this.list &#x3D; data;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="72add-1-2-3-4-10"><a href="#72add-1-2-3-4-10" class="headerlink" title="72add(1)(2)(3)(4) == 10"></a>72<strong>add(1)(2)(3)(4) == 10</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function add (a) &#123;	return function (b) &#123;		return function (c) &#123;			return function (d) &#123;				return a + b + c + d			&#125;		&#125;	&#125;&#125;-----------柯里化function add (...args) &#123;	return args.reduce((a, b) &#x3D;&gt; a + b)&#x2F;&#x2F;reduce里面可以放一个累加器（累加函数）进行累加效果&#125;function currying (fn) &#123;	let args &#x3D; []	return function _c (...newArgs) &#123;		if (newArgs.length) &#123;			&#x2F;&#x2F; 合并参数			args &#x3D; [...args, ...newArgs];			return _c		&#125; else &#123;			return fn.apply(this, args)		&#125;	&#125;&#125;&#x2F;&#x2F;回调函数是一个函数作为另一个函数的参数，在另一个函数内部执行let addCurry &#x3D; currying(add)&#x2F;&#x2F; 注意调用方式的变化console.log(addCurry(1)(2)(3)(4, 5)())</span><br></pre></td></tr></table></figure>

<h3 id="3-“1”-”2”-”3”-map-parseInt-结果"><a href="#3-“1”-”2”-”3”-map-parseInt-结果" class="headerlink" title="3 [“1”,”2”,”3”].map(parseInt)结果"></a>3 [“1”,”2”,”3”].map(parseInt)结果</h3><p>字符串1，2，3作为元素；0，1，2作为下标分别调用 parseInt 函数。即分别求出 parseInt(‘1’,0), parseInt(‘2’,1), parseInt(‘3’,2)的结果。第二个参数 区间范围介于2~36之间； 当参数为 0，parseInt() 会根据十进制来解析； 如果忽略该参数，默认的基数规则：如果 string 以 “0x” 开头，parseInt() 会把 string 的其余部分解析为十六进制的整数；parseInt(“0xf”)  //15 …</p>
<p>[‘1’,’2’,’3’].map(parseInt)即</p>
<p>parseInt(‘1’,0);radix 为 0，parseInt() 会根据十进制来解析，所以结果为 1；</p>
<p>parseInt(‘2’,1);radix 为 1，超出区间范围，所以结果为 NaN；</p>
<p>parseInt(‘3’,2);radix 为 2，用2进制来解析，应以 0 和 1 开头，所以结果为 NaN。</p>
<h3 id="19在前端使用js直接计算0-1-0-2的值时，得到的结果为0-30000000000000004，为什么，如何写代码才能避免该情况（请写出代码）？"><a href="#19在前端使用js直接计算0-1-0-2的值时，得到的结果为0-30000000000000004，为什么，如何写代码才能避免该情况（请写出代码）？" class="headerlink" title="19在前端使用js直接计算0.1+0.2的值时，得到的结果为0.30000000000000004，为什么，如何写代码才能避免该情况（请写出代码）？"></a>19在前端使用js直接计算0.1+0.2的值时，得到的结果为0.30000000000000004，为什么，如何写代码才能避免该情况（请写出代码）？</h3><p>由于二进制浮点数中0.1和0.2并不是十分精确</p>
<p>最简单的就是先把0.1和0.2换成别的数字（因为在js中只有这两个数相加有bug，例如：1.1+1.2不会有问题），所以先让0.1和0.2分别乘以10，求和之后再除以10 ，则不会有问题：(0.1*10+0.2*10)/10 ===0.3</p>
<p>或者parseFloat((0.1+0.2).toFixed(10)) ===0.3</p>
<h5 id="求两个数对的和（整数或浮点数）"><a href="#求两个数对的和（整数或浮点数）" class="headerlink" title="求两个数对的和（整数或浮点数）"></a>求两个数对的和（整数或浮点数）</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseFloat((0.1+0.2).toFixed(10)) toFixed(10)规定了小数的位数，0到20之间</span><br></pre></td></tr></table></figure>

<h3 id="176-字符串前后空位的删除，tirm方法的实现"><a href="#176-字符串前后空位的删除，tirm方法的实现" class="headerlink" title="176 字符串前后空位的删除，tirm方法的实现"></a>176 字符串前后空位的删除，tirm方法的实现</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str.trim()  str.trimStart()   str.trimEnd()String.prototype.trim &#x3D; function()&#123;    return this.replace(&#x2F;^(\s*)|(\s*)$&#x2F;g, &#39;&#39;);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="109-每隔一段时间执行一次函数，执行次数一定"><a href="#109-每隔一段时间执行一次函数，执行次数一定" class="headerlink" title="109 每隔一段时间执行一次函数，执行次数一定"></a><strong>109</strong> <strong>每隔一段时间执行一次函数，执行次数一定</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function repeat (func, times, wait) &#123;       return function (content)&#123;          var count &#x3D; 0;          var interval &#x3D; setInterval(function()&#123;            count +&#x3D; 1;            func(content);            if(count &#x3D;&#x3D;&#x3D; times)&#123;                clearInterval(interval);              &#125;          &#125;, wait);      &#125;&#125; const repeatFunc &#x3D; repeat(alert, 4, 3000)repeatFunc(&quot;hellworld&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="177css3不需要回流和重绘的属性："><a href="#177css3不需要回流和重绘的属性：" class="headerlink" title="177css3不需要回流和重绘的属性："></a>177css3不需要回流和重绘的属性：</h3><ul>
<li>transform</li>
<li>opacity</li>
<li>filter</li>
<li>Will-change</li>
</ul>
<p>will-change属性可以提前通知浏览器我们要对元素做什么动画，这样浏览器可以提前准备合适的优化设置。这样可以避免对页面响应速度有重要影响的昂贵成本。元素可以更快的被改变，渲染的也更快，这样页面可以快速更新，表现的更加流畅。</p>
<p>will-change: transform, opacity;</p>
<h3 id="179"><a href="#179" class="headerlink" title="179"></a>179</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">实现函数 keys(o, level)，能够获取指定层次的键。示例：let o &#x3D; &#123;  x: &#123; a: 1, b: 2 &#125;,  y: 3,  z: &#123;c: 1, d: 2, p: &#123;m: 3&#125;&#125;&#125;keys(o, 1) &#x2F;&#x2F; 返回 [&#39;x&#39;, ‘y’, ‘z&#39;]keys(o, 2) &#x2F;&#x2F; 返回 [&#39;a&#39;, ‘b’, ‘c’, ‘d’ ‘p&#39;]keys(o, 3) &#x2F;&#x2F; 返回 [‘m’]keys(o, 4) &#x2F;&#x2F; 返回 []</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function keys (o, level) &#123;	if (level &lt;&#x3D; 1) &#123;		return Object.keys(object);	&#125;	const accumulatedKeys &#x3D; [];	for (let value of Object.values(object)) &#123;		if (typeof value &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;			accumulatedKeys.push(...keys(value, level - 1));		&#125;	&#125;	return accumulatedKeys;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="180"><a href="#180" class="headerlink" title="180"></a>180</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const obj &#x3D; &#123;a: 2&#125;;const a &#x3D; 1;console.log(obj &gt; a);</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">大于运算符的操作数可以是任意类型，单只有数字和字符串才能真正执行比较操作，其他类型都需要转换如果操作数是对象，先使用valueOf()转换为原始值，如果结果不是原始值，再使用toString()转换在对象转换为原始值之后，如果至少有一个操作数不是字符串，则两个操作数都转换为数字进行比较原始值指基础类型值(&#123;a: 2&#125;) &gt; 1就相当于 NaN &gt; 1，应该是 false</span><br></pre></td></tr></table></figure>

<h3 id="181reverse-是颠倒数组的方法"><a href="#181reverse-是颠倒数组的方法" class="headerlink" title="181reverse()是颠倒数组的方法"></a>181reverse()是颠倒数组的方法</h3><h3 id="方法重载表示传入的参数不同"><a href="#方法重载表示传入的参数不同" class="headerlink" title="方法重载表示传入的参数不同"></a>方法重载表示传入的参数不同</h3><h3 id="182金额转换为千分位"><a href="#182金额转换为千分位" class="headerlink" title="182金额转换为千分位"></a>182金额转换为千分位</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function formatNum(str) &#123;    var newStr &#x3D; &quot;&quot;;    var count &#x3D; 0;    if(str.indexOf(&quot;.&quot;) &#x3D;&#x3D;&#x3D; -1)&#123;        for(var i&#x3D;str.length-1;i&gt;&#x3D;0;i--)&#123;            if(count % 3 &#x3D;&#x3D; 0 &amp;&amp; count !&#x3D; 0)&#123;            	newStr &#x3D; str.charAt(i) + &quot;,&quot; + newStr;        	&#125;else&#123;        		newStr &#x3D; str.charAt(i) + newStr;    	&#125;    	count++;        str &#x3D; newStr + &quot;.00&quot;; &#x2F;&#x2F;自动补小数点后两位        console.log(str)    &#125; else &#123;    for(var i &#x3D; str.indexOf(&quot;.&quot;)-1;i&gt;&#x3D;0;i--)&#123;        if(count % 3 &#x3D;&#x3D; 0 &amp;&amp; count !&#x3D; 0)&#123;        	newStr &#x3D; str.charAt(i) + &quot;,&quot; + newStr; &#x2F;&#x2F;碰到3的倍数则加上“,”号        &#125;else&#123;        	newStr &#x3D; str.charAt(i) + newStr; &#x2F;&#x2F;逐个字符相接起来        &#125;        count++;    &#125;        str &#x3D; newStr + str.substring(str.indexOf(&quot;.&quot;));        console.log(str.toFixed(2));&#x2F;&#x2F;保留两位小数    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="183二维路径规划问题"><a href="#183二维路径规划问题" class="headerlink" title="183二维路径规划问题"></a>183二维路径规划问题</h3><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。说明：每次只能向下或者向右移动一步。</p>
<p>输入：grid = [[1,3,1],[1,5,1],[4,2,1]]<br>输出：7<br>解释：因为路径 1→3→1→1→1 的总和最小。</p>
<p>解题思路<br>当前数的最小和 = 当前数 + min(左边数最小和，上边数最小和)<br>特例：第一列、第一行，需要单独处理</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const minPathSum &#x3D; grid &#x3D;&gt; &#123;    const row &#x3D; grid.length,        col &#x3D; grid[0].length;    for (let i &#x3D; 1; i &lt; row; i++) &#123;        grid[i][0] +&#x3D; grid[i - 1][0];    &#125;    for (let j &#x3D; 1; j &lt; col; j++) &#123;        grid[0][j] +&#x3D; grid[0][j - 1];    &#125;    for (let i &#x3D; 1; i &lt; row; i++) &#123;        for (let j &#x3D; 1; j &lt; col; j++) &#123;            grid[i][j] +&#x3D; Math.min(grid[i - 1][j], grid[i][j - 1]);        &#125;    &#125;    return grid[row - 1][col - 1];&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="184实现set"><a href="#184实现set" class="headerlink" title="184实现set"></a>184实现set</h3><p>const a = new MySet([1,2,3,3])<br>a.add(4)<br>a.remove(4)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Set &#123;	constructor() &#123;		this.items &#x3D; &#123;&#125;;	&#125;		add(value) &#123;		if (!this.has(value)) &#123;&#x2F;&#x2F;注意			this.items[value] &#x3D; value;			return true;		&#125; else &#123;			return false;		&#125;	&#125;	remove(value) &#123;		if (this.has(value)) &#123;			delete this.items[value];			return true;		&#125; else &#123;			return false;		&#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="185"><a href="#185" class="headerlink" title="185"></a>185</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">把一段字符串中数字相关的放在数组中输出，如果是数字直接使用数字类型，其他都使用字符串类型输入：const str &#x3D; &#39;这是一篇文章：加快递费3.22X10^5，就开始的经费3673降低开jvjsldfjXDJKFLD发洛索洛芬2&#x2F;3，是杜绝浪费0.12345，晋升的了客服-2344&#39;输出结果：[&#39;3.22X10^5&#39;,3673,&#39;2&#x2F;3&#39;,0.12345,-2344]function getNum (str) &#123;    var arr &#x3D; [];    var reg &#x3D; &#x2F;X|\^|\&#x2F;|\.|\d|\-&#x2F;;    	while (reg.exec(str)) &#123;		var count &#x3D; 0;		var j &#x3D; 0;		for (var i &#x3D; reg.exec(str) + 1; i &lt; str.length; i++) &#123;			if (reg.test(str[i])) &#123;				count++;			&#125; else &#123;				arr[j] &#x3D; str.splice(reg.exec(str), count);    			j++;			&#125;		&#125;	&#125;    return arr;&#125;match   [ , , , ,]</span><br></pre></td></tr></table></figure>

<h3 id="186-splice"><a href="#186-splice" class="headerlink" title="186 splice"></a>186 splice</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">splice(index,howmany,item1,.....,itemX)index使用负数可从数组结尾处规定位置，必填howmany要删除的项目数量，必填item1,.....,itemX 向数组添加的新项目，选填</span><br></pre></td></tr></table></figure>

<h3 id="187"><a href="#187" class="headerlink" title="187"></a>187</h3><p>动态作用域：函数内的成员是否可以被访问只有在运行的时候才能确定</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;	alert(x);&#125;function f1()&#123;	var x &#x3D; 1;	f();&#125;function f2()&#123;	var x &#x3D; 2;	f();&#125;f1();&#x2F;&#x2F;报错：x没有定义，说明JS没有动态作用域f2();</span><br></pre></td></tr></table></figure>

<p>JS只有静态作用域lexical，也叫词法作用域或者闭包，在词法创建阶段就确定了相关的作用域。闭包：引用了自由变量的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;	var x &#x3D; 100;	function g()&#123;		...	&#125;	g();&#125;f();function f()&#123;&#x2F;&#x2F;f()创建的时候（浏览器解析的时候），给f添加一个看不到摸不着的成员[[scope]] 		  	 &#x2F;&#x2F;f.[[scope]] &#x3D;&#x3D; window			 &#x2F;&#x2F;f()被调用的时候会创建自己的一个词法环境f.le, f.le -&gt;f.[[scope]]&#x2F;&#x2F;在预处理阶段(上一行解释，f()刚刚被调用时)，f.le&#123;x &#x3D; undefined, g()&#123;...&#125;&#125;，g.[[scope]] &#x3D;&#x3D; f.le&#x2F;&#x2F;在预处理阶段，无论g()是函数声明还是函数表达式创建的都会把g()加入到f.le中	var x &#x3D; 100;&#x2F;&#x2F;在执行阶段，f.le&#123;x &#x3D; 100, g()&#123;...&#125;&#125;	function g()&#123;&#x2F;&#x2F;在预处理阶段，g.[[scope]] &#x3D;&#x3D; f.le		...	&#125;	g();&#x2F;&#x2F;g()在运行时，会创建自己的词法环境，g.le -&gt;g.[[scope]]	&#x2F;&#x2F;综上形成一条链条	&#x2F;&#x2F;g.le -&gt; g.[[scope]] &#x3D;&#x3D; f.le -&gt; f.[[scope]] &#x3D;&#x3D; window&#125;f();</span><br></pre></td></tr></table></figure>

<h3 id="112手写Promise-all和Promise-race"><a href="#112手写Promise-all和Promise-race" class="headerlink" title="112手写Promise.all和Promise.race"></a>112手写Promise.all和Promise.race</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Promise.allfunction promiseAll (promises) &#123;	if (!Array.isArray(promises)) &#123;		throw new Error (&quot;promises must to be an array!!!&quot;);	&#125;	return new Promise (function (resolve, reject) &#123;		let promiseNum &#x3D; promises.length;		let resolvedCount &#x3D; 0;		let resolveValues &#x3D; new Array(promiseNum);        for (let i &#x3D; 0; i &lt; promiseNum; i++) &#123;            try&#123;                promises[i].then(function (value) &#123;                    resolveValues[i] &#x3D; value;                    if (++resolvedCount &#x3D;&#x3D;&#x3D; promiseNum) &#123;                    	resolve(resolveValues);                    &#125;                &#125;            &#125; catch (error) &#123;            	reject(error);            &#125;        &#125;	&#125;)&#125;&#x2F;&#x2F;Promise.racefunction promiseRace(promise) &#123;	if (!Array.isArray (promises)) &#123;		throw new Error (&quot;promises must be an array!!!&quot;);	&#125;	let resolved &#x3D; false;	return new Promise(function (resolve, reject) &#123;		try&#123;			promises.forEach(p &#x3D;&gt;                p.then(data &#x3D;&gt; &#123;                	if (!resolved) &#123;                		resolved &#x3D; true;                		resolve (data);                	&#125;                &#125;)            )		&#125; catch (error) &#123;			reject(error);		&#125;	&#125;)&#125;</span><br></pre></td></tr></table></figure>

<h3 id="202下列代码存在几个变量没有被回收？"><a href="#202下列代码存在几个变量没有被回收？" class="headerlink" title="202下列代码存在几个变量没有被回收？"></a>202下列代码存在几个变量没有被回收？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var i &#x3D; 1;var i &#x3D; 2;var add &#x3D; function() &#123;  var i &#x3D; 0;  return function()&#123;		i++;		console.log(i);	&#125;&#125;();add();</span><br></pre></td></tr></table></figure>

<p>代码回收规则如下：（ 3个）</p>
<p>1.全局变量不会被回收。</p>
<p>2.局部变量会被回收，也就是函数一旦运行完以后，函数内部的东西都会被销毁。</p>
<p>3.只要被另外一个作用域所引用就不会被回收</p>
<p>有3个变量没有被回收，首先是全局变量中的i，第二行声明被忽略，赋值会覆盖掉第一行，因此只有1个。第二个是var add，这个变量也没有回收，他定义了一个匿名函数，并将它赋给了add。第三个就是闭包中的变量i，闭包中的局部变量是不会被回收的，因此是3个变量没有被回收。</p>
<h3 id="188"><a href="#188" class="headerlink" title="188"></a>188</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function addCounter() &#123;    var counter &#x3D; 0;    const myFunction &#x3D; function() &#123;        counter &#x3D; counter + 1;        return counter;    &#125;    return myFunction;&#125;const increment &#x3D; addCounter();const c1 &#x3D; increment();const c2 &#x3D; increment();const c3 &#x3D; increment();console.log(c1, c2, c3);&#x2F;&#x2F;1, 2, 3-------------------------function fn(a) &#123;    console.log(a);    var a &#x3D; 2;    function a() &#123;    	console.log(a);    &#125;&#125;fn(1);&#x2F;&#x2F;f a() &#123; console.log(a) &#125;&#x2F;&#x2F;函数的声明大于变量-----------------function fn1() &#123;	console.log(this);&#125;fn1();&#x2F;&#x2F;windowfn1.call(&#123;x: 100&#125;);&#x2F;&#x2F;&#123;x: 100&#125;const fn2 &#x3D; fn1.bind(&#123;x: 200&#125;);fn2();&#x2F;&#x2F;&#123;x: 200&#125;------------当一个块级容器display:flex时，怎么设置使他的自己由顶部向下排列，再偏右排列flex-direction: column;justify-content: flex-start;align-items: flex-end;-------------------JavaScript中 window 对象的子对象不包含以下那个对象：documenthistoryselfmessage******--------------------------------------------------------------var string &#x3D; &#39;string&#39;;var number &#x3D; 0;var bool &#x3D; true;console.log(number || string);&#x2F;&#x2F;&#39;string&#39;console.log(number &amp;&amp; string);&#x2F;&#x2F;0console.log(bool || number);&#x2F;&#x2F;trueconsole.log(bool &amp;&amp; number);&#x2F;&#x2F;0-----------------------------------------------function Foo() &#123;	console.log(this.location);&#125;Foo();&#x2F;&#x2F;当前窗口的Location对象---------------------javascript中的数字在计算机内存储为多少Byte？JavaScript内部，所有数字都是以64位浮点数形式储存，即使整数也是如此8 Byte &#x3D; 64bit</span><br></pre></td></tr></table></figure>

<h3 id="42如何渲染⼏万条数据并不卡住界⾯"><a href="#42如何渲染⼏万条数据并不卡住界⾯" class="headerlink" title="42如何渲染⼏万条数据并不卡住界⾯"></a>42如何渲染⼏万条数据并不卡住界⾯</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 优化性能，插⼊不会造成回流const fragment &#x3D; document.createDocumentFragment();ul.appendChild(fragment);docunment.createElementdocument.documentElement</span><br></pre></td></tr></table></figure>

<h3 id="189"><a href="#189" class="headerlink" title="189"></a>189</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。输入：nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4]输出：6解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。function maxNum(nums) &#123;    var arr &#x3D; [];    for (var i &#x3D; 0; i &lt; nums.length; i++) &#123;        var maxValue &#x3D; nums[i];        var tempValue &#x3D; nums[i];        for (var j &#x3D; i + 1; j &lt; nums.length; j++) &#123;            tempValue +&#x3D; nums[j];            if (tempValue &gt; maxValue) &#123;            	maxValue &#x3D; tempValue;            &#125;        &#125;        arr[i] &#x3D; maxValue;    &#125;    return Math.max(...arr);&#125;var nums &#x3D; [-2,1,-3,4,-1,2,1,-5,4];console.log(maxNum(nums));</span><br></pre></td></tr></table></figure>

<h3 id="190"><a href="#190" class="headerlink" title="190"></a>190</h3><p>setState本身并不是异步，只是因为react的性能优化机制体现为异步。在react的生命周期函数或者作用域下为异步，在原生的环境下为同步。</p>
<h4 id="setState-只在合成事件和钩子函数中是“异步”的，在原生事件和-setTimeout-中都是同步的。"><a href="#setState-只在合成事件和钩子函数中是“异步”的，在原生事件和-setTimeout-中都是同步的。" class="headerlink" title="setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。"></a>setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。</h4><h5 id="合成事件：就是react-在组件中的onClick等都是属于它自定义的合成事件"><a href="#合成事件：就是react-在组件中的onClick等都是属于它自定义的合成事件" class="headerlink" title="合成事件：就是react 在组件中的onClick等都是属于它自定义的合成事件"></a>合成事件：就是react 在组件中的onClick等都是属于它自定义的合成事件</h5><h5 id="原生事件：比如通过addeventListener添加的，dom中的原生事件"><a href="#原生事件：比如通过addeventListener添加的，dom中的原生事件" class="headerlink" title="原生事件：比如通过addeventListener添加的，dom中的原生事件"></a>原生事件：比如通过addeventListener添加的，dom中的原生事件</h5><h3 id="191"><a href="#191" class="headerlink" title="191"></a>191</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入一个字符串，打印出该字符串中字符的所有排列。你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。示例:输入：s &#x3D; &quot;abc&quot;输出：[&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们将这个问题看作有 nn 个排列成一行的空位，我们需要从左往右依次填入题目给定的 nn 个字符，每个字符只能使用一次。首先可以想到穷举的算法，即从左往右每一个空位都依次尝试填入一个字符，看是否能填完这 nn 个空位，编程实现时，我们可以用「回溯法」来模拟这个过程。定义递归函数 \texttt&#123;backtrack&#125;(i, \textit&#123;perm&#125;)backtrack(i,perm) 表示当前排列为 \textit&#123;perm&#125;perm，下一个待填入的空位是第 ii 个空位（下标从 00 开始）。那么该递归函数分为两个情况：如果 i&#x3D;ni&#x3D;n，说明我们已经填完了 nn 个空位，找到了一个可行的解，我们将 \textit&#123;perm&#125;perm 放入答案数组中，递归结束。如果 i&lt;ni&lt;n，此时需要考虑第 ii 个空位填哪个字符。根据题目要求我们肯定不能填已经填过的字符，因此很容易想到的一个处理手段是我们定义一个标记数组 \textit&#123;vis&#125;vis 来标记已经填过的字符，那么在填第 ii 个字符的时候我们遍历题目给定的 nn 个字符，如果这个字符没有被标记过，我们就尝试填入，并将其标记，继续尝试填下一个空位，即调用函数 \texttt&#123;backtrack&#125;(i + 1, \textit&#123;perm&#125;)backtrack(i+1,perm)。回溯时，我们需要要撤销该空位填的字符以及对该字符的标记，并继续向当前空位尝试填入其他没被标记过的字符。但是该递归函数并没有满足「全排列不重复」的要求，在重复的字符较多的情况下，该递归函数会生成大量重复的排列。对于任意一个空位，如果存在重复的字符，该递归函数会将它们重复填上去并继续尝试导致最后答案的重复。解决该问题的一种较为直观的思路是，我们首先生成所有的排列，然后进行去重。而另一种思路是我们通过修改递归函数，使得该递归函数只会生成不重复的序列。具体地，我们只要在递归函数中设定一个规则，保证在填每一个空位的时候重复字符只会被填入一次。具体地，我们首先对原字符串排序，保证相同的字符都相邻，在递归函数中，我们限制每次填入的字符一定是这个字符所在重复字符集合中「从左往右第一个未被填入的字符」，即如下的判断条件：var permutation &#x3D; function(s) &#123;    const rec &#x3D; [], vis &#x3D; [];    const n &#x3D; s.length;    const arr &#x3D; Array.from(s).sort();    const perm &#x3D; [];    const backtrack &#x3D; (arr, i, n, perm) &#x3D;&gt; &#123;        if (i &#x3D;&#x3D;&#x3D; n) &#123;            rec.push(perm.toString());            return;        &#125;        for (let j &#x3D; 0; j &lt; n; j++) &#123;            if (vis[j] || (j &gt; 0 &amp;&amp; !vis[j - 1] &amp;&amp; arr[j - 1] &#x3D;&#x3D;&#x3D; arr[j])) &#123;                continue;            &#125;            vis[j] &#x3D; true;            perm.push(arr[j]);            backtrack(arr, i + 1, n, perm);            perm.pop();            vis[j] &#x3D; false;        &#125;    &#125;    backtrack(arr, 0, n, perm);    const size &#x3D; rec.length;    const recArr &#x3D; new Array(size).fill(0);    for (let i &#x3D; 0; i &lt; size; i++) &#123;        recArr[i] &#x3D; rec[i].split(&#39;,&#39;).join(&#39;&#39;);    &#125;    return recArr;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="192"><a href="#192" class="headerlink" title="192"></a>192</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function primeNubmer(n)&#123; for(var i&#x3D;2 ; i&lt;n ; i++)&#123;	    var a &#x3D; true;&#x2F;&#x2F;状态码判定是否打印		for(var j &#x3D; 2; j &lt;&#x3D; Math.sqrt(i); j++)&#123;	            &#x2F;&#x2F;判断i能否被j整除		    if(i%j &#x3D;&#x3D; 0)&#123;			&#x2F;&#x2F;能被整除则说明不是素数，修改布尔值为false				a &#x3D; false ;		    &#125;		&#125;		&#x2F;&#x2F;打印素数		if(a)&#123;		    document.writeln(i);		&#125;	 &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="193js实现两个大整数相乘"><a href="#193js实现两个大整数相乘" class="headerlink" title="193js实现两个大整数相乘"></a>193js实现两个大整数相乘</h3><p>一般涉及到大整数，都需要考虑通过数组或者字符串来模拟算术运算。我们通过数组来表示两个数字a、b（这里从左往右需要从个位数到最高位），这里的相乘只需要理解一点：a的每一位a[i]乘以b的每一位b[j]，我们可以先将其放在结果中的result[i+j]中。这是模拟运算的过程。剩下的只需要将result中每一位大于9的进行进位即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function dazhenghsuAdd(str1,str2)&#123;    str1&#x3D;str1.split(&#39;&#39;).reverse();    str2&#x3D;str2.split(&#39;&#39;).reverse();    let result&#x3D;[];    for(let i&#x3D;0;i&lt;str1.length;i++)&#123;        for(let j&#x3D;0;j&lt;str2.length;j++)&#123;            result[i+j]&#x3D;result[i+j]||0;&#x2F;&#x2F;如果result[i+j]是undefined则将其变为0            result[i+j]+&#x3D;parseInt(str1[i])*parseInt(str2[j]);        &#125;    &#125;    let temp;    for(let k&#x3D;0;k&lt;result.length;k++)&#123;        if(result[k]&gt;9)&#123;            temp&#x3D;Math.floor(result[k]&#x2F;10);            result[k]&#x3D;result[k]%10;            result[k+1]&#x3D;result[k+1]||0;            result[k+1]+&#x3D;temp;        &#125;    &#125;    return result.reverse().join(&#39;&#39;);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="194Postman中post的数据类型"><a href="#194Postman中post的数据类型" class="headerlink" title="194Postman中post的数据类型"></a>194Postman中post的数据类型</h3><p>1、form-data  将表单的数据组织成Key-Value形式，也可以上传文件</p>
<p>2、x-www-form-urlencoded   将表单内的数据转换为Key-Value</p>
<p>3、raw   传输txt，json xml，html的数据</p>
<p>4、binary  只可以上传二进制数据，用来上传文件，一次只能上传1个数据</p>
<h3 id="195"><a href="#195" class="headerlink" title="195"></a>195</h3><p>for in可遍历原型链上扩展的属性，Object.keys() 只遍历自身属性</p>
<p>sort会改变原数组</p>
<h3 id="196BIGO"><a href="#196BIGO" class="headerlink" title="196BIGO"></a>196BIGO</h3><p>三个并排的div宽度设置为33.3%，会出现问题？</p>
<p>理想中是显示在一行中，事实却是两行。<br>原因是因为： col元素 display: inline-block后，元素后面的换行符以及空格都会被算上宽度，所以会溢出。<br>两种解决方法：</p>
<ol>
<li>.col加上float: left</li>
<li>.container加上font-size: 0</li>
</ol>
<hr>
<p>line-height是干什么的？</p>
<p>line-height 行高，常见作用有二。</p>
<p>1.如果可能有换行，保证行与行之间距离合适。</p>
<p>2.居中。左侧字体14px，右侧字体18px。如果用一个行高将两部分框起来，可以保证左右两部分中心水平居中。</p>
<hr>
<p>http1.0缓存弊端</p>
<p>HTTP/1.0缓存机制完全依赖时间，弊端显而易见，服务器、客户端的时钟不同步，文档的更新周期小于1s, 都会出现问题。</p>
<p>所以HTTP/1.1提倡的缓存机制是，对比文档的hash值，文档内容变，则hash变，用相对时间代替绝对时间</p>
<p>HTTP/1.1 继承 HTTP/1.0 所以HTTP/1.0的相关字段仍然有效，保留的这些字段就是为了兼容那些仅支持HTTP/1.0的客户端。 HTTP/1.1服务器不应该设置与1.0矛盾的过期策略, 1.1的服务器在没有文档hash值时，也可以使用If-Modified-Since进行判断文档过期。</p>
<p>新增字段：</p>
<ul>
<li>Cache-Control: 用来控制浏览器的缓存行为</li>
<li>ETag: 文档的Hash值</li>
<li>If-None-Match: 用来验证资源是否过期，即文档Hash值是否变化</li>
</ul>
<p>Cache-Control最容易理解也是最常用的就是：</p>
<ul>
<li>no-cache: 浏览器缓存，但是认为是过期缓存</li>
<li>no-store: 浏览器不缓存</li>
<li>max-age：缓存有效时间段</li>
</ul>
<hr>
<p>https的加密原理</p>
<p>HTTPS 没有采用单一的技术去实现，而是根据他们的特点，充分的将这些技术整合进去，以达到性能与安全最大化。这套整合的技术称之为 SSL(安全套接层)，因此 HTTPS 并非是一项新的协议，它只是在 HTTP 上披了一层加密的外壳。</p>
<hr>
<p>如何知道http的传输已经结束</p>
<p>1.Content-Length</p>
<p>2.Transfer-Encoding</p>
<p><a target="_blank" rel="noopener" href="https://www.dazhuanlan.com/cloud_zhao/topics/1414445">https://www.dazhuanlan.com/cloud_zhao/topics/1414445</a></p>
<hr>
<p>WebSocket是哪一层</p>
<p>websocket和http一样都是传输层协议、都是基于tcp应用层协议</p>
<p><strong>tcp</strong>属于哪⼀层（1** <strong>物理层 -&gt; 2</strong> <strong>数据链路层 -&gt; 3</strong> <strong>⽹络层(ip)-&gt; 4</strong> <strong>传输层</strong>(tcp) -&gt; 5 **应⽤层(http)**）</p>
<hr>
<p>闭包的原理和使用场景</p>
<hr>
<p>实现柯里化</p>
<p>把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<p>好处：参数确认、提前确认、延迟执行</p>
<hr>
<p>es6代理</p>
<hr>
<p>http为什么要用长连接，一般用在什么场景中</p>
<p>设置Connection为keep-alive就算是长连接了，但要服务器和客户端都设置</p>
<p>长连接多用于操作频繁，点对点的通讯，而且连接数不能太多情况；</p>
<p>而像WEB网站的http服务一般都用短链接，因为长连接对于服务端来说会耗费一定的资源，而像WEB网站这么频繁的成千上万甚至上亿客户端的连接用短连接会更省一些资源，如果用长连接，而且同时有成千上万的用户，如果每个用户都占用一个连接的话，那可想而知吧。所以并发量大，但每个用户无需频繁操作情况下需用短连好。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/xifenglou/p/12888615.html">https://www.cnblogs.com/xifenglou/p/12888615.html</a></p>
<hr>
<p>状态码  304   5xx</p>
<hr>
<p>tcp连接过程中的状态考察</p>
<p>两端都为 CLOSED 状态</p>
<p>客户端便进⼊ SYN-SENT 状态</p>
<p>服务端进⼊ SYN-RECEIVED 状态</p>
<p>客户端进⼊ ESTABLISHED 状态</p>
<hr>
<p>四次挥手，如果最后一个ack丢了会怎么样</p>
<p>1、当第四步的A发送的确认报文，B收到时，A会等待2MSL的时间后，连接彻底关闭。(因为B收到了，所以2MSL时间内B不会重发第三步的释放报文)</p>
<p>2、当第四步的A发送的确认报文，B没有收到时，B会继续发送第三步的释放报文，A收到后会继续发送第四步的确认报文（此时会重新启动2MSL计时器，重新等待2MSL时间），若在接下来的2MSL的时间内未收到B发送的第三步的释放报文，则意味着B已经收到了A的ack确认报文，连接彻底关闭</p>
<hr>
<p>tcp三次握手详细过程</p>
<p>建⽴连接三次握⼿</p>
<p>在 TCP 协议中，主动发起请求的⼀端为客户端，被动连接的⼀端称为服务端。不管是客户端还是服务端， TCP 连接建⽴完后都能发送和接收数据，所以 TCP 也是⼀个全双⼯的协议。起初，两端都为 CLOSED 状态。在通信开始前，双⽅都会创建 TCB 。 服务器创建完TCB 后遍进⼊ LISTEN 状态，此时开始等待客户端发送数据</p>
<p>第⼀次握⼿</p>
<p>客户端向服务端发送连接请求报⽂段。该报⽂段中包含⾃身的数据通讯初始序号。请求发送后，客户端便进⼊ SYN-SENT 状态，x 表示客户端的数据通信初始序号。</p>
<p>第⼆次握⼿</p>
<p>服务端收到连接请求报⽂段后，如果同意连接，则会发送⼀个应答，该应答中也会包含⾃身的数据通讯初始序号，发送完成后便进⼊ SYN-RECEIVED 状态。</p>
<p>第三次握⼿</p>
<p>当客户端收到连接同意的应答后，还要向服务端发送⼀个确认报⽂。客户端发完这个报⽂段后便进⼊ ESTABLISHED 状态，服务端收到这个应答后也进⼊ESTABLISHED 状态，此时连接建⽴成功。</p>
<p>你是否有疑惑明明两次握⼿就可以建⽴起连接，为什么还需要第三次应答？</p>
<p>因为这是为了防⽌失效的连接请求报⽂段被服务端接收，从⽽产⽣错误</p>
<p>可以想象如下场景。客户端发送了⼀个连接请求 A，但是因为⽹络原因造成了超时，这时 TCP 会启动超时重传的机制再次发送⼀个连接请求 B。此时请求顺利到达服务端，服务端应答完就建⽴了请求。如果连接请求 A 在两端关闭后终于抵达了服务端，那么这时服务端会认为客户端⼜需要建⽴ TCP 连接，从⽽应答了该请求并进⼊ ESTABLISHED 状态。此时客户端其实是 CLOSED 状态，那么就会导致服务端⼀直等待，造成资源的浪费</p>
<hr>
<p>insigned int 类型扩展长度</p>
<p>int 数据，内存就分配给它两个字节</p>
<hr>
<p>https的建立连接过程</p>
<p><strong><em>客户端发起https连接</em></strong></p>
<p><strong><em>服务端发送证书</em></strong></p>
<p><strong><em>客户端验证服务端发来的证书</em></strong>（*<strong>验证证书**<em>、</em></strong>生成随机数、此随机数就是后面用的对称加密的私钥*<strong>、**<em>生成握手信息</em></strong>）</p>
<p><strong><em>服务端接收随机数加密的信息，并解密得到随机数，验证握手信息是否被篡改</em></strong></p>
<p><strong><em>客户端验证服务端发送回来的握手信息，完成握手</em></strong></p>
<hr>
<p>一个长度为一百万的数组中，有超过一半的数都是某一个值，求这个值</p>
<p>1.定义一个辅助数组 zero ，里面全是0；</p>
<p>2.循环输入的数组 arr ，将 arr 每个位置的值（arr[i]）对应到辅助数组zero里的每个位置，使之++。</p>
<p>即 如果arr[1]的值是2，就对应到zero[2]，使zero[2]的值++；……；如果arr[5]的值又是2，就再对应到zero[2]，使zero[2]的值++；</p>
<p>3.循环辅助数组 zero，将其中的数与 arr长度的一半作比较，如果大于则输出该数的位置。即如果 arr.length/2 == 3，zero[3] == 4，则输出3。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function arrCount(arr)&#123;	var count &#x3D; arr.length&#x2F;2;	var zero &#x3D; new Array(Math.floor(count);	var res &#x3D; 0;	if (arr.length &#x3D;&#x3D; 0) &#123;		console.log(&quot;This arr is null!&quot;);		return;	&#125;	for(let i &#x3D; 0; i &lt; arr.length; i++)&#123;		zero[arr[i]]++;		if (zero[arr[i]] &gt;&#x3D; count) &#123;		return arr[i];		&#125;	&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="197前序顺序是（根节点排最先，然后同级先左后右）；中序顺序是-先左后根最后右）；后序顺序是（先左后右最后根）。"><a href="#197前序顺序是（根节点排最先，然后同级先左后右）；中序顺序是-先左后根最后右）；后序顺序是（先左后右最后根）。" class="headerlink" title="197前序顺序是（根节点排最先，然后同级先左后右）；中序顺序是(先左后根最后右）；后序顺序是（先左后右最后根）。"></a>197前序顺序是（根节点排最先，然后同级先左后右）；中序顺序是(先左后根最后右）；后序顺序是（先左后右最后根）。</h3><hr>
<h3 id="1设置元素浮动后，该元素的display值是（block）"><a href="#1设置元素浮动后，该元素的display值是（block）" class="headerlink" title="1设置元素浮动后，该元素的display值是（block）"></a>1设置元素浮动后，该元素的display值是（block）</h3><h3 id="2document-load-与document-ready的区别"><a href="#2document-load-与document-ready的区别" class="headerlink" title="2document load 与document ready的区别"></a>2document load 与document ready的区别</h3><p>页面加载完成有两种事件</p>
<p>load是当页面所有资源全部加载完成后（包括DOM文档树，css文件，js文件，图片资源等）执行一个函数</p>
<p>问题：如果图片资源较多，加载时间较长，onload后等待执行的函数需要等待较长时间，所以一些效果可能受到影响</p>
<p>$(document).ready()是当DOM文档树加载完成后执行一个函数 （不包含图片，css等）所以会比load较快执行</p>
<p>在原生的js中不包括ready()这个方法，只有load方法就是onload事件</p>
<h3 id="13LocalStorage用于浏览器保存持久数据接口，已有保存数据接口setItem-key-value-和获取数据接口getItem-key-。因项目需要我们需要为这个localStorage的数据保存添加一个有效时间time（单位：秒），满足在有效时间内，key-value有效，超过有效时间-即time秒后失效。我们把这个改装后台的localStorage命名为Xstorage，请根据已有的接口，来实现函数-setItem-key-value-time-和-getItem-key-的方法。"><a href="#13LocalStorage用于浏览器保存持久数据接口，已有保存数据接口setItem-key-value-和获取数据接口getItem-key-。因项目需要我们需要为这个localStorage的数据保存添加一个有效时间time（单位：秒），满足在有效时间内，key-value有效，超过有效时间-即time秒后失效。我们把这个改装后台的localStorage命名为Xstorage，请根据已有的接口，来实现函数-setItem-key-value-time-和-getItem-key-的方法。" class="headerlink" title="13LocalStorage用于浏览器保存持久数据接口，已有保存数据接口setItem(key, value)和获取数据接口getItem(key)。因项目需要我们需要为这个localStorage的数据保存添加一个有效时间time（单位：秒），满足在有效时间内，key-value有效，超过有效时间 即time秒后失效。我们把这个改装后台的localStorage命名为Xstorage，请根据已有的接口，来实现函数.setItem(key, value, time)和.getItem(key)的方法。"></a>13LocalStorage用于浏览器保存持久数据接口，已有保存数据接口setItem(key, value)和获取数据接口getItem(key)。因项目需要我们需要为这个localStorage的数据保存添加一个有效时间time（单位：秒），满足在有效时间内，key-value有效，超过有效时间 即time秒后失效。我们把这个改装后台的localStorage命名为Xstorage，请根据已有的接口，来实现函数.setItem(key, value, time)和.getItem(key)的方法。</h3><h3 id="20flex-grow默认值是0；弹性布局中，子元素的float、clear、vertical-align属性无效；弹性布局的定义是取决于容器元素的display属性等于flex或inline-flex来决定的"><a href="#20flex-grow默认值是0；弹性布局中，子元素的float、clear、vertical-align属性无效；弹性布局的定义是取决于容器元素的display属性等于flex或inline-flex来决定的" class="headerlink" title="20flex-grow默认值是0；弹性布局中，子元素的float、clear、vertical-align属性无效；弹性布局的定义是取决于容器元素的display属性等于flex或inline-flex来决定的"></a>20flex-grow默认值是0；弹性布局中，子元素的float、clear、vertical-align属性无效；弹性布局的定义是取决于容器元素的display属性等于flex或inline-flex来决定的</h3><h3 id="24请使用ES5和ESNext分别实现一种继承"><a href="#24请使用ES5和ESNext分别实现一种继承" class="headerlink" title="24请使用ES5和ESNext分别实现一种继承"></a>24请使用ES5和ESNext分别实现一种继承</h3><p>（ESNext:ES6转JavaScript）</p>
<h3 id="28js请使用正则表达式实现匹配网址（从http-www-xxx-com-a-1中www-xxx-com，协议头包含http-https-ftp"><a href="#28js请使用正则表达式实现匹配网址（从http-www-xxx-com-a-1中www-xxx-com，协议头包含http-https-ftp" class="headerlink" title="***28js请使用正则表达式实现匹配网址（从http://www.xxx.com/?a=1中www.xxx.com，协议头包含http/https/ftp"></a>***28js请使用正则表达式实现匹配网址（从<a target="_blank" rel="noopener" href="http://www.xxx.com/?a=1%E4%B8%ADwww.xxx.com%EF%BC%8C%E5%8D%8F%E8%AE%AE%E5%A4%B4%E5%8C%85%E5%90%ABhttp/https/ftp">http://www.xxx.com/?a=1中www.xxx.com，协议头包含http/https/ftp</a></h3><h3 id="31请实现对数组-a-2-a-1-a-0-a-10-a-2-1-按属性a为浮点数的基准进行过滤，过滤掉其中属性a为浮点数的项"><a href="#31请实现对数组-a-2-a-1-a-0-a-10-a-2-1-按属性a为浮点数的基准进行过滤，过滤掉其中属性a为浮点数的项" class="headerlink" title="31请实现对数组[{a:2},{a:1},{a:0},{a:10},{a:2.1}]按属性a为浮点数的基准进行过滤，过滤掉其中属性a为浮点数的项"></a>31请实现对数组[{a:2},{a:1},{a:0},{a:10},{a:2.1}]按属性a为浮点数的基准进行过滤，过滤掉其中属性a为浮点数的项</h3><p>array.filter((item, index) =&gt; {}</p>
<h3 id="37-lt-base-input-v-model-”lovingVue”-gt-lt-base-input-gt-，假如base-input是你封装的组件，在内部如何接收外部传进去的lovingVue，以及内部如何更新外部lovingVue的值？；介绍一下组件中父子间通讯？（https-blog-csdn-net-bigbear00007-article-details-104887792）；如何解决跨域问题？"><a href="#37-lt-base-input-v-model-”lovingVue”-gt-lt-base-input-gt-，假如base-input是你封装的组件，在内部如何接收外部传进去的lovingVue，以及内部如何更新外部lovingVue的值？；介绍一下组件中父子间通讯？（https-blog-csdn-net-bigbear00007-article-details-104887792）；如何解决跨域问题？" class="headerlink" title="37&lt;base-input v-model=”lovingVue”&gt;&lt;/base-input&gt;，假如base-input是你封装的组件，在内部如何接收外部传进去的lovingVue，以及内部如何更新外部lovingVue的值？；介绍一下组件中父子间通讯？（https://blog.csdn.net/bigbear00007/article/details/104887792）；如何解决跨域问题？"></a>37&lt;base-input v-model=”lovingVue”&gt;&lt;/base-input&gt;，假如base-input是你封装的组件，在内部如何接收外部传进去的lovingVue，以及内部如何更新外部lovingVue的值？；介绍一下组件中父子间通讯？（<a target="_blank" rel="noopener" href="https://blog.csdn.net/bigbear00007/article/details/104887792%EF%BC%89%EF%BC%9B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F">https://blog.csdn.net/bigbear00007/article/details/104887792）；如何解决跨域问题？</a></h3><h3 id="38根据以下xml请写出对应的json"><a href="#38根据以下xml请写出对应的json" class="headerlink" title="38根据以下xml请写出对应的json"></a>38根据以下xml请写出对应的json</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style&#x3D;&quot;font-size:18px;&quot;&gt;&lt;xml&gt;&lt;list&gt;&lt;item&gt;&lt;id&gt;12&lt;&#x2F;id&gt;&lt;name&gt;张三&lt;&#x2F;name&gt;&lt;&#x2F;item&gt;&lt;item&gt;&lt;id&gt;13&lt;&#x2F;id&gt;&lt;name&gt;李四&lt;&#x2F;name&gt;&lt;&#x2F;item&gt;&lt;&#x2F;list&gt;&lt;&#x2F;xml&gt;&lt;&#x2F;span&gt;</span><br></pre></td></tr></table></figure>

<p>答案： </p>
<p>&lt;span style=”font-size:18px;”&gt;var list = [{“id”:”12”,”name”:”张三”},{“id”:”13”,”name”:”李四”}];&lt;/span&gt;</p>
<h3 id="47Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？-set"><a href="#47Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？-set" class="headerlink" title="47Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？($set())"></a>47Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？($set())</h3><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_45259626/article/details/106078006">https://blog.csdn.net/weixin_45259626/article/details/106078006</a></p>
<h3 id="49写一段代码，使用vue实现组件内部双向数据绑定，例如有一个输入框组件，用户输入时，同步父组件页面的内容"><a href="#49写一段代码，使用vue实现组件内部双向数据绑定，例如有一个输入框组件，用户输入时，同步父组件页面的内容" class="headerlink" title="49写一段代码，使用vue实现组件内部双向数据绑定，例如有一个输入框组件，用户输入时，同步父组件页面的内容"></a>49写一段代码，使用vue实现组件内部双向数据绑定，例如有一个输入框组件，用户输入时，同步父组件页面的内容</h3><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/mahmud/p/10492189.html">https://www.cnblogs.com/mahmud/p/10492189.html</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_27852041/article/details/87855130">https://blog.csdn.net/qq_27852041/article/details/87855130</a></p>
<h3 id="61模块化CSS的方法，Native-CSS-LESS-SCSS不同的实现，优势和问题（CSS模块化的命名问题、权重问题、变量问题）"><a href="#61模块化CSS的方法，Native-CSS-LESS-SCSS不同的实现，优势和问题（CSS模块化的命名问题、权重问题、变量问题）" class="headerlink" title="61模块化CSS的方法，Native CSS/LESS/SCSS不同的实现，优势和问题（CSS模块化的命名问题、权重问题、变量问题）"></a>61模块化CSS的方法，Native CSS/LESS/SCSS不同的实现，优势和问题（CSS模块化的命名问题、权重问题、变量问题）</h3><p>CSS 模块化的实现方式</p>
<p>BEM 命名规范</p>
<p>BEM 的意思就是块（block）、元素（element）、修饰符（modifier）。是由 Yandex 团队提出的一种前端命名方法论。这种巧妙的命名方法让你的 css 类对其他开发者来说更加透明而且更有意义。</p>
<p>scss，@import ‘./css/base.css’;/<em>页面基础样式</em>/</p>
<p>less支持了模块化，可以@import ‘xxx.less’的形式导入其他less文件实现模块化。</p>
<p>css也可以用@import ‘xxx.css’方式实现模块化，所有页面只引用一个style.css。</p>
<p>这样可以http请求的消耗，同样方便合作开发，后期新增和删除模块只需修改这一个文件即可。</p>
<h3 id="63不直接用-，实现字符串数组的add-strA-strB"><a href="#63不直接用-，实现字符串数组的add-strA-strB" class="headerlink" title="63不直接用+-/，实现字符串数组的add(strA, strB)"></a>63<em>不直接用+-</em>/，实现字符串数组的add(strA, strB)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;加减乘除&#x2F;&#x2F;加法function accAdd(arg1,arg2)&#123;         var r1,r2,m;         try&#123;r1&#x3D;arg1.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r1&#x3D;0&#125;;         try&#123;r2&#x3D;arg2.toString().split(&quot;.&quot;)[1].length&#125;catch(e)&#123;r2&#x3D;0&#125;;         m&#x3D;Math.pow(10,Math.max(r1,r2));         return (arg1*m+arg2*m)&#x2F;m;&#125;&#x2F;&#x2F;减法function accSubtr(arg1,arg2)&#123;        var r1,r2,m,n;        try&#123;r1&#x3D;arg1.toString().split(&quot;.&quot;)[1].length;&#125;catch(e)&#123;r1&#x3D;0;&#125;        try&#123;r2&#x3D;arg2.toString().split(&quot;.&quot;)[1].length;&#125;catch(e)&#123;r2&#x3D;0;&#125;        m&#x3D;Math.pow(10,Math.max(r1,r2));        &#x2F;&#x2F;动态控制精度长度        n&#x3D;(r1&gt;&#x3D;r2)?r1:r2;        return ((arg1*m-arg2*m)&#x2F;m).toFixed(n);&#125; &#x2F;&#x2F;乘法function accMul(arg1,arg2)&#123;        var m&#x3D;0,s1&#x3D;arg1.toString(),s2&#x3D;arg2.toString();          try&#123;m+&#x3D;s1.split(&quot;.&quot;)[1].length&#125;catch(e)&#123;&#125;;          try&#123;m+&#x3D;s2.split(&quot;.&quot;)[1].length&#125;catch(e)&#123;&#125;;          return Number(s1.replace(&quot;.&quot;,&quot;&quot;))*Number(s2.replace(&quot;.&quot;,&quot;&quot;))&#x2F;Math.pow(10,m);&#125;&#x2F;&#x2F;除法function accDivCoupon(arg1,arg2)&#123;        var t1&#x3D;0,t2&#x3D;0,r1,r2;        try&#123;t1&#x3D;arg1.toString().split(&quot;.&quot;)[1].length;&#125;catch(e)&#123;&#125;        try&#123;t2&#x3D;arg2.toString().split(&quot;.&quot;)[1].length;&#125;catch(e)&#123;&#125;        with(Math)&#123;            r1&#x3D;Number(arg1.toString().replace(&quot;.&quot;,&quot;&quot;));            r2&#x3D;Number(arg2.toString().replace(&quot;.&quot;,&quot;&quot;));            return (r1&#x2F;r2)*pow(10,t2-t1);        &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="66手写实现一个基本功能的promise"><a href="#66手写实现一个基本功能的promise" class="headerlink" title="66手写实现一个基本功能的promise"></a>66手写实现一个基本功能的promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Promise(exector) &#123;        let self &#x3D; this;        &#x2F;&#x2F;status表示一种状态        let status &#x3D; &quot;pending&quot;;        let value &#x3D; undefined;        let reason &#x3D; undefined;        &#x2F;&#x2F;成功执行        function resolve(value) &#123;                if (status &#x3D;&#x3D; &#39;pending&#39;) &#123;                        self.value &#x3D; value;                        self.status &#x3D; &quot;resolve&quot;;                &#125;    	&#125;        &#x2F;&#x2F;执行失败        function reject(reason) &#123;                if (status &#x3D;&#x3D; &#39;pending&#39;) &#123;                        self.reason &#x3D; reason;                        self.status &#x3D; &quot;reject&quot;                &#125;        &#125;        &#x2F;&#x2F;对异常操作        try &#123;    	    	exector(resolve, reject)        &#125; catch (e) &#123;    	    	reject(e)    	&#125;    	&#x2F;&#x2F;设置promise的then方法        Promise.prototype.then &#x3D; function(reject, resolve) &#123;                let self &#x3D; this;                if (self.status &#x3D;&#x3D; &#39;resolve&#39;) &#123;        	        	reject(self.value)                &#125;                if (self.status &#x3D;&#x3D; &#39;reject&#39;) &#123;        	        	resolve(self.reason)                &#125;        &#125;        &#x2F;&#x2F;new 一个promise  进行测试          let promise &#x3D; new Promise((reject, resolve) &#x3D;&gt; &#123;    	        resolve(&quot;return resolve&quot;);        &#125;);        promise.then(data &#x3D;&gt; &#123;    	        console.log(&#96;success$&#123;data&#125;&#96;);        &#125;, err &#x3D;&gt; &#123;    	        console.log(&#96;err$&#123;err&#125;&#96;);		&#125;)&#125;</span><br></pre></td></tr></table></figure>

<h3 id="68实现一个具备基础功能的事件监听器，addEventListener-dispatchEvent-removeEventListener"><a href="#68实现一个具备基础功能的事件监听器，addEventListener-dispatchEvent-removeEventListener" class="headerlink" title="68实现一个具备基础功能的事件监听器，addEventListener dispatchEvent removeEventListener"></a>68实现一个具备基础功能的事件监听器，addEventListener dispatchEvent removeEventListener</h3><h3 id="69编程题：输出旋转数组的最小元素"><a href="#69编程题：输出旋转数组的最小元素" class="headerlink" title="69编程题：输出旋转数组的最小元素"></a>69编程题：输出旋转数组的最小元素</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;直接遍历，找到最小值。像选择排序一样，找到最小值索引，找到最小值&#x2F;&#x2F;利用二分查找。如果中间元素值&gt;最后一个元素值，说明最小值右半区间，如果中间元素&lt;最后一个元素区间，说明最小值在左半区间，如果相等说明有相同元素，需要将判断区间往前缩一下，继续判断，不断循环，当二分查找的的左右区间相等了，就说明找到最小值了。function minNumberINRotateArray (rotateArray) &#123;	var len &#x3D; rotateArray.length;	if (len &#x3D; 0) &#123;return 0;&#125;	var left &#x3D; 0;	var right &#x3D; len - 1;	while (left &lt; right) &#123;		var mid &#x3D; Math.floor(len &#x2F; 2);		if (rotateArray[mid] &gt; rotateArray[right])            &#123;                left &#x3D; mid + 1;            &#125;else if (rotateArray[mid] &lt; rotateArray[right]) &#123;                right&#x3D;mid;            &#125;else &#123;            	right&#x3D;right-1;            &#125;        &#125;	&#125;	return rotateArray[left];&#125;</span><br></pre></td></tr></table></figure>

<h3 id="70编程题：给定数组arr，设数组长度为n，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim，代表要找的钱数，求换钱的方法数有多少种。由于方法的种数比较大，所以要求输出对109-710-9-7109-7进行取模后的答案。-动态规划的题，老难了"><a href="#70编程题：给定数组arr，设数组长度为n，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim，代表要找的钱数，求换钱的方法数有多少种。由于方法的种数比较大，所以要求输出对109-710-9-7109-7进行取模后的答案。-动态规划的题，老难了" class="headerlink" title="***70编程题：给定数组arr，设数组长度为n，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim，代表要找的钱数，求换钱的方法数有多少种。由于方法的种数比较大，所以要求输出对109+710^9+7109+7进行取模后的答案。(动态规划的题，老难了)"></a>***70编程题：给定数组arr，设数组长度为n，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim，代表要找的钱数，求换钱的方法数有多少种。由于方法的种数比较大，所以要求输出对109+710^9+7109+7进行取模后的答案。(动态规划的题，老难了)</h3><h3 id="73将字符串中的rgb颜色转换为16进制"><a href="#73将字符串中的rgb颜色转换为16进制" class="headerlink" title="73将字符串中的rgb颜色转换为16进制"></a>73将字符串中的rgb颜色转换为16进制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function formatColor(str) &#123;    const newstr &#x3D; str.replace(&#x2F;(rgb\()|(\))&#x2F;g, &#39;&#39;)    const arr &#x3D; newstr.split(&#39;,&#39;)    let res &#x3D; &#39;#&#39;    for(var val of arr)&#123;        res +&#x3D; fillZero(switchNumToSixteen(parseInt(val)))    &#125;    return res&#125; function switchNumToSixteen(num) &#123;    return num.toString(16)&#x2F;&#x2F;转换为16进制&#125;  function fillZero(str) &#123;    if(parseInt(str, 16) &lt; 16) &#123;&#x2F;&#x2F;转换为16进制        return &#39;0&#39; + str    &#125;    return str&#125;</span><br></pre></td></tr></table></figure>

<h3 id="74根据包名，在指定空间中创建对象"><a href="#74根据包名，在指定空间中创建对象" class="headerlink" title="74根据包名，在指定空间中创建对象"></a>74根据包名，在指定空间中创建对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输入描述:namespace(&#123;a: &#123;test: 1, b: 2&#125;&#125;, &#39;a.b.c.d&#39;)输出描述:&#123;a: &#123;test: 1, b: &#123;c: &#123;d: &#123;&#125;&#125;&#125;&#125;&#125;理解题意命名空间命名空间是一种代码封装技术,代码中的每个成员，都是自己的活动空间，彼此互不干扰。首先理解题意，namespace($1, $2)函数中第一个参数是现有命名空间中的对象，而第二个参数是需要此空间实现的结构（即对象的包含关系），可知是a包含b包含c包含d；解题思路首先因为题目所要求创建的空间是顺序的，所以直接通过循环，将其一个个创建即可。当空间中包含对象时（如a：&#123;test：1&#125;）则保留此对象；当包含内容不是对象时（如b：2），则将其设置为一个空对象。如果不包含此空间名，则在其上一级空间中创建一个空对象。function namespace(oNamespace, sPackage) &#123;    var package &#x3D; sPackage.split(&#39;.&#39;);    var obj &#x3D; oNamespace;        for (var i &#x3D; 0; i &lt; package.length; ++i) &#123;        if (typeof obj[package[i]] !&#x3D;&#x3D; &#39;object&#39;) &#123;            obj[package[i]] &#x3D; &#123;&#125;;        &#125;         obj &#x3D; obj[package[i]];    &#125;    return oNamespace;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="76有-n-个城市，其中一些彼此相连，另一些没有相连。如果城市-a-与城市-b-直接相连，且城市-b-与城市-c-直接相连，那么城市-a-与城市-c-间接相连。"><a href="#76有-n-个城市，其中一些彼此相连，另一些没有相连。如果城市-a-与城市-b-直接相连，且城市-b-与城市-c-直接相连，那么城市-a-与城市-c-间接相连。" class="headerlink" title="76有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。"></a>76有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</h3><p>省份 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p>
<p>给你一个 n x n 的矩阵 isConnected ，其中 isConnected[i][j] = 1 表示第 i 个城市和第 j 个城市直接相连，而 isConnected[i][j] = 0 表示二者不直接相连。</p>
<p>返回矩阵中 省份 的数量。</p>
<p>思路：</p>
<p>利用路径标记的方式，采用一维数组标记是否相连：若城市 i 与城市 j 相连，则与城市 j 相连的其它城市均与城市 i 相连。</p>
<p>通过dfs方式可以搜索全部的相连城市，并根据搜索的路径确定当前城市是否为当前类别。</p>
<h3 id="89断开链接四次握⼿"><a href="#89断开链接四次握⼿" class="headerlink" title="89断开链接四次握⼿"></a>89断开链接四次握⼿</h3><p>TCP 是全双⼯的，在断开连接时两端都需要发送 FIN 和 ACK 。</p>
<p>第⼀次握⼿</p>
<p>若客户端 A 认为数据发送完成，则它需要向服务端 B 发送连接释放请求。</p>
<p>第⼆次握⼿</p>
<p>B 收到连接释放请求后，会告诉应⽤层要释放 TCP 链接。然后会发送 ACK包，并进⼊ CLOSE_WAIT 状态，表示 A 到 B 的连接已经释放，不接收 A 发的数据了。但是因为 TCP 连接时双向的，所以 B 仍旧可以发送数据给 A。</p>
<p>第三次握⼿</p>
<p>如果此时还有没发完的数据会继续发送，完毕后会向 A 发送连接释放请求，然后 B 便进⼊ LAST-ACK 状态。PS：通过延迟确认的技术（通常有时间限制，否则对⽅会误认为需要重传），可以将第⼆次和第三次握⼿合并，延迟 ACK 包的发送。</p>
<p>第四次握⼿</p>
<p>A 收到释放请求后，向 B 发送确认应答，此时 A 进⼊ TIME-WAIT 状态。该状态会持续2MSL（最⼤段⽣存期，指报⽂段在⽹络中⽣存的时间，超时会被抛弃） 时间，若该时间段内没有 B 的重发请求的话，就进⼊ CLOSED 状态。当 B 收到确认应答后，也便进⼊CLOSED 状态。</p>
<h3 id="94表单可以跨域吗-可以"><a href="#94表单可以跨域吗-可以" class="headerlink" title="94表单可以跨域吗 可以"></a><strong>94</strong>表单可以跨域吗 <strong>可以</strong></h3><p>Form表单可以跨域是因为要保持兼容性，当请求到另一个域名后，原页面得脚本无法获取新页面中得内容，提交的form表单数据不需要返回，所以浏览器认为是安全得行为，所以浏览器不会阻止form表单跨域，而ajax我们需要返回的数据，浏览器认为不安全，所以会阻止这个请求行为。</p>
<h3 id="98-监听input的哪个事件，在什么时候触发"><a href="#98-监听input的哪个事件，在什么时候触发" class="headerlink" title="98 监听input的哪个事件，在什么时候触发"></a><strong>98</strong> <strong>监听input的哪个事件，在什么时候触发</strong></h3><p>onfocus  onblur  onkeydown  onkeyup  onclick</p>
<p>onchange 当input失去焦点并且它的value值发生变化时触发</p>
<p>onselect 当input里的内容文本被选中后执行一段，只要选择了就会触发，不是非得全部选中</p>
<p>oninput 当input的value值发生变化时就会触发，不用等到失去焦点（与onchange的区别）</p>
<h3 id="100mixin-和-mixins-区别"><a href="#100mixin-和-mixins-区别" class="headerlink" title="100mixin 和 mixins 区别"></a><strong>100mixin</strong> <strong>和 mixins</strong> <strong>区别</strong></h3><p>mixin ⽤于全局混⼊，会影响到每个组件实例，通常插件都是这样做初始化的，虽然⽂档不建议我们在应⽤中直接使⽤ mixin ，但是如果不滥⽤的话也是很有帮助的，⽐如可以全局混⼊封装好的 ajax 或者⼀些⼯具函数等等。</p>
<p>mixins 应该是我们最常使⽤的扩展组件的⽅式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 mixins 混⼊代码，⽐如上拉下拉加载数据这种逻辑等等。</p>
<p>另外需要注意的是 mixins 混⼊的钩⼦函数会先于组件内的钩⼦函数执⾏，并且在遇到同名选项的时候也会有选择性的进⾏合并。</p>
<h3 id="101工厂模式"><a href="#101工厂模式" class="headerlink" title="101工厂模式"></a>101工厂模式</h3><p>当然⼯⼚模式并不仅仅是⽤来 new 出实例。</p>
<p>可以想象⼀个场景。假设有⼀份很复杂的代码需要⽤户去调⽤，但是⽤户并不关⼼这些复杂的代码，只需要你提供给我⼀个接⼝去调⽤，⽤户只负责传递需要的参数，⾄于这些参数怎么使⽤，内部有什么逻辑是不关⼼的，只需要你最后返回我⼀个实例。这个构造过程就是⼯⼚。</p>
<p>⼯⼚起到的作⽤就是隐藏了创建实例的复杂度，只需要提供⼀个接⼝，简单清晰。</p>
<p>在 Vue 源码中，你也可以看到⼯⼚模式的使⽤，⽐如创建异步组件</p>
<h3 id="125编写一个函数repeatStr-，使用字符串的repeat-方法来将任意一个字符串进行不断重复，然后超过20个字符的部分就截断舍弃，也就是最终返回一个包含20个字符的字符串。"><a href="#125编写一个函数repeatStr-，使用字符串的repeat-方法来将任意一个字符串进行不断重复，然后超过20个字符的部分就截断舍弃，也就是最终返回一个包含20个字符的字符串。" class="headerlink" title="125编写一个函数repeatStr()，使用字符串的repeat()方法来将任意一个字符串进行不断重复，然后超过20个字符的部分就截断舍弃，也就是最终返回一个包含20个字符的字符串。"></a>125编写一个函数repeatStr()，使用字符串的repeat()方法来将任意一个字符串进行不断重复，然后超过20个字符的部分就截断舍弃，也就是最终返回一个包含20个字符的字符串。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function repeatStr(str) &#123;  const len &#x3D; 20;  const n &#x3D; Math.ceil(len &#x2F; str.length);  return str.repeat(n).substr(0, len);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="126编写一个函数shieldStr-，用于接收一个电子邮件地址，然后将-前面所有的字符屏蔽掉。比如，-x6c-118-x79-101-115-x74-x75-100-x79-x40-x66-111-120-109-x61-105-108-46-x63-111-x6d-将被屏蔽为：-foxmail-com。"><a href="#126编写一个函数shieldStr-，用于接收一个电子邮件地址，然后将-前面所有的字符屏蔽掉。比如，-x6c-118-x79-101-115-x74-x75-100-x79-x40-x66-111-120-109-x61-105-108-46-x63-111-x6d-将被屏蔽为：-foxmail-com。" class="headerlink" title="126编写一个函数shieldStr()，用于接收一个电子邮件地址，然后将@前面所有的字符屏蔽掉。比如，&#x6c;&#118;&#x79;&#101;&#115;&#x74;&#x75;&#100;&#x79;&#x40;&#x66;&#111;&#120;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;将被屏蔽为：**********@foxmail.com。"></a>126编写一个函数shieldStr()，用于接收一个电子邮件地址，然后将@前面所有的字符屏蔽掉。比如，<a href="mailto:&#x6c;&#118;&#x79;&#101;&#115;&#x74;&#x75;&#100;&#x79;&#x40;&#x66;&#111;&#120;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;">&#x6c;&#118;&#x79;&#101;&#115;&#x74;&#x75;&#100;&#x79;&#x40;&#x66;&#111;&#120;&#109;&#x61;&#105;&#108;&#46;&#x63;&#111;&#x6d;</a>将被屏蔽为：**********@foxmail.com。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function shieldStr(str) &#123;  const arr &#x3D; str.split(&quot;@&quot;);  const str1 &#x3D; &quot;*&quot;.repeat(arr[0].length);  const str2 &#x3D; arr[1];  return &#96;$&#123;str1&#125;@$&#123;str2&#125;&#96;;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="127"><a href="#127" class="headerlink" title="127"></a>127</h3><p>在实际开发中，为什么我们要把“类数组”转换为“真正的数组”，其目的是什么？</p>
<p>主要是为了使得类数组也能使用真正数组的各种方法，比如push()、slice()等。</p>
<h3 id="128"><a href="#128" class="headerlink" title="128"></a>128</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const person &#x3D; &#123;    name: &quot;Jack&quot;,    age: 24&#125;;const result &#x3D; Object.assign(&#123;&#125;, person);result.name &#x3D; &quot;Lucy&quot;;console.log(result.name);console.log(person.name);&#x2F;&#x2F;下面有一段代码，其运行结果是:&#x2F;&#x2F;&quot;Lucy&quot;, &quot;Jack&quot;const person &#x3D; &#123;    name: &#123;        first: &quot;Jack&quot;,        last: &quot;Mo&quot;    &#125;,    age: 24&#125;;const result &#x3D; Object.assign(&#123;&#125;, person);result.name.first &#x3D; &quot;Lucy&quot;;console.log(result.name.first);console.log(person.name.first);&#x2F;&#x2F;&quot;Lucy&quot;, &quot;Lucy&quot;</span><br></pre></td></tr></table></figure>

<h3 id="135二叉树深度"><a href="#135二叉树深度" class="headerlink" title="135二叉树深度"></a>135二叉树深度</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;递归。树的深度&#x3D;左子树的深度和右子树深度中最大者+1function TreeDepth(pRoot)&#123;    if(pRoot &#x3D;&#x3D;&#x3D; null) return 0;    var left &#x3D; TreeDepth(pRoot.left);    var right &#x3D; TreeDepth(pRoot.right);    return Math.max(left,right)+1;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="136如何判断一个对象是-Map或者Set数据结构"><a href="#136如何判断一个对象是-Map或者Set数据结构" class="headerlink" title="136如何判断一个对象是 Map或者Set数据结构"></a>136如何判断一个对象是 Map或者Set数据结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;1. 可以通过 instanceofvar set &#x3D; new Set();console.log(set instanceof Set);&#x2F;&#x2F;2. 构造函数  constructorconsole.log(set.constructor &#x3D;&#x3D; Set);&#x2F;&#x2F;3. Object.prototype.toString.call()var set &#x3D; new Set();console.log(Object.prototype.toString.call(set) &#x3D;&#x3D; &quot;[object Set]&quot;);&#x2F;&#x2F;4. isPrototypeOfvar set &#x3D; new Set();console.log(Set.prototype.isPrototypeOf(set));</span><br></pre></td></tr></table></figure>

<h3 id="139-对象a-b-存在相同的key值，b覆盖a属性值，如果a，b相同的key对应的值均为对象，则再次进行对象合并"><a href="#139-对象a-b-存在相同的key值，b覆盖a属性值，如果a，b相同的key对应的值均为对象，则再次进行对象合并" class="headerlink" title="139 对象a, b 存在相同的key值，b覆盖a属性值，如果a，b相同的key对应的值均为对象，则再次进行对象合并"></a>139 对象a, b 存在相同的key值，b覆盖a属性值，如果a，b相同的key对应的值均为对象，则再次进行对象合并</h3><h3 id="143给你一个包含-n-个整数的数组-nums，判断-nums-中是否存在三个元素-a，b，c-，使得-a-b-c-0-？请你找出所有和为-0-且不重复的三元组。"><a href="#143给你一个包含-n-个整数的数组-nums，判断-nums-中是否存在三个元素-a，b，c-，使得-a-b-c-0-？请你找出所有和为-0-且不重复的三元组。" class="headerlink" title="143给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。"></a>143给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;输入：nums &#x3D; [-1,0,1,2,-1,-4]&#x2F;&#x2F;输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure>

<hr>
<hr>
<h3 id="1-前端需要注意哪些SEO"><a href="#1-前端需要注意哪些SEO" class="headerlink" title="1 前端需要注意哪些SEO"></a>1 前端需要注意哪些SEO</h3><p>1  合理的 title 、 description 、 keywords 。</p>
<p>语义化代码让搜索引擎容易理解⽹⻚，重要内容 HTML 代码放在最前：搜索引擎抓取 HTML 顺序是从上到下，有的搜索引擎对抓取⻓度有限制，保证重要内容⼀定会被抓取重要内容不要⽤ js 输出：爬⾍不会执⾏js获取内容</p>
<p>3  少⽤ iframe 。搜索引擎不会抓取 iframe 中的内容<br>4  ⾮装饰性图⽚必须加 alt。<br>5  提⾼⽹站速度。⽹站速度是搜索引擎排序的⼀个重要指标</p>
<h3 id="2-HTML5-的离线储存怎么使⽤，⼯作原理能不能解释⼀下？"><a href="#2-HTML5-的离线储存怎么使⽤，⼯作原理能不能解释⼀下？" class="headerlink" title="2 HTML5 的离线储存怎么使⽤，⼯作原理能不能解释⼀下？"></a>2 HTML5 的离线储存怎么使⽤，⼯作原理能不能解释⼀下？</h3><p>在⽤户没有与因特⽹连接时，可以正常访问站点或应⽤，在⽤户与因特⽹连接时，更新⽤户机器上的缓存⽂件<br>原理： HTML5 的离线存储是基于⼀个新建的 .appcache ⽂件的缓存机制(不是存储技术)，通过这个⽂件上的解析清单离线存储资源，这些资源就会像 cookie ⼀样被存储了下来。之后当⽹络在处于离线状态下时，浏览器会通过被离线存储的数据进⾏⻚⾯展示<br>如何使⽤：<br>⻚⾯头部像下⾯⼀样加⼊⼀个 manifest 的属性；在 cache.manifest ⽂件的编写离线存储的资源；在离线状态时，操作 window.applicationCache 进⾏需求实现</p>
<p>在线的情况下，浏览器发现 html 头部有 manifest 属性，它会请求 manifest ⽂件，如果是第⼀次访问 app ，那么浏览器就会根据manifest⽂件的内容下载相应的资源并且进⾏离线存储。如果已经访问过 app 并且资源已经离线存储了，那么浏览器就会使⽤离线的资源加载⻚⾯，然后浏览器会对⽐新的 manifest ⽂件与旧的 manifest ⽂件，如果⽂件没有发⽣改变，就不做任何操作，如果⽂件改变了，那么就会重新下载⽂件中的资源并进⾏离线存储。</p>
<p>离线的情况下，浏览器就直接使⽤离线存储的资源。</p>
<h3 id="4-HTML全局属性-global-attribute-有哪些"><a href="#4-HTML全局属性-global-attribute-有哪些" class="headerlink" title="4 HTML全局属性(global attribute)有哪些"></a>4 HTML全局属性(global attribute)有哪些</h3><p>class :为元素设置类标识<br>data-* : 为元素增加⾃定义属性<br>draggable : 设置元素是否可拖拽<br>id : 元素 id ，⽂档内唯⼀<br>lang : 元素内容的的语⾔<br>style : ⾏内 css 样式<br>title : 元素相关的建议信息</p>
<h3 id="5-HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt"><a href="#5-HTML5-为什么只需要写-lt-DOCTYPE-HTML-gt" class="headerlink" title="5 HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;"></a>5 HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;</h3><p>HTML5 不基于 SGML ，因此不需要对 DTD 进⾏引⽤，但是需要 doctype 来规范浏览器的⾏为<br>⽽ HTML4.01 基于 SGML ,所以需要对 DTD 进⾏引⽤，才能告知浏览器⽂档所使⽤的⽂档类型</p>
<h3 id="6-如何在⻚⾯上实现⼀个圆形的可点击区域？"><a href="#6-如何在⻚⾯上实现⼀个圆形的可点击区域？" class="headerlink" title="6 如何在⻚⾯上实现⼀个圆形的可点击区域？"></a>6 如何在⻚⾯上实现⼀个圆形的可点击区域？</h3><p>svg<br>border-radius</p>
<h3 id="7-viewport里的配置，延伸提问，怎样处理移动端1px被渲染成2px问题"><a href="#7-viewport里的配置，延伸提问，怎样处理移动端1px被渲染成2px问题" class="headerlink" title="7 viewport里的配置，延伸提问，怎样处理移动端1px被渲染成2px问题"></a>7 viewport里的配置，延伸提问，怎样处理移动端1px被渲染成2px问题</h3><p>局部处理<br>mate 标签中的 viewport 属性 ， initial-scale 设置为 1<br>rem 按照设计稿标准⾛，外加利⽤ transfrome 的 scale(0.5) 缩⼩⼀倍即可；</p>
<p>全局处理<br>mate 标签中的 viewport 属性 ， initial-scale 设置为 0.5<br>rem 按照设计稿标准⾛即可</p>
<h3 id="8-div-css的布局较table布局有什么优点？"><a href="#8-div-css的布局较table布局有什么优点？" class="headerlink" title="8 div+css的布局较table布局有什么优点？"></a>8 div+css的布局较table布局有什么优点？</h3><p>改版的时候更⽅便，只要改 css ⽂件。<br>⻚⾯加载速度更快、结构化清晰、⻚⾯显示简洁。<br>表现与结构相分离。<br>易于优化（ seo ）搜索引擎更友好，排名更容易靠前。</p>
<h3 id="10-web开发中会话跟踪的⽅法有哪些"><a href="#10-web开发中会话跟踪的⽅法有哪些" class="headerlink" title="10 web开发中会话跟踪的⽅法有哪些"></a>10 web开发中会话跟踪的⽅法有哪些</h3><p>HTTP协议由两部分程序实现：一个客户端程序和一个服务器程序，它们运行在不同的端系统当中，通过交换HTTP报文进行会话。</p>
<p>在一个会话中，跟踪请求之间的数据成为会话跟踪。</p>
<p>（一）应用隐藏域进行会话跟踪(隐藏 input)<br>利用HTML中的隐藏域，在网页表单内填写客户端的信息。这些信息会随客户端的请求信息一起传送给服务器，服务器通过获取的这些信息来进行会话跟踪。<br>隐藏域的HTML标签如下：</p>
<p>&lt;input type=”hidden” name=”隐藏域名称” value=”默认值”&gt;<br>应用隐藏域的请求信息在浏览器页面是看不到的，但是查看源代码的话是可以看到客户端的请求信息的，所以这种方式显然是不安全的，会导致信息泄露。<br>（二）SSL会话（Secure Socket Layer）<br>安全套接字（Secure Socket Layer，SSL）协议是Web浏览器与Web服务器之间安全交换信息的协议，提供两个基本的安全服务：鉴别与保密。在SSL中会使用密钥交换算法交换密钥；使用密钥对数据进行加密；使用散列算法对数据的完整性进行验证，使用数字证书证明自己的身份。<br>（三）Cookies<br>Cookie是由服务器端生成，发送给浏览器，浏览器会将Cookie的key/value保存到某个目录下的文本文件内，下次请求同一网站时就发送该Cookie给服务器（前提是浏览器设置为启用cookie）。Cookie名称和值可以由服务器端开发自己定义，这样服务器可以知道该用户是否合法用户以及是否需要重新登录等。<br>服务器可以利用Cookies包含信息的任意性来筛选并经常性维护这些信息，以判断在HTTP传输中的状态。Cookies最典型的应用是判定注册用户是否已经登录网站，用户可能会得到提示，是否在下一次进入此网站时保留用户信息以便简化登录手续，这样就实现了对客户的追踪。<br>（四）URL重写<br>URL重写就是首先获得一个进入的URL请求然后把它重新写成网站可以处理的另一个URL的过程。举个例子来说，如果通过浏览器进来的URL是“UserProfile.aspx?ID=1”那么它可以被重写成 “UserProfile/1.aspx”，这样的URL，这样的网址可以更好的被网站所阅读。<br>如果浏览器不支持Cookie或用户阻止了所有Cookie，可以把会话ID附加在HTML页面中所有的URL上，这些页面作为响应发送给客户。这样，当用户单击URL时，会话ID被自动作为请求行的一部分而不是作为头行发送回服务器。这种方法称为URL重写。</p>
<p>（五）ip 地址</p>
<h3 id="11-link-与-import-的区别"><a href="#11-link-与-import-的区别" class="headerlink" title="11 link 与 @import 的区别"></a>11 link 与 @import 的区别</h3><p>link属于html标签。@import在css中使用表示导入外部样式表；<br>页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载;<br>import只在IE5以上才能识别，而link是HTML标签，无兼容问题;<br>link方式的样式的权重高于@import的权重；<br>link 支持使用javascript改变样式 （document.styleSheets），后者不可</p>
<p>总体来说： link 优于 @import</p>
<h4 id="什么是FOUC-如何避免"><a href="#什么是FOUC-如何避免" class="headerlink" title="什么是FOUC?如何避免"></a>什么是FOUC?如何避免</h4><p>Flash Of Unstyled Content ：⽤户定义样式表加载之前浏览器使⽤默认样式显示⽂档，⽤户样式加载渲染之后再从新显示⽂档，造成⻚⾯闪烁。<br>解决⽅法：把样式表放到⽂档的 &lt;head&gt;</p>
<h3 id="13-在⽹⻚中的应该使⽤奇数还是偶数的字体？为什么呢？"><a href="#13-在⽹⻚中的应该使⽤奇数还是偶数的字体？为什么呢？" class="headerlink" title="13 在⽹⻚中的应该使⽤奇数还是偶数的字体？为什么呢？"></a>13 在⽹⻚中的应该使⽤奇数还是偶数的字体？为什么呢？</h3><p>偶数字号相对更容易和 web 设计的其他部分构成⽐例关系</p>
<h3 id="16-stylus-sass-less区别"><a href="#16-stylus-sass-less区别" class="headerlink" title="16 stylus/sass/less区别"></a>16 stylus/sass/less区别</h3><p>均具有“变量”、“混合”、“嵌套”、“继承”、“颜⾊混合”五⼤基本特性；<br>Scss 和 LESS 语法较为严谨， LESS 要求⼀定要使⽤⼤括号“{}”， Scss 和 Stylus 可以通过缩进表示层次与嵌套关系<br>Scss ⽆全局变量的概念， LESS 和 Stylus 有类似于其它语⾔的作⽤域概念<br>Sass 是基于 Ruby 语⾔的，⽽ LESS 和 Stylus 可以基于 NodeJS NPM 下载相应库后进⾏编译；</p>
<h3 id="17-postcss的作⽤"><a href="#17-postcss的作⽤" class="headerlink" title="17 postcss的作⽤"></a>17 postcss的作⽤</h3><p>可以直观的理解为：它就是⼀个平台。PostCSS 提供了⼀个解析器，它能够将 CSS 解析成抽象语法树<br>通过在 PostCSS 这个平台上，我们能够开发⼀些插件，来处理我们的 CSS ，⽐如热⻔的： autoprefixer<br>postcss 可以对sass处理过后的 css 再处理 最常⻅的就是 autoprefixer</p>
<h3 id="18-伪类和伪元素的区别"><a href="#18-伪类和伪元素的区别" class="headerlink" title="18 伪类和伪元素的区别"></a>18 伪类和伪元素的区别</h3><p>伪类表状态；伪元素是真的有元素<br>前者单冒号，后者双冒号</p>
<h3 id="19请⽤CSS写⼀个简单的幻灯⽚效果⻚⾯"><a href="#19请⽤CSS写⼀个简单的幻灯⽚效果⻚⾯" class="headerlink" title="19请⽤CSS写⼀个简单的幻灯⽚效果⻚⾯"></a>19请⽤CSS写⼀个简单的幻灯⽚效果⻚⾯</h3><p>知道是要⽤ CSS3 。使⽤ animation 动画实现⼀个简单的幻灯⽚效果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.ani&#123; width:480px; height:320px; margin:50px auto; overflow: hidden; box-shadow:0 0 5px rgba(0,0,0,1); background-size: cover; background-position: center; -webkit-animation-name: &quot;loops&quot;; -webkit-animation-duration: 20s; -webkit-animation-iteration-count: infinite;&#125;@-webkit-keyframes &quot;loops&quot; &#123; 0% &#123; background:url(http:&#x2F;&#x2F; &#125; 25% &#123; background:url(http:&#x2F;&#x2F; &#125; 50% &#123; background:url(http:&#x2F;&#x2F; &#125; 75% &#123; background:url(http:&#x2F;&#x2F; &#125; 100% &#123; background:url(http:&#x2F;&#x2F; &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="21-如何使⽤CSS实现硬件加速？"><a href="#21-如何使⽤CSS实现硬件加速？" class="headerlink" title="21 如何使⽤CSS实现硬件加速？"></a>21 如何使⽤CSS实现硬件加速？</h3><p>硬件加速是指通过创建独⽴的复合图层，让GPU来渲染这个图层，从⽽提⾼性能，⼀般触发硬件加速的 CSS 属性有 transform 、 opacity 、 filter ，为了避免2D动画,在开始和结束的时候的 repaint 操作，⼀般使⽤tranform:translateZ(0)</p>
<h3 id="22-如何实现⼩于12px的字体效果"><a href="#22-如何实现⼩于12px的字体效果" class="headerlink" title="22 如何实现⼩于12px的字体效果"></a>22 如何实现⼩于12px的字体效果</h3><p>transform:scale() 这个属性只可以缩放可以定义宽⾼的元素，⽽⾏内元素是没有宽⾼的，我们可以加上⼀个 display:inline-block ;</p>
<h3 id="25-XML和JSON的区别？"><a href="#25-XML和JSON的区别？" class="headerlink" title="25 XML和JSON的区别？"></a>25 XML和JSON的区别？</h3><p>JSON 相对 于XML 来讲，数据的体积⼩，传递的速度更快些。<br>JSON 与 JavaScript 的交互更加⽅便，更容易解析处理，更好的数据交互<br>JSON 对数据的描述性⽐ XML 较差<br>JSON 的速度要远远快于 XML</p>
<h3 id="30-offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别"><a href="#30-offsetWidth-offsetHeight-clientWidth-clientHeight与scrollWidth-scrollHeight的区别" class="headerlink" title="30 offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别"></a>30 offsetWidth/offsetHeight,clientWidth/clientHeight与scrollWidth/scrollHeight的区别</h3><p>offsetWidth/offsetHeight 返回值包含content + padding + border，效果与e.getBoundingClientRect()相同<br>clientWidth/clientHeight 返回值只包含content + padding，如果有滚动条，也不包含滚动条<br>scrollWidth/scrollHeight 返回值包含content + padding + 溢出内容的尺⼨</p>
<p>ele.scrollTop = 被卷去的上侧距离<br>ele.scrollHeight = 自身实际的高度（不包括边框）</p>
<h2 id="31-Node的应⽤场景"><a href="#31-Node的应⽤场景" class="headerlink" title="31 Node的应⽤场景"></a>31 Node的应⽤场景</h2><p>特点：<br>它是⼀个 Javascript 运⾏环境<br>依赖于 Chrome V8 引擎进⾏代码解释<br>事件驱动<br>⾮阻塞 I/O<br>单进程，单线程<br>优点：<br>⾼并发（最重要的优点）<br>缺点：<br>只⽀持单核 CPU ，不能充分利⽤ CPU<br>可靠性低，⼀旦代码某个环节崩溃，整个系统都崩溃</p>
<h3 id="32-eval是做什么的"><a href="#32-eval是做什么的" class="headerlink" title="32 eval是做什么的"></a>32 eval是做什么的</h3><p>它的功能是把对应的字符串解析成 JS 代码并运⾏应该避免使⽤ eval ，不安全，⾮常耗性能（ 2 次，⼀次解析成 js 语句，⼀次执⾏）</p>
<p>由 JSON 字符串转换为JSON对象的时候可以⽤ eval</p>
<p>var obj =eval(‘(‘+ str +’)’);<br>var obj = str.parseJSON();<br>var obj = JSON.parse(str);</p>
<p>JSON 对象转换为JSON字符串</p>
<p>var last=obj.toJSONString();<br>var last=JSON.stringify(obj);</p>
<h3 id="33-同步和异步的区别"><a href="#33-同步和异步的区别" class="headerlink" title="33 同步和异步的区别"></a>33 同步和异步的区别</h3><p>同步：浏览器访问服务器请求，⽤户看得到⻚⾯刷新，重新发请求,等请求完，⻚⾯刷新，新内容出现，⽤户看到新内容,进⾏下⼀步操作<br>异步：浏览器访问服务器请求，⽤户正常操作，浏览器后端进⾏请求。等请求完，⻚⾯不刷新，新内容也会出现，⽤户看到新内容</p>
<h3 id="34-说说严格模式的限制"><a href="#34-说说严格模式的限制" class="headerlink" title="34 说说严格模式的限制"></a>34 说说严格模式的限制</h3><p>变量必须声明后再使⽤<br>函数的参数不能有同名属性，否则报错<br>不能使⽤ with 语句<br>禁⽌ this 指向全局对象</p>
<h3 id="35-什么是⾯向对象编程及⾯向过程编程，它们的异同和优缺点"><a href="#35-什么是⾯向对象编程及⾯向过程编程，它们的异同和优缺点" class="headerlink" title="35 什么是⾯向对象编程及⾯向过程编程，它们的异同和优缺点"></a>35 什么是⾯向对象编程及⾯向过程编程，它们的异同和优缺点</h3><p>⾯向过程就是分析出解决问题所需要的步骤，然后⽤函数把这些步骤⼀步⼀步实现，使⽤的时候⼀个⼀个依次调⽤就可以了<br>⾯向对象是把构成问题事务分解成各个对象，建⽴对象的⽬的不是为了完成⼀个步骤，⽽是为了描叙某个事物在整个解决问题的步骤中的⾏为<br>⾯向对象是以功能来划分问题，⽽不是步骤</p>
<h3 id="37-谈⼀谈箭头函数与普通函数的区别？"><a href="#37-谈⼀谈箭头函数与普通函数的区别？" class="headerlink" title="37 谈⼀谈箭头函数与普通函数的区别？"></a>37 谈⼀谈箭头函数与普通函数的区别？</h3><p>函数体内的 this 对象，就是定义时所在的对象，⽽不是使⽤时所在的对象<br>不可以当作构造函数，也就是说，不可以使⽤ new 命令，否则会抛出⼀个错误<br>不可以使⽤ arguments 对象，该对象在函数体内不存在。如果要⽤，可以⽤ Rest 参数代替<br>不可以使⽤ yield 命令，因此箭头函数不能⽤作 Generator 函数</p>
<h3 id="38JS动画与CSS动画区别及相应实现"><a href="#38JS动画与CSS动画区别及相应实现" class="headerlink" title="38JS动画与CSS动画区别及相应实现"></a>38JS动画与CSS动画区别及相应实现</h3><p>CSS3 的动画的优点:<br>在性能上会稍微好⼀些，浏览器会对 CSS3 的动画做⼀些优化<br>代码相对简单<br>缺点:<br>在动画控制上不够灵活<br>兼容性不好<br>JavaScript 的动画正好弥补了这两个缺点，控制能⼒很强，可以单帧的控制、变换，同时写得好完全可以兼容 IE6 ，并且功能强⼤。对于⼀些复杂控制的动画，使⽤javascript 会⽐较靠谱。⽽在实现⼀些⼩的交互动效的时候，就多考虑考虑 CSS 吧</p>
<h3 id="39-gulp是什么"><a href="#39-gulp是什么" class="headerlink" title="39 gulp是什么"></a>39 gulp是什么</h3><p>gulp 是前端开发过程中⼀种基于流的代码构建⼯具，是⾃动化项⽬的构建利器；它不仅能对⽹站资源进⾏优化，⽽且在开发过程中很多重复的任务能够使⽤正确的⼯具⾃动完成<br>Gulp的特点：<br>易于使⽤：通过代码优于配置的策略，gulp 让简单的任务简单，复杂的任务可管理<br>构建快速: 利⽤ Node.js 流的威⼒，你可以快速构建项⽬并减少频繁的 IO 操作<br>易于学习</p>
<h3 id="41快速的让⼀个数组乱序"><a href="#41快速的让⼀个数组乱序" class="headerlink" title="41快速的让⼀个数组乱序"></a>41快速的让⼀个数组乱序</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1,2,3,4,5,6,7,8,9,10];arr.sort(function()&#123; return Math.random() - 0.5;&#125;)console.log(arr);</span><br></pre></td></tr></table></figure>

<h3 id="43希望获取到⻚⾯中所有的checkbox怎么做"><a href="#43希望获取到⻚⾯中所有的checkbox怎么做" class="headerlink" title="43希望获取到⻚⾯中所有的checkbox怎么做"></a>43希望获取到⻚⾯中所有的checkbox怎么做</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var domList &#x3D; document.getElementsByTagName(‘input’)var checkBoxList &#x3D; [];var len &#x3D; domList.length; &#x2F;&#x2F;缓存到局部变量while (len--) &#123; &#x2F;&#x2F;使⽤while的效率会⽐for循环更⾼    if (domList[len].type &#x3D;&#x3D; ‘checkbox’) &#123;    	checkBoxList.push(domList[len]);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="44Javascript中callee和caller的作⽤？"><a href="#44Javascript中callee和caller的作⽤？" class="headerlink" title="44Javascript中callee和caller的作⽤？"></a>44Javascript中callee和caller的作⽤？</h3><p>caller 是返回⼀个对函数的引⽤，该函数调⽤了当前函数；<br>callee 是返回正在被执⾏的 function 函数，也就是所指定的 function 对象的正⽂</p>
<h3 id="45-addEventListener-和attachEvent-的区别"><a href="#45-addEventListener-和attachEvent-的区别" class="headerlink" title="45 addEventListener()和attachEvent()的区别"></a>45 addEventListener()和attachEvent()的区别</h3><p>addEventListener() 是符合W3C规范的标准⽅法; attachEvent() 是IE低版本的⾮标准⽅法<br>addEventListener() ⽀持事件冒泡和事件捕获; ⽽ attachEvent() 只⽀持事件冒泡<br>addEventListener() 的第⼀个参数中,事件类型不需要添加 on ; attachEvent() 需要添加 ‘on’<br>如果为同⼀个元素绑定多个事件, addEventListener() 会按照事件绑定的顺序依次执⾏,attachEvent() 会按照事件绑定的顺序倒序执⾏</p>
<h3 id="47-Javascript全局函数和全局变量"><a href="#47-Javascript全局函数和全局变量" class="headerlink" title="47 Javascript全局函数和全局变量"></a>47 Javascript全局函数和全局变量</h3><p>全局变量<br>Infinity 代表正的⽆穷⼤的数值。<br>NaN 指示某个值是不是数字值。<br>undefined 指示未定义的值。<br>全局函数</p>
<p>个人记忆方法：6（编码相关）+ 2（数据处理）+ 4（数字相关）+ 1（特殊） </p>
<p>编码相关： </p>
<p>  escape()、unescape()、encodeURI()、decodeURI()、 </p>
<p>  encodeURIComponent()、decodeURIComponent() </p>
<p>数据处理： </p>
<p>  Number()、String() </p>
<p>数字相关： </p>
<p>  isFinite()、isNaN()、parseFloat()、parseInt() </p>
<p>特殊： </p>
<p>  eval() </p>
<h3 id="48怎么判断两个对象相等？"><a href="#48怎么判断两个对象相等？" class="headerlink" title="48怎么判断两个对象相等？"></a>48怎么判断两个对象相等？</h3><p>JSON.stringify(obj)==JSON.stringify(obj2);//true</p>
<h3 id="50-深浅拷⻉"><a href="#50-深浅拷⻉" class="headerlink" title="50 深浅拷⻉"></a>50 深浅拷⻉</h3><p>浅拷⻉<br>Object.assign 或者 展开运算符<br>深拷⻉<br>可以通过 JSON.parse(JSON.stringify(object)) 来解决，该⽅法也是有局限性的，会忽略 undefined</p>
<p>但是该⽅法也是有局限性的：<br>会忽略 undefined<br>会忽略 symbol<br>不能序列化函数<br>不能解决循环引⽤的对象</p>
<h3 id="51-防抖-节流"><a href="#51-防抖-节流" class="headerlink" title="51 防抖/节流"></a>51 防抖/节流</h3><p>防抖动是将多次执⾏变为最后⼀次执⾏，节流是将多次执⾏变成每隔⼀段时间执⾏</p>
<h3 id="52变量提升"><a href="#52变量提升" class="headerlink" title="52变量提升"></a>52变量提升</h3><p>在⽣成执⾏环境时，会有两个阶段。第⼀个阶段是创建的阶段，JS 解释器会找出需要提升的变量和函数，并且给他们提前在内存中开辟好空间，函数的话会将整个函数存⼊内存中，变量只声明并且赋值为 undefined ，所以在第⼆个阶段，也就是代码执⾏阶段，我们可以直接提前使⽤在提升的过程中，相同的函数会覆盖上⼀个函数，并且函数优先于变量提升</p>
<h3 id="53请简单实现双向数据绑定-mvvm"><a href="#53请简单实现双向数据绑定-mvvm" class="headerlink" title="53请简单实现双向数据绑定 mvvm"></a>53请简单实现双向数据绑定 mvvm</h3><h3 id="63编写⼀个⽅法-求⼀个字符串的字节⻓度，假设：⼀个英⽂字符占⽤⼀个字节，⼀个中⽂字符占⽤两个字节"><a href="#63编写⼀个⽅法-求⼀个字符串的字节⻓度，假设：⼀个英⽂字符占⽤⼀个字节，⼀个中⽂字符占⽤两个字节" class="headerlink" title="63编写⼀个⽅法 求⼀个字符串的字节⻓度，假设：⼀个英⽂字符占⽤⼀个字节，⼀个中⽂字符占⽤两个字节"></a>63编写⼀个⽅法 求⼀个字符串的字节⻓度，假设：⼀个英⽂字符占⽤⼀个字节，⼀个中⽂字符占⽤两个字节</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function GetBytes(str)&#123;    var len &#x3D; str.length;    var bytes &#x3D; len;    for(var i&#x3D;0; i&lt;len; i++)&#123;    	if (str.charCodeAt(i) &gt; 255) bytes++;    &#125;    return bytes;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="64bind的⽤法，以及如何实现bind的函数和需要注意的点"><a href="#64bind的⽤法，以及如何实现bind的函数和需要注意的点" class="headerlink" title="64bind的⽤法，以及如何实现bind的函数和需要注意的点"></a>64bind的⽤法，以及如何实现bind的函数和需要注意的点</h3><p>bind 的作⽤与 call 和 apply 相同，区别是 call 和 apply 是⽴即调⽤函数，⽽bind 是返回了⼀个函数，需要调⽤的时候再执⾏。 ⼀个简单的 bind 函数实现如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.bind &#x3D; function(ctx) &#123;    var fn &#x3D; this;    return function() &#123;    	fn.apply(ctx, arguments);    &#125;;&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="67-定义⼀个log⽅法，让它可以代理console-log的⽅法"><a href="#67-定义⼀个log⽅法，让它可以代理console-log的⽅法" class="headerlink" title="67 定义⼀个log⽅法，让它可以代理console.log的⽅法"></a>67 定义⼀个log⽅法，让它可以代理console.log的⽅法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;可⾏的⽅法⼀：function log(msg) &#123;	console.log(msg);&#125;log(&quot;hello world!&quot;) &#x2F;&#x2F; hello world!&#x2F;&#x2F;如果要传⼊多个参数呢？显然上⾯的⽅法不能满⾜要求，所以更好的⽅法是：function log()&#123;	console.log.apply(console, arguments);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="70写⼀个-function-，清除字符串前后的空格"><a href="#70写⼀个-function-，清除字符串前后的空格" class="headerlink" title="70写⼀个 function ，清除字符串前后的空格"></a>70写⼀个 function ，清除字符串前后的空格</h3><p>使⽤⾃带接trim() ，考虑兼容性：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if (!String.prototype.trim) &#123;    String.prototype.trim &#x3D; function() &#123;    	return this.replace(&#x2F;^\s+&#x2F;, &quot;&quot;).replace(&#x2F;\s+$&#x2F;,&quot;&quot;);    &#125;&#125;var str &#x3D; &quot; \t\n test string &quot;.trim();alert(str &#x3D;&#x3D; &quot;test string&quot;); &#x2F;&#x2F; alerts &quot;true&quot;</span><br></pre></td></tr></table></figure>

<h3 id="71实现每隔⼀秒钟输出1-2-3…数字"><a href="#71实现每隔⼀秒钟输出1-2-3…数字" class="headerlink" title="71实现每隔⼀秒钟输出1,2,3…数字"></a>71实现每隔⼀秒钟输出1,2,3…数字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for(var i&#x3D;0;i&lt;10;i++)&#123;    (function(j)&#123;        setTimeout(function()&#123;        	console.log(i+1)        &#125;,i*1000)    &#125;)(i)&#125;</span><br></pre></td></tr></table></figure>

<h3 id="72实现⼀个函数，判断输⼊是不是回⽂字符串"><a href="#72实现⼀个函数，判断输⼊是不是回⽂字符串" class="headerlink" title="72实现⼀个函数，判断输⼊是不是回⽂字符串"></a>72实现⼀个函数，判断输⼊是不是回⽂字符串</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function run(input) &#123;    if (typeof input !&#x3D;&#x3D; &#39;string&#39;) return false;    return input.split(&#39;&#39;).reverse().join(&#39;&#39;) &#x3D;&#x3D;&#x3D; input;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="74负载均衡"><a href="#74负载均衡" class="headerlink" title="74负载均衡"></a>74负载均衡</h3><p>多台服务器共同协作，不让其中某⼀台或⼏台超额⼯作，发挥服务器的最⼤作⽤<br>http 重定向负载均衡：调度者根据策略选择服务器以302响应请求，缺点只有第⼀次有效果，后续操作维持在该服务器 dns负载均衡：解析域名时，访问多个 ip 服务器中的⼀个（可监控性较弱）<br>反向代理负载均衡：访问统⼀的服务器，由服务器进⾏调度访问实际的某个服务器，对统⼀的服务器要求⼤，性能受到服务器群的数量</p>
<h3 id="75CDN"><a href="#75CDN" class="headerlink" title="75CDN"></a>75CDN</h3><p>内容分发⽹络，基本思路是尽可能避开互联⽹上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。</p>
<h3 id="78前后端路由差别"><a href="#78前后端路由差别" class="headerlink" title="78前后端路由差别"></a>78前后端路由差别</h3><p>后端每次路由请求都是重新访问服务器<br>前端路由实际上只是 JS 根据 URL 来操作 DOM 元素，根据每个⻚⾯需要的去服务端请求数据，返回数据后和模板进⾏组合</p>
<h3 id="79谈谈你对重构的理解"><a href="#79谈谈你对重构的理解" class="headerlink" title="79谈谈你对重构的理解"></a>79谈谈你对重构的理解</h3><p>⽹站重构：在不改变外部⾏为的前提下，简化结构、添加可读性，⽽在⽹站前端保持⼀致的⾏为。也就是说是在不改变UI的情况下，对⽹站进⾏优化， 在扩展的同时保持⼀致的UI<br>对于传统的⽹站来说重构通常是：<br>表格( table )布局改为 DIV+CSS<br>使⽹站前端兼容于现代浏览器(针对于不合规范的 CSS 、如对IE6有效的)<br>对于移动平台的优化<br>针对于 SEO 进⾏优化</p>
<h3 id="80什么样的前端代码是好的"><a href="#80什么样的前端代码是好的" class="headerlink" title="80什么样的前端代码是好的"></a>80什么样的前端代码是好的</h3><p>⾼复⽤低耦合，这样⽂件⼩，好维护，⽽且好扩展。<br>具有可⽤性、健壮性、可靠性、宽容性等特点</p>
<h3 id="87-gt-true"><a href="#87-gt-true" class="headerlink" title="87 [] == ![] // -&gt; true"></a>87 [] == ![] // -&gt; true</h3><p>// [] 转成 true，然后取反变成 false<br>[] == false<br>[] == ToNumber(false)<br>[] == 0<br>ToPrimitive([]) == 0<br>// [].toString() -&gt; ‘’<br>‘’ == 0<br>0 == 0 // -&gt; true</p>
<h3 id="89什么是事件代理"><a href="#89什么是事件代理" class="headerlink" title="89什么是事件代理"></a>89什么是事件代理</h3><p>如果⼀个节点中的⼦节点是动态⽣成的，那么⼦节点需要注册事件的话应该注册在⽗节点上</p>
<p>事件代理的⽅式相对于直接给⽬标注册事件来说，有以下优点<br>节省内存<br>不需要给⼦节点注销事件</p>
<h3 id="91很多⼈不知道的是，重绘和回流其实和-Event-loop-有关。"><a href="#91很多⼈不知道的是，重绘和回流其实和-Event-loop-有关。" class="headerlink" title="91很多⼈不知道的是，重绘和回流其实和 Event loop 有关。"></a>91很多⼈不知道的是，重绘和回流其实和 Event loop 有关。</h3><p>当 Event loop 执⾏完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新⼀次。然后判断是否有 resize 或者 scroll ，有的话会去触发事件，所以 resize 和scroll 事件也是⾄少 16ms 才会触发⼀次，并且⾃带节流功能。<br>判断是否触发了 media query<br>更新动画并且发送事件<br>判断是否有全屏操作事件<br>执⾏ requestAnimationFrame 回调<br>执⾏ IntersectionObserver 回调，该⽅法⽤于判断元素是否可⻅，可以⽤于懒加载上，但是兼容性不好<br>更新界⾯<br>以上就是⼀帧中可能会做的事情。如果在⼀帧中有空闲时间，就会去执⾏requestIdleCallback 回调</p>
<h3 id="92’a’-‘b’-gt-“aNaN”"><a href="#92’a’-‘b’-gt-“aNaN”" class="headerlink" title="92’a’ + + ‘b’ // -&gt; “aNaN”"></a>92’a’ + + ‘b’ // -&gt; “aNaN”</h3><p>+’b’      NaN</p>
<h3 id="97-预加载"><a href="#97-预加载" class="headerlink" title="97 预加载"></a>97 预加载</h3><p>在开发中，可能会遇到这样的情况。有些资源不需要⻢上⽤到，但是希望尽早获取，这时候就可以使⽤预加载<br>预加载其实是声明式的 fetch ，强制浏览器请求资源，并且不会阻塞 onload 事件<br>预加载可以⼀定程度上降低⾸屏的加载时间，因为可以将⼀些不影响⾸屏但重要的⽂件延后加载，唯⼀缺点就是兼容性不好</p>
<h3 id="98预渲染"><a href="#98预渲染" class="headerlink" title="98预渲染"></a>98预渲染</h3><p>可以通过预渲染将下载的⽂件预先在后台渲染，可以使⽤以下代码开启预渲染<br>预渲染虽然可以提⾼⻚⾯的加载速度，但是要确保该⻚⾯百分百会被⽤户在之后打开，否则就⽩⽩浪费资源去渲染</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel &#x3D; &quot;prerender&quot; href &#x3D; &quot;http:&#x2F;&#x2F;poetries.com&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<h3 id="99懒执⾏与懒加载"><a href="#99懒执⾏与懒加载" class="headerlink" title="99懒执⾏与懒加载"></a>99懒执⾏与懒加载</h3><p>懒执⾏就是将某些逻辑延迟到使⽤时再计算。该技术可以⽤于⾸屏优化，对于某些耗时逻辑并不需要在⾸屏就使⽤的，就可以使⽤懒执⾏。懒执⾏需要唤醒，⼀般可以通过定时器或者事件的调⽤来唤醒<br>懒加载<br>懒加载就是将不关键的资源延后加载<br>懒加载的原理就是只加载⾃定义区域（通常是可视区域，但也可以是即将进⼊可视区域）内需要加载的东⻄。对于图⽚来说，先设置图⽚标签的 src 属性为⼀张占位图，将真实的图⽚资源放⼊⼀个⾃定义属性中，当进⼊⾃定义区域时，就将⾃定义属性替换为 src 属性，这样图⽚就会去下载资源，实现了图⽚懒加载<br>懒加载不仅可以⽤于图⽚，也可以使⽤在别的资源上。⽐如进⼊可视区域才开始播放视频等</p>
<h3 id="102密码安全"><a href="#102密码安全" class="headerlink" title="102密码安全"></a>102密码安全</h3><p>加盐<br>对于密码存储来说，必然是不能明⽂存储在数据库中的，否则⼀旦数据库泄露，会对⽤户造成很⼤的损失。并且不建议只对密码单纯通过加密算法加密，因为存在彩虹表的关系<br>通常需要对密码加盐，然后进⾏⼏次不同加密算法的加密<br>但是加盐并不能阻⽌别⼈盗取账号，只能确保即使数据库泄露，也不会暴露⽤户的真实密码。⼀旦攻击者得到了⽤户的账号，可以通过暴⼒破解的⽅式破解密码。对于这种情况，通常使⽤验证码增加延时或者限制尝试次数的⽅式。<br>加盐也就是给原密码添加字符串，增加原密码⻓度sha256(sha1(md5(salt + password + salt)))</p>
<p>且⼀旦⽤户输⼊了错误的密码，也不能直接提示⽤户输错密码，⽽应该提示账号或密码错误<br>前端加密<br>虽然前端加密对于安全防护来说意义不⼤，但是在遇到中间⼈攻击的情况下，可以避免明⽂密码被第三⽅获取</p>
<h3 id="103this-对象的理解"><a href="#103this-对象的理解" class="headerlink" title="103this 对象的理解"></a>103this 对象的理解</h3><p> 普通函数</p>
<p>this 总是指向函数的直接调用者</p>
<p>如果有 new 关键字，this 指向 new 出来的实例对象</p>
<p>在事件中，this 指向触发这个事件的对象</p>
<p>IE 下 attachEvent 中的 this 总是指向全局对象 Window</p>
<p>箭头函数中，函数体内的this对象，就是定义时所在作用域的对象，而不是使用时所在的作用域的对象。</p>
<h3 id="104如何派发事件"><a href="#104如何派发事件" class="headerlink" title="104如何派发事件"></a>104如何派发事件</h3><blockquote>
<p>(dispatchEvent)（如何进行事件广播？）</p>
</blockquote>
<p>W3C: 使用 dispatchEvent 方法</p>
<p>IE: 用 fireEvent 方法</p>
<h3 id="105运行机制"><a href="#105运行机制" class="headerlink" title="105运行机制"></a>105运行机制</h3><ol>
<li><p>在执行栈中执行一个宏任务。 </p>
</li>
<li><p>执行过程中遇到微任务，将微任务添加到微任务队列中。</p>
</li>
<li><p>当前宏任务执行完毕，立即执行微任务队列中的任务。 </p>
</li>
<li><p>当前微任务队列中的任务执行完毕，检查渲染，GUI线程接管渲染。 </p>
</li>
<li><p>渲染完毕后，js线程接管，开启下一次事件循环，执行下一次宏任务（事件队列中取）。</p>
</li>
</ol>
<p><strong>微任务</strong>：process.nextTick、MutationObserver、Promise.then catch finally</p>
<p><strong>宏任务：</strong>I/O、setTimeout、setInterval、setImmediate、requestAnimationFrame</p>
<h3 id="109实现简单promise"><a href="#109实现简单promise" class="headerlink" title="109实现简单promise"></a>109实现简单promise</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 三个常量用于表示状态const PENDING &#x3D; &#39;pending&#39;const RESOLVED &#x3D; &#39;resolved&#39;const REJECTED &#x3D; &#39;rejected&#39;function MyPromise(fn) &#123;  const that &#x3D; this  this.state &#x3D; PENDING  &#x2F;&#x2F; value 变量用于保存 resolve 或者 reject 中传入的值  this.value &#x3D; null  &#x2F;&#x2F; 用于保存 then 中的回调，因为当执行完 Promise 时状态可能还是等待中，这时候应该把 then 中的回调保存起来用于状态改变时使用  that.resolvedCallbacks &#x3D; []  that.rejectedCallbacks &#x3D; []  function resolve(value) &#123;    &#x2F;&#x2F; 首先两个函数都得判断当前状态是否为等待中    if(that.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      that.state &#x3D; RESOLVED      that.value &#x3D; value      &#x2F;&#x2F; 遍历回调数组并执行      that.resolvedCallbacks.map(cb&#x3D;&gt;cb(that.value))    &#125;  &#125;  function reject(value) &#123;    if(that.state &#x3D;&#x3D;&#x3D; PENDING) &#123;      that.state &#x3D; REJECTED      that.value &#x3D; value      that.rejectedCallbacks.map(cb&#x3D;&gt;cb(that.value))    &#125;  &#125;  &#x2F;&#x2F; 完成以上两个函数以后，我们就该实现如何执行 Promise 中传入的函数了  try &#123;    fn(resolve,reject)  &#125;catch(e)&#123;    reject(e)  &#125;&#125;&#x2F;&#x2F; 最后我们来实现较为复杂的 then 函数MyPromise.prototype.then &#x3D; function(onFulfilled,onRejected)&#123;  const that &#x3D; this  &#x2F;&#x2F; 判断两个参数是否为函数类型，因为这两个参数是可选参数  onFulfilled &#x3D; typeof onFulfilled &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onFulfilled : v&#x3D;&gt;v;  onRejected &#x3D; typeof onRejected &#x3D;&#x3D;&#x3D; &#39;function&#39; ? onRejected : (e)&#x3D;&gt; &#123; throw e &#125;;  &#x2F;&#x2F; 当状态不是等待态时，就去执行相对应的函数。如果状态是等待态的话，就往回调函数中 push 函数  if(this.state &#x3D;&#x3D;&#x3D; PENDING) &#123;    this.resolvedCallbacks.push(onFulfilled)    this.rejectedCallbacks.push(onRejected)  &#125;  if(this.state &#x3D;&#x3D;&#x3D; RESOLVED) &#123;    onFulfilled(that.value)  &#125;  if(this.state &#x3D;&#x3D;&#x3D; REJECTED) &#123;    onRejected(that.value)  &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;使用let promise&#x3D;new MyPromise((resolve,reject)&#x3D;&gt;&#123;  &#x2F;&#x2F;请求成功  let res&#x3D;&#39;dddd&#39;;  if(true)&#123;    resolve(res)  &#125;else &#123;    reject()  &#125;&#125;);promise.then(res&#x3D;&gt;&#123;  console.log(res)   &#x2F;&#x2F;ddd&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="114-instanceof的原理"><a href="#114-instanceof的原理" class="headerlink" title="114. instanceof的原理"></a>114. instanceof的原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 思路：右边变量的原型存在于左边变量的原型链上function instanceOf(left, right) &#123;  let leftValue &#x3D; left.__proto__  let rightValue &#x3D; right.prototype  while (true) &#123;    if (leftValue &#x3D;&#x3D;&#x3D; null) &#123;      return false    &#125;    if (leftValue &#x3D;&#x3D;&#x3D; rightValue) &#123;      return true    &#125;    leftValue &#x3D; leftValue.__proto__  &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="115-Object-create的基本实现原理"><a href="#115-Object-create的基本实现原理" class="headerlink" title="115. Object.create的基本实现原理"></a>115. Object.create的基本实现原理</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 传入的对象的原型function create(obj) &#123;  function F() &#123;&#125;  F.prototype &#x3D; obj  return new F()&#125;</span><br></pre></td></tr></table></figure>

<h2 id="123-实现一个双向数据绑定（看es6）"><a href="#123-实现一个双向数据绑定（看es6）" class="headerlink" title="123. 实现一个双向数据绑定（看es6）"></a>123. 实现一个双向数据绑定（看es6）</h2><h3 id="133"><a href="#133" class="headerlink" title="133"></a>133</h3><p>当按百分比设定一个元素的高度时，它是相对于父容器的高度计算的。但是，对于一些表示竖向距离的属性，例如 padding-top , padding-bottom , margin-top , margin-bottom 等，当按百分比设定它们时，依据的是父容器的宽度，而不是高度。</p>
<h3 id="135你对line-height是如何理解的"><a href="#135你对line-height是如何理解的" class="headerlink" title="135你对line-height是如何理解的"></a>135你对line-height是如何理解的</h3><p>行高是指一行文字的高度，具体说是两行文字间基线的距离。CSS中起高度作用的是height和line-height，没有定义height属性，最终其表现作用一定是line-height。<br>单行文本垂直居中：把line-height值设置为height一样大小的值可以实现单行文字的垂直居中，其实也可以把height删除。<br>多行文本垂直居中：需要设置display属性为inline-block。</p>
<h3 id="137如果需要手动写动画，你认为最小时间间隔是多久"><a href="#137如果需要手动写动画，你认为最小时间间隔是多久" class="headerlink" title="137如果需要手动写动画，你认为最小时间间隔是多久"></a>137如果需要手动写动画，你认为最小时间间隔是多久</h3><p>多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms</p>
<h3 id="139position跟display、overflow、float这些特性相互叠加后会怎么样？"><a href="#139position跟display、overflow、float这些特性相互叠加后会怎么样？" class="headerlink" title="139position跟display、overflow、float这些特性相互叠加后会怎么样？"></a>139position跟display、overflow、float这些特性相互叠加后会怎么样？</h3><p>display属性规定元素应该生成的框的类型；position属性规定元素的定位类型；float属性是一种布局方式，定义元素在哪个方向浮动。</p>
<p>类似于优先级机制：position：absolute/fixed优先级最高，有他们在时，float不起作用，display值需要调整。float 或者absolute定位的元素，只能是块元素或表格。</p>
<h3 id="141-CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？"><a href="#141-CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？" class="headerlink" title="141 CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？"></a>141 <strong>CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？</strong></h3><p>当一个元素的visibility属性被设置成collapse值后，对于一般的元素，它的表现跟hidden是一样的。</p>
<p>chrome中，使用collapse值和使用hidden没有区别。</p>
<p>firefox，opera和IE，使用collapse值和使用display：none没有什么区别。</p>
<h3 id="142全屏滚动的原理是什么？用到了CSS的哪些属性？"><a href="#142全屏滚动的原理是什么？用到了CSS的哪些属性？" class="headerlink" title="142全屏滚动的原理是什么？用到了CSS的哪些属性？"></a>142<strong>全屏滚动的原理是什么？用到了CSS的哪些属性？</strong></h3><p>原理：有点类似于轮播，整体的元素一直排列下去，假设有5个需要展示的全屏页面，那么高度是500%，只是展示100%，剩下的可以通过transform进行y轴定位，也可以通过margin-top实现</p>
<p>overflow：hidden；transition：all 1000ms ease；</p>
<h3 id="145关于浮动，以下是正确的说法："><a href="#145关于浮动，以下是正确的说法：" class="headerlink" title="145关于浮动，以下是正确的说法："></a>145关于浮动，以下是正确的说法：</h3><p>如果有非浮动元素和浮动元素同时存在，并且非浮动元素在前，则浮动元素不会高于非浮动元素；</p>
<p>行内元素与浮动元素发生重叠，边框、背景、内容都会显示在浮动元素之上；</p>
<p>块级元素与浮动元素发生重叠，边框、背景会显示在浮动元素之下，内容会显示在浮动元素之上</p>
<h3 id="146关于上面两行代码显示结果说法正确和错误的是"><a href="#146关于上面两行代码显示结果说法正确和错误的是" class="headerlink" title="146关于上面两行代码显示结果说法正确和错误的是"></a>146关于上面两行代码显示结果说法正确和错误的是</h3><p>&lt;input type=”date” name=”bday”&gt;<br> &lt;input type=”datetime-local” name=”bdaytime”&gt;<br> 两者都可以用来绘制日历；（对）</p>
<p> 后者可以显示本地时间，且时间可以修改；（对）    </p>
<h3 id="147以下哪些方法可以优化滚动性能？"><a href="#147以下哪些方法可以优化滚动性能？" class="headerlink" title="147以下哪些方法可以优化滚动性能？"></a>147以下哪些方法可以优化滚动性能？</h3><p> 在滚动中对滚动函数进行节流处理；</p>
<p> 滚动中减少导致重绘的操作；</p>
<p> 滚动中减少导致重排的操作；</p>
<p> 通过给滚动内的子元素开启硬件加速</p>
<h3 id="148如何使用-css-在标题元素-lt-h2-gt-前插入图像文件"><a href="#148如何使用-css-在标题元素-lt-h2-gt-前插入图像文件" class="headerlink" title="148如何使用 css 在标题元素&lt;h2&gt;前插入图像文件"></a>148如何使用 css 在标题元素&lt;h2&gt;前插入图像文件</h3><p>h2::before{content: url(…)}</p>
<h3 id="149Background-position属性"><a href="#149Background-position属性" class="headerlink" title="149Background-position属性"></a>149Background-position属性</h3><p>用处：配合background-image属性一起使用，用于设置背景图片在盒子中的位置</p>
<p>参数：xpos ypos |x% y% |x y三种,</p>
<p>如果只写第一个水平方向的参数，第二个垂直方向的参数会默认为：center|50%|容器高度的一半px</p>
<p>Xpos：规定水平方向的对齐方式,值有left,right,center</p>
<p>Ypos：规定垂直方向的对齐方式,值有top,bottom,center</p>
<p>x%:规定图片水平方向的距离。你会不会以为这个x%就是父级容器宽度的x%？那你就想错了哦，这里的x%指的是父级容器的宽度减去图片的宽度后的差值的x%。</p>
<p>举个栗子：background-position：50%，20%；</p>
<p>图片的宽度为   imgwidth：100px；高度为   imgheight：100px；</p>
<p>容器的宽度为   conwidth：200px；高度为   conheight：200px；</p>
<p>那么此时图片的左顶点距离容器的左顶点的水平距离就是(conwidth-imgwidth)<em>50%=50px,而不是conwidth</em>50%=100px；由此也可以算出图片的左顶点距离容器的左顶点的垂直距离为20px</p>
<h3 id="150"><a href="#150" class="headerlink" title="150"></a>150</h3><p>padding是边框和内容的分割，这部分必然是透明的，除非设置背景</p>
<p>margin也可以透明，也可以显示背景，它显示的背景是父元素的背景。而padding是显示当前元素的背景。</p>
<hr>
<p>vw:基于视口的宽度 vh:基于视口的高度，视口被均分成100个单位</p>
<p>vw：viewpoint width，视窗宽度，1vw等于视窗宽度的1%。</p>
<p>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</p>
<p>vmin：vw和vh中较小的那个。</p>
<p>vmax：vw和vh中较大的那个。</p>
<p>pt ：印刷业上常使用的单位，磅的意思，一般用于页面打印排版。</p>
<hr>
<p>a标签不能套a标签</p>
<p>有序列表的小写字母如果大于26项再次从 ‘aa’开始</p>
<hr>
<p>每个选择器最多只能出现一个伪元素，伪类的个数没有限制</p>
<hr>
<p>margin: top horizontal bottom /三值语法 上 横向 下/</p>
<p>举例： margin: 1em auto 2em;</p>
<h3 id="151"><a href="#151" class="headerlink" title="151"></a>151</h3><p>&lt;html lang=”en”&gt;</p>
<p>向搜索引擎表示该页面是html语言，并且语言为英文网站，而“en”即表示english</p>
<p>如果是中文页面，可将其改为&lt;html lang=”zh”&gt; ，zh即表示中文</p>
<html lang en">可以输出中文,只是会让你的浏览器提示你要不要翻译此页

<hr>
<p>通常我们需要获取某个信息时，都会通过几个缩写的关键字进行检索，那么，在开发中，如何使用HTML5元素进行布局&lt;abbr&gt;标签</p>
<p> The &lt;abbr title=”People’s Republic of China”&gt;PRC&lt;/abbr&gt; was founded in 1949.结果：The PRC was founded in 1949.<br> 鼠标在结果的PRC上时会显示People’s Republic of China</p>
<hr>
<p>在Blink和Webkit的浏览器中，某个元素具有3D或透视变换（perspective transform）的CSS属性，会让浏览器创建单独的图层。</p>
<p>我们平常会使用left和top属性来修改元素的位置，但left和top会触发重布局，取而代之的更好的方法是使用translate，这个不会触发重布局。</p>
<p>解决浏览器渲染的性能问题时，首要目标就是要避免层的重绘和重排。</p>
<p>滥用硬件加速会导致严重性能问题，因为它增加了内存使用，并且它会导致移动端电池寿命减少。</p>
<hr>
<p>关于web表单登录中用到的图形验证码的实现，发送到客户端的只有图片形式的验证码，服务器端保存cookie对应的图形验证码的正确</p>
<hr>
<p>在html代码段中，可使“Welcome”在浏览器中从左向右滚动显示的是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;&lt;body&gt;	&lt;marquee scrolldelay&#x3D;&quot;200&quot; direction&#x3D;&quot;right&quot;&gt;Welcome!&lt;&#x2F;marquee&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p> a元素可以不使用href这个属性，此时为超链接的一个占位符；</p>
<hr>
<p>在使用table表现数据时，有时候表现出来的会比自己实际设置的宽度要宽，为此需要设置哪些属性</p>
<p> （多）cellpadding=”0”  cellspacing=”0”</p>
<p>单元格边距(表格填充)(cellpadding) – 代表表格边框与单元格补白的距离,也是单元格补白之间的距离。</p>
<p>单元格间距(表格间距)(cellspacing) – 代表单元格外面的一个距离,用于隔开单元格与单元格空间；</p>
<hr>
<p>MVC是一种常见的架构。描述正确的时：React</p>
<p>模型变更之后，只有控制器（Controller）才能驱动视图变更或重新渲染视图。</p>
<p>任何系统都可以使用MVC的设计理念； </p>
<p>模型层里面放的是业务逻辑，视图层有很多表现形式。</p>
<p>React属于MVC框架，是V层，单项数据绑定，可以设置为双向数据绑定</p>
<hr>
<p>关于跨域的描述正确的是：</p>
<p>CSS文件的加载不受跨域的影响；图片等资源文件加载可以跨域，src本质是get请求，但文字就不一定了，有的是不允许跨域请求的。</p>
<p> ‘window.onerror’方法默认情况下无法获取跨域脚本的报错详情；</p>
<p> canvas中使用drawimage贴图会受跨域的影响，解决方案1：如果图片不大不多可以使用base64，解决方案2：实例的image对象的设置img.crossOrigin = &apos; &apos;;并且在服务器端设置Access-Control-Allow-Origin:*(或运行的域名)；</p>
<hr>
<p> &lt;a id=”yes”&gt;我可以&lt;/a&gt;    不可以，a标签没有设置href属性时不能获取到焦点</p>
<p>&lt;a id=”yes” href=”#”&gt;我可以&lt;/a&gt;  这样便可以了。<br> tabindex：0 或-1 或x<br> 0：tab键可获取焦点；<br> -1：tab键不可获取焦点；<br>  x：x&gt;0，x越小获取焦点优先级越高；</p>
<hr>
<p>对于iframe的说法，正确的是：</p>
<p>iframe是用来在网页中插入第三方页面</p>
<p>Iframe的创建比一般的DOM元素慢了1-2个数量级；</p>
<p> Iframe标签会阻塞页面的加载；</p>
<p>局限：<br> 1、创建比一般的 DOM 元素慢了 1-2 个数量级<br> iframe 的创建比其它包括 scripts 和 css 的 DOM 元素的创建慢了 1-2 个数量级，使用 iframe 的页面一般不会包含太多 iframe，所以创建 DOM 节点所花费的时间不会占很大的比重。但带来一些其它的问题：onload 事件以及连接池（connection pool）<br> 2、阻塞页面加载<br> 及时触发 window 的 onload 事件是非常重要的。onload 事件触发使浏览器的 “忙” 指示器停止，告诉用户当前网页已经加载完毕。当 onload 事件加载延迟后，它给用户的感觉就是这个网页非常慢。window 的 onload 事件需要在所有 iframe 加载完毕后（包含里面的元素）才会触发。在 Safari 和 Chrome 里，通过 JavaScript 动态设置 iframe 的 SRC 可以避免这种阻塞情况<br> 3、唯一的连接池<br> 浏览器只能开少量的连接到 web 服务器。比较老的浏览器，包含 Internet Explorer 6 &amp; 7 和 Firefox 2，只能对一个域名（hostname）同时打开两个连接。这个数量的限制在新版本的浏览器中有所提高。Safari 3+ 和 Opera 9+ 可同时对一个域名打开 4 个连接，Chrome 1+, IE 8 以及 Firefox 3 可以同时打开 6 个绝大部分浏览器，主页面和其中的 iframe 是共享这些连接的。这意味着 iframe 在加载资源时可能用光了所有的可用连接，从而阻塞了主页面资源的加载。如果 iframe 中的内容比主页面的内容更重要，这当然是很好的。但通常情况下，iframe 里的内容是没有主页面的内容重要的。这时 iframe 中用光了可用的连接就是不值得的了。一种解决办法是，在主页面上重要的元素加载完毕后，再动态设置 iframe 的 SRC。<br> 4、不利于 SEO<br> 搜索引擎的检索程序无法解读 iframe。另外，iframe 本身不是动态语言，样式和脚本都需要额外导入。</p>
<hr>
<p>onchange 是失去焦点且内容改变才会执行函数，如果内容不变则不执行；<br>onblur 不论内容是否改变,只要失去焦点,就会执行函数；</p>
<hr>
<p>DHTML具备的三个主要优点是：</p>
<p>​    （多）动态样式、动态内容、动态定位</p>
<p>DHTML是Dynamic HTML的简称，就是动态的HTML(标准通用标记语言下的一个应用)，是相对传统的静态的html而言的一种制作网页的概念。<br>DHTML 将 HTML、JavaScript、DOM 以及 CSS 组合在一起，用于创造动态性更强的网页。通过 JavaScript 和 HTML DOM，能够动态地改变 HTML 元素的样式。</p>
<p>DHTML实现了网页从Web服务器下载后无需再经过服务的处理，而在浏览器中直接动态地更新网页的内容、排版样式和动画的功能。</p>
<p>html+css+javascript（或其他脚本）的优点：html确定页面框架，css和脚本决定页面样式、动态内容和动态定位。</p>
<p>DHTML 的动态样式的作用是：使网页作者改变内容的外部特征而不强调用户再次下载全部内容</p>
<p>动态内容(Dynamic Content)：动态地更新网页内容，可“动态”地插入、修改或删除网页的元件，如文字、图像、标记等。 </p>
<hr>
<p>关于页面加载过程，描述正确的是：</p>
<p>由于html的层次结构已经是树状结构，因此可以实现边加载边生成DOM树；</p>
<p>页面所有资源加载完毕后，会触发onload事件；</p>
<p>css加载不会阻塞DOM树的解析 ；<br>css加载会阻塞DOM树的渲染 ；<br>css加载会阻塞后面js语句的执行</p>
<hr>
<p> 关于XML、JSON、HTML5的描述：</p>
<p> JSON比XML在数据编码上更具有效率，更节约时间，数据的体积小，传递的速度更快些；</p>
<p> JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互；（对）</p>
<p> XML对数据的类型描述表达比JSON更丰富；（对）</p>
<p> 存在一些数据库，直接支持XML或JSON数据的操作，如mongodb,postgresql;（对）</p>
<p> HTML5是一种特殊的XML;（错）</p>
<p> HTML5在跨系统交互面是一种理性的交换格式；（错）</p>
<p> XML比JSON更能表达结构化数据；（错）</p>
<hr>
<p>对象无初始值或者其值为 0、-0、null、””、false、undefined 或者 NaN，那么对象的值为 false；除了上面几个，它值都为 true（即使值为字符串 “false” ）</p>
<p>console.log(({}==false)?true:false); // =&gt; console.log((NaN==0)?true:false);</p>
<p>布尔类型与其它任何类型进行比较，布尔类型将会转换为number类型。</p>
<p>Number转换类型的参数如果为对象返回的就是NaN,</p>
<p>那么Number({})返回的就是NaN</p>
<p>下面几个都会转化为0：</p>
<p>Number()</p>
<p>Number(‘’)</p>
<p>Number([])</p>
<p>Number(0)</p>
<p>Number(‘0’)</p>
<p>Number([0])</p>
<p>Number(false)</p>
<p>Number(null)</p>
<hr>
<p>放在HTML里的哪一部分JavaScript会在页面加载的时候被执行？</p>
<p>​    （单）&lt;body&gt;标签部分</p>
<p>在HTML body部分中的JavaScripts会在页面加载的时候被执行。放在body部分的脚本通常被用来生成页面的内容。<br>在HTML head部分中的JavaScripts会在被调用的时候才执行。把脚本放在head部分中时，可以保证脚本在任何调用之前被加载。<br>之所以把js放在body之后，是为了预防外部js文件过多时，浏览器呈现页面出现延迟，延迟期间浏览器的窗口一片空白。 </p>
<hr>
<p>拖放是HTML5标准的组成部分，若想要把drag1图片放入div1块中，拖放方法如下： </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function allowDrop(ev)&#123; 	ev.preventDefault();&#125;function drag(ev)&#123; 	ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id);&#125;function drop(ev)&#123;     ev.preventDefault();    var data&#x3D;ev.dataTransfer.getData(&quot;Text&quot;);    ev.target.appendChild(document.getElementById(data));&#125; 则，如下HTML代码正确的是（）&lt;div id&#x3D;&quot;div1&quot; ondrop&#x3D;&quot;drop(event)&quot; ondragover&#x3D;&quot;allowDrop(event)&quot;&gt;&lt;&#x2F;div&gt; &lt;img id&#x3D;&quot;drag1&quot; src&#x3D;&quot;img_logo.png&quot; draggable&#x3D;&quot;true&quot; ondragstart&#x3D;&quot;drag(event)&quot; width&#x3D;&quot;336&quot; height&#x3D;&quot;69&quot;&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>创建带有id属性的DOM元素有什么副作用？</p>
<p>​    （单）会创建同名的全局变量；</p>
<p>如果一个元素拥有ID属性,那么ID属性的属性值就会成为window对象的属性名.</p>
<hr>
<p>html5新增了manifest标签，他有什么作用？</p>
<p>​    （单）应用缓存资源清单</p>
<p>manifest 文件是一个简单的文本文件，列举出了浏览器用于离线访问而缓存的资源。</p>
<hr>
<p>哪个元素定义了&lt;object&gt;元素的参数？</p>
<p>​    （单）&lt;param&gt;</p>
<p>param用来为object或applet元素定义的对象或小程序进行初始化参数设置</p>
<hr>
<p>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。<br>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。</p>
<p>在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
<hr>
<p> 一个页面title元素只能有一个；</p>
<p> 一个页面main元素只能有一个（多个，其他隐藏也可以），因为&lt;main&gt; 标签规定文档的主要内容，&lt;main&gt; 元素不能是以下元素的后代：&lt;article&gt;、&lt;aside&gt;、&lt;footer&gt;、&lt;header&gt; 或 &lt;nav&gt;。</p>
<p>在html5中，哪个元素用于组合标题元素？&lt;hgroup&gt;</p>
<p>hgroup元素是将标题及其子标题进行分组的元素，hgroup元素通常会将h1-h6元素进行分组，比如内容区块的标题及其子元素算一组</p>
<hr>
<p>关于Canvas和SVG图形的区别</p>
<p>Canvas</p>
<p>Canvas是通过JavaScript的API进行绘图的<br>依赖分辨率</p>
<p>不支持事件处理器，不能使用绘制对象的相关事件处理，因为我们没有他们的参考（<br>弱的文本渲染能力<br>能够以 .png 或 .jpg 格式保存结果图像<br>最适合图像密集型的游戏，其中的许多对象会被频繁重绘<br>Canvas 是逐像素进行渲染的。<br>在 canvas 中，一旦图形被绘制完成，它就不会继续得到浏览器的关注。如果其位置发生变化，那么整个场景也需要重新绘制，包括任何或许已被图形覆盖的对象。</p>
<p>canvas中绘制的元素不可以通过浏览器提供的接口获取到。<br>SVG</p>
<p>SVG是通过XML进行绘图的<br>不依赖分辨率<br>支持事件处理器<br>最适合带有大型渲染区域的应用程序（比如谷歌地图）<br>复杂度高会减慢渲染速度<br>不适合游戏应用</p>
<p>SVG中绘制的元素可以通过浏览器提供的接口获取到。</p>
<p>SVG为了之后的操作，需要记录坐标，所以比较缓慢</p>
<hr>
<p>不对字符编码，当表单中包含文件上传控件时，需要将enctype设置为：multipart/form-data</p>
<p>enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。<br>在发送前编码所有字符（默认） application/x-www-form-urlencoded<br>空格转换为 “+” 加号，但不对特殊字符编码。text/plain </p>
<p>IE6/7/8不支持事件捕获（对）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;blockquote&gt; 标签定义摘自另一个源的块引用。&lt;blockquote&gt; 与 &lt;&#x2F;blockquote&gt;之间的所有文本都会从常规文本中分离出来，经常会在左、右两边进行缩进，而且有时会使用斜体。也就是说，块引用拥有它们自己的空间。</span><br></pre></td></tr></table></figure>

<hr>
<p>名为“ctx”的变量是某个HTML5画布对象的上下文。以下代码绘制的是什么？Ctx.arc(x,y,r,0,Math.PI,true);</p>
<p>在给定点逆时针绘制一个半圆</p>
<hr>
<p>当使用地图进行图像搜索时，可以把一幅图片从电脑桌面拖放到地图页面的输入框中，这是使用了HTML5的（）API实现的（单）File</p>
<p>文件（File）接口提供有关文件的信息，并允许网页中的 JavaScript 访问其内容。<br> 通常情况下，File对象是来自用户在一个 &lt;input&gt; 元素上选择文件后返回的 FileList 对象,也可以是来自由拖放操作生成的 DataTransfer 对象，或者来自 HTMLCanvasElement 上的mozGetAsFile() API。</p>
<hr>
<p>部分无视和完全无视的区别？需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围(可以说是部分无视)。而对于使用absolute position脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。(可以说是完全无视)</p>
<hr>
<p>关于XML，说法正确与否：</p>
<p>每个合格的xml都有唯一的根元素（对）</p>
<p>XML常用于WebService中用来做数据交换的标准（对）</p>
<p>XML中的数据可以通过XPATH检索查询（对）</p>
<hr>
<p>document是文档（整个DOM树）的根节点（对）</p>
<p>p元素不能包含任何块级元素(包括自身)<br>a元素可以包含任何其他元素(除了自身)<br>li里可以包含一个新的有序或无序列表。</p>
<hr>
<p>link标签是同时加载的，script标签才会加载完一个再加载另一个，因为JavaScript是一种单线程的脚本语言</p>
<p>id不能为纯数字</p>
<hr>
<p>Ajax（AsynchronousJavaScriptand XML），直译为“异步的JavaScript与XML技术”，是一种创建交互式网页应用的网页开发技术，与传统的Web应用相比，Ajax通过浏览器与服务器进行少量的数据交换就可以实现网页的异步更新，在不重新加载整个网页的情况下，即可对网页进行更新。</p>
<hr>
<p>td中设置align= ‘center’，列中内容会居中显示。</p>
<hr>
<p>ScrollView竖直滚动条，水平方向上的滚动条HorizontalScrollView。</p>
<p>ScrollView中，可以直接包含(一)个组件</p>
<hr>
<p>dom中HTMLDivElement的正确继承关系是</p>
<p>HTMLDivElement -&gt; HTMLElement -&gt; Element -&gt; Node -&gt; EventTarget</p>
<hr>
<p>label标签只有两个属性，for（规定 label 绑定到哪个表单元素。）disabled</p>
<p>没有id属性</p>
<hr>
<p>head 标签中必不少的是&lt;title&gt;</p>
<p>Readonly规定输入的字段为只读，即用户不可修改，但是用户可以通过tab切换到该字段，还可以选中复制该字段。</p>
<hr>
<p>Web应用特有的状态作用域： 请求作用域，会话作用域，应用上下文。 </p>
<hr>
<p>autoplay 属性规定一旦视频就绪马上开始播放。</p>
<p>preload 属性规定是否在页面加载后载入视频，如果设置了 autoplay 属性，则忽略该属性。</p>
<hr>
<p>&lt;dfn&gt; 标签可标记那些对特殊术语或短语的定义；</p>
<p>&lt;abbr&gt; 标签指示简称或缩写</p>
<hr>
<p>HTML 5 支持 HTML 4 中的所有表单控件（对）</p>
<p>html中a标签target属性的默认值是_self</p>
<p>&lt;textarea&gt;没有width属性，但是可以设置cols属性来控制宽度。</p>
<p>&lt;blockquote&gt;长文本引用</p>
<hr>
<p>假链接中我们通常在a标签的href中添加什么能使得页面不跳转</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href &#x3D; &quot;http:&#x2F;&#x2F;www.baidu.com&quot; onclick &#x3D; &quot;return false&quot; &gt;不能跳转到百度&lt;&#x2F;a&gt;&lt;a href &#x3D; &quot;javascript: ;&quot; &gt;不能跳转&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<hr>
<p>js中的函数就是一个对象，每个函数对象都继承了js的Function类（错）</p>
<p>箭头函数不能调用Function的bind、apply、call方法（Function类具有的方法），没有继承Function类</p>
<hr>
<p>置换元素：浏览器根据元素的标签和属性，来决定元素的具体显示内容。 </p>
<p>&lt;img&gt;、&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;、&lt;object&gt;</p>
<p>不可替换元素：(x)html 的大多数元素是不可替换元素，即其内容直接表现给用户端（如浏览器）。</p>
<p>例如： &lt;label&gt;label中的内容&lt;/label&gt; 标签&lt;label&gt;是一个非置换元素，文字label中的内容”将全被显示。</p>
<hr>
<p>在js里面添加的属性名使用驼峰法，在css里面使用连接线</p>
<p>a标签有href属性才有下划线标识！</p>
<hr>
<h3 id="152-以下代码执行后，array的结果是？"><a href="#152-以下代码执行后，array的结果是？" class="headerlink" title="152 以下代码执行后，array的结果是？"></a>152 以下代码执行后，array的结果是？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var array&#x3D;[-1,1,3,4,6,10]; array.sort((a,b)&#x3D;&gt;Math.abs(a-3)-Math.abs(b-3)); &#x2F;&#x2F;[3,4,1,6,-1,10]&#x2F;&#x2F;将每个数进行Math.abs(a - 3）后的大小进行排序</span><br></pre></td></tr></table></figure>

<h3 id="154有var-d-new-Date-apos-2018-05-09-apos-，可以设置为6月份的操作是？"><a href="#154有var-d-new-Date-apos-2018-05-09-apos-，可以设置为6月份的操作是？" class="headerlink" title="154有var d = new Date(&apos;2018-05-09&apos;)，可以设置为6月份的操作是？"></a>154有var d = new Date(&apos;2018-05-09&apos;)，可以设置为6月份的操作是？</h3><p>d.setMonth(5); //月份是0-12</p>
<p>d.setDate(40);//如果当月有 30 天，32 为下一个月的第二天， 40 为下一个月的第9天</p>
<h3 id="155"><a href="#155" class="headerlink" title="155"></a>155</h3><p>‘hello’ 和 new String(‘hello’) 的区别，前者是字符串字面值，属于原始类型，而后者是对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var str1&#x3D;new String(&#39;str1&#39;); var str2&#x3D;&#39;str2&#39;; console.log(typeof str1);&#x2F;&#x2F;object console.log(typeof str2);&#x2F;&#x2F;string console.log(str1 instanceof String);&#x2F;&#x2F;true console.log(str2 instanceof String);&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>

<h3 id="156-1"><a href="#156-1" class="headerlink" title="156"></a>156</h3><p>如何获取下面表单 select域的选择部分的文本？obj.options[obj.selectedInded].text</p>
<hr>
<p>页面有一个按钮button，id为button1，通过原生的js如何禁用？</p>
<p>document.getElementById(“button1”).setAttribute(“disabled”, “true”);或者</p>
<p>document.getElementById(“button1”).disabled = true;</p>
<hr>
<p>if下的js语句也会进行变量提升</p>
<hr>
<p>call和apply函数有两个参数，第一个是上下文，第二个是参数组成的数组；如果第一个参数是null，则使用全局对象替代</p>
<hr>
<p>var a=b=3 时a是局部变量，而b是全局变量</p>
<hr>
<p>在标准的JavaScript中，Ajax异步执行调用基于哪些机制才能实现？（Event和callback）</p>
<hr>
<p>Referer是request Header里的内容</p>
<hr>
<p>不要在块内声明一个函数（严格模式会报语法错误）。如果确实需要在块中定义函数，可以使用函数表达式来声明函数。</p>
<hr>
<p>javascirpt中的数字在计算机内存储为8Byte</p>
<h3 id="159"><a href="#159" class="headerlink" title="159"></a>159</h3><p>在大数据量的场景下，字符串的连接方式较为高级的是？</p>
<p>+的处理机制是：新建一个临时字符串，将新字符串赋值为a+b，然后返回这个临新字符串并同时销毁原始字符串，所以字符串连接效率较低。所以用Array.join()不会新建临时字符串效率更高。 （当然以上效率问题仅存在于低版本浏览器ie7-及以下，现在的新浏览器基本上都解决了这个问题，效率差不多） </p>
<p>所以在面试时遇到这种题时告诉面试官分两种情况： </p>
<p>旧浏览器（ie7-）下用join()会高效，而新版本浏览器下除了做变量缓存外不需要做别的优化。这样可以侧面表达对刘拉你兼容有所了解。</p>
<h3 id="160"><a href="#160" class="headerlink" title="160"></a>160</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var A &#x3D; &#123;n: 4399&#125;;var B &#x3D; function () &#123;this.n &#x3D; 9999&#125;;var C &#x3D; function () &#123;var n &#x3D; 8888&#125;;B.prototype &#x3D; A;C.prototype &#x3D; A;var b &#x3D; new B();var c &#x3D; new C();A.n++;console.log(b.n);&#x2F;&#x2F;9999console.log(c.n);&#x2F;&#x2F;4400</span><br></pre></td></tr></table></figure>

<p>console.log(b.n);在查找 b.n 是首先查找 b 对象自身有没有 n 属性，如果没有会去原型prototype上查找，当执行 var b = new B() 时，函数内部 this.n=9999(此时this指向b)，返回b对象，b对象有自身的n属性，所以返回 9999</p>
<p>console.log(c.n); 同理，当执行 var c = new C() 时，c对象没有自身的n属性，向上查找，找到原型prototype上的 n 属性，因为 A.n++(此时对象A中的n为4400)，所以返回4400</p>
<h3 id="161"><a href="#161" class="headerlink" title="161"></a>161</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function g () &#123;	return 23;&#125;;&#x2F;&#x2F;如果是typeof f，结果是function &#x2F;&#x2F;如果是typeof f()，结果是number &#x2F;&#x2F;如果是typeof g,结果是undefined. &#x2F;&#x2F;如果是typeof g(),会立即执行g()，结果是ReferenceError，因为g is not defined</span><br></pre></td></tr></table></figure>

<h3 id="163"><a href="#163" class="headerlink" title="163"></a>163</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr&#x3D;[&#123;a:1&#125;,&#123;&#125;];arr.forEach(function(item,idx)&#123;    item.b&#x3D;idx;&#125;);上面代码执行后， arr 的值是：[&#123;a: 1, b: 0&#125;, &#123;b: 1&#125;]arr.forEach（a,b,c） 这个函数用于数组的遍历，其中三个参数abc意义如下 a代表arr[0]---arr[arr.length-1] b代表0---arr.length-1 c代表arr &#x2F;&#x2F;参数c被省略了 所以第一次循环 a&#x3D;&#123;a:1&#125; , b&#x3D;0; 执行a.b &#x3D; 0 后，以为a是一个对象，即给对象啊添加一个b属性，值为0 得到[&#123;a:1,b:0&#125;,&#123;&#125;] 第二次循环也是这个意思</span><br></pre></td></tr></table></figure>

<h3 id="164-1"><a href="#164-1" class="headerlink" title="164"></a>164</h3><p>静态语言（强类型语言）</p>
<p>静态语言是在编译时变量的数据类型即可确定的语言，多数静态类型语言要求在使用变量之前必须声明数据类型。 </p>
<p>例如：C++、Java、Delphi、C#等。</p>
<p>动态语言（弱类型语言）</p>
<p>动态语言是在运行时确定数据类型的语言。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。 </p>
<p>例如PHP/ASP/Ruby/Python/Perl/ABAP/SQL/JavaScript/Unix Shell等等。</p>
<h3 id><a href="#" class="headerlink" title></a></h3><h3 id="167白屏时间first-paint和可交互时间dom-ready的关系是？"><a href="#167白屏时间first-paint和可交互时间dom-ready的关系是？" class="headerlink" title="167白屏时间first paint和可交互时间dom ready的关系是？"></a>167白屏时间first paint和可交互时间dom ready的关系是？</h3><p>先触发first paint，后触发dom ready</p>
<p>白屏时间（first Paint Time）——用户从打开页面开始到页面开始有东西呈现为止</p>
<p>首屏时间——用户浏览器首屏内所有内容都呈现出来所花费的时间</p>
<p>用户可操作时间(dom Interactive)——用户可以进行正常的点击、输入等操作，默认可以统计domready时间，因为通常会在这时候绑定事件操作</p>
<p>总下载时间——页面所有资源都加载完成并呈现出来所花的时间，即页面 onload 的时间</p>
<h3 id="168-1"><a href="#168-1" class="headerlink" title="168"></a>168</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;  &lt;input type&#x3D;&quot;button&quot; id &#x3D; &quot;button1&quot; value&#x3D;&quot;1&quot; onclick&#x3D;&quot;moveBtn(this);&quot;&gt;  &lt;input type&#x3D;&quot;button&quot; id &#x3D; &quot;button2&quot; value&#x3D;&quot;2&quot;&#x2F;&gt;&lt;&#x2F;div&gt;&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;function moveBtn(obj) &#123;   var clone &#x3D; obj.cloneNode(true); &#x2F;&#x2F; 复制一个button1结点   var parent &#x3D; obj.parentNode; &#x2F;&#x2F; 找到button1的父节点   parent.appendChild(clone); &#x2F;&#x2F; 将复制的结点加入到父节点，也就是button1的复制结点现在在button2后面   parent.removeChild(obj); &#x2F;&#x2F; 移除原来的button1 &#125;&lt;&#x2F;script&gt;所以最终达到的效果：鼠标单机Button1后把button1结点移到button2结点后面。</span><br></pre></td></tr></table></figure>

<h3 id="169-1"><a href="#169-1" class="headerlink" title="169"></a>169</h3><p>若需给子scope发送消息，需使用（$broadcast() ）方法</p>
<p>$emit() 是向上冒泡</p>
<p>$broadcast() 是向下传播事件</p>
<h3 id="170-1"><a href="#170-1" class="headerlink" title="170"></a>170</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; parseFloat(),解析一个字符串，并返回一个浮点数。&#x2F;&#x2F; toFixed把数字转换为字符，结果的小数点后有指定位数的数字,按四舍五入取值var num &#x3D; new Number(15.7857);var a &#x3D; num.toFixed(); &#x2F;&#x2F;16 无参数，表示小数点后面位数为0位，然后四舍五入var b &#x3D; num.toFixed(1);&#x2F;&#x2F;15.8var c &#x3D; num.toFixed(3);&#x2F;&#x2F;15.786var d &#x3D; num.toFixed(10);  &#x2F;&#x2F;多出的补0&#x2F;&#x2F;toPrecision()把数字格式化为指定长度var f &#x3D; num.toPrecision();&#x2F;&#x2F;15.7857，无参数，返回原数字var g &#x3D; num.toPrecision(1);&#x2F;&#x2F;2e+1，参数小于整数部分位数，返回科学计数var h &#x3D; num.toPrecision(3);&#x2F;&#x2F;15.8，也是有四舍五入var i &#x3D; num.toPrecision(10);&#x2F;&#x2F;15.78570000，长度不够补0</span><br></pre></td></tr></table></figure>

<h3 id="171typeof-Date-now-的值是：number"><a href="#171typeof-Date-now-的值是：number" class="headerlink" title="171typeof Date.now() 的值是：number"></a>171typeof Date.now() 的值是：number</h3><p>data.now是一个时间戳，Date.now() 方法返回自1970年1月1日 00:00:00 UTC到当前时间的毫秒数。它返回的数据是一个毫秒数，typeof是一个number类型。</p>
<h3 id="172-1"><a href="#172-1" class="headerlink" title="172"></a>172</h3><p>Object.prototype.prototype === undefined;//true</p>
<p>Object.prototype只是一个普通对象(普通对象没有prototype属性，所以值是undefined)，Object.prototype是js原型链的最顶端，它的__proto__是null</p>
<p> var obj = {};</p>
<p>obj.<strong>__proto__</strong> === Object.prototype;//true</p>
<p>obj.prototype === undefined;//true</p>
<p>原型链是基于____proto____形成的，继承是通过prototype实现的。</p>
<p>Function.prototype是个特例，它是函数对象，但是没有prototype属性。其他所有函数都有prototype属性。</p>
<p>Function.prototype.prototype === undefined;//true</p>
<p>内置的Function也是一个函数对象，它是通过自己来创建自己的。</p>
<p>Function.<strong>__proto__</strong>=== Function.prototype;//true</p>
<p>函数也是对象，因为Function.prototype.____proto____指向Object.prototype。</p>
<p>typeof Function.prototype.<strong>__proto__</strong>=== “object”;//true</p>
<h3 id="173"><a href="#173" class="headerlink" title="173"></a>173</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Foo () &#123;	console.log(this.location);&#125;Foo();&#x2F;&#x2F;返回当前窗口的Location对象&#x2F;&#x2F;&#39;use strict&#39;条件下，会报TypeError；无&#39;use strict&#39;条件下，this指向window</span><br></pre></td></tr></table></figure>

<h3 id="174"><a href="#174" class="headerlink" title="174"></a>174</h3><p>console.log(1+ +”2”+”2”);  //(+”2”)应用了一元加操作符，一元加操作符相当于Number()函数，会将(+”2”)转换为2,1+2+”2”=32</p>
<p>console.log(“A”- “B”+”2”);  //在减法中遇到字符串和加法相反，调用Number()函数将字符串转换为数字，不能转换则返回NaN，此时运用加法规则，NaN+”2”，”2”是字符串，则将两者拼接。</p>
<p>console.log(“A”- “B”+2);  //这个与上面的不太相同，减法运算后依然为NaN，但是加号后面的为数字2，加法规则中，如果有一个操作数是NaN，则结果为NaN</p>
<h3 id="175"><a href="#175" class="headerlink" title="175"></a>175</h3><p>假设val已经声明,可定义为任何值。则下面js代码有可能输出的结果为:(‘define’)</p>
<p>console.log(‘Value is ‘ + (val != ‘0’) ? ‘define’ : ‘undefine’);</p>
<p>加号优先级高于 三目运算。低于括号。 所以括号中无论真假 加上前边的字符串都为 TRUE 三目运算为TRUE是 输出 define</p>
<h3 id="176"><a href="#176" class="headerlink" title="176"></a>176</h3><p>({} + ‘b’ &gt; {} + ‘a’)返回值是（true）</p>
<p>假如是这样{}+‘b’&gt;{}+’a’中 </p>
<p>{}处在语句的起始位置，不会被解析成{}空对象，会被解析为一个表达式，类似于这样</p>
<p>{ </p>
<p>} </p>
<p>+‘b’ </p>
<p>此时的+‘b’是一个表达式值为NaN </p>
<p>第二个{}并没有处在语句的起始位置，所以会被解析成为空对象 </p>
<p>此时的{}+’a’ 结果为【object object】a </p>
<p>所以{}+’b’&gt;{}+’a’结果为false </p>
<p>而（{}+’b’&gt;{}+’a’）结果为true </p>
<p>因为上面的表达式解析后的结果是【object object】b &gt;【object object】a </p>
<p>此时会按照ASCII码进行比较</p>
<p>{} + ‘b’ -&gt; NaN </p>
<p>{} + ‘a’ -&gt; NaN </p>
<p>{} + ‘b’ &gt; {} + ‘a’ -&gt; false</p>
<p>({} + ‘b’ &gt; {} + ‘a’) -&gt; true</p>
<h3 id="177"><a href="#177" class="headerlink" title="177"></a>177</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var color &#x3D; &quot;green&quot;;var test4399 &#x3D; &#123;	color: &quot;blue&quot;;	getColor: function () &#123;		var color &#x3D; &quot;red&quot;;		alert(this.color);	&#125;&#125;var getColor &#x3D; test4399.getColor;getColor();&#x2F;&#x2F;greentest4399.getColor();&#x2F;&#x2F;blue</span><br></pre></td></tr></table></figure>

<h3 id="179-1"><a href="#179-1" class="headerlink" title="179"></a>179</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当用户打开一个页面时，想一直停留在当前打开的页面，禁止页面前进和后退，以下正确的是ADA. window.history.forward(1);B. window.history.back(1);C. window.history.go(-1);D. window.history.forward(-1);</span><br></pre></td></tr></table></figure>

<p>B. Window History Back</p>
<p>history.back() 方法加载历史列表中前一个 URL。 这等同于在浏览器中点击后退按钮。</p>
<p>C. 跳转到 history 中指定的一个点</p>
<p>你可以用 go() 方法载入到会话历史中的某一特定页面， 通过与当前页面相对位置来标志 (当前页面的相对位置标志为0).</p>
<p>向后移动一个页面 (等同于调用 back()):window.history.go(-1);</p>
<p>向前移动一个页面, 等同于调用了 forward():window.history.go(1);</p>
<p>&lt;SCRIPT language=”JavaScript”&gt; </p>
<p>​    javascript:window.history.forward(1); </p>
<p>&lt;/SCRIPT&gt; </p>
<p>这种方法是用于防止由下一个页面返回的。 简单的说，页面A（A中有这段代码）转向页面B， 这时，B向A转向是被禁止。</p>
<p>有时候我们再做网页时不希望某个网页通过浏览器的前进后退按钮来后退或前进，可以通过简单的办法达到该效果&lt;body οnbefοreunlοad=”history.go(0)”&gt;这样这个网页就会永远停留再这个页面，不能前进后退了。</p>
<h3 id="180-1"><a href="#180-1" class="headerlink" title="180"></a>180</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; new Boolean(false);if (x) &#123; alert(&#39;hi&#39;); &#125;var y &#x3D; Boolean(0);if (y) &#123; alert(&#39;hello&#39;); &#125;&#x2F;&#x2F;的显示结果是hi</span><br></pre></td></tr></table></figure>

<p>此题考查的是 JS 的类型转换： </p>
<p>if(x) 这里期望 x 是一个布尔类型的原始值，而 x 是一个对象，任何对象转为布尔值，都为得到 true（切记！在 JS 中，只有 0，-0，NaN，””，null，undefined 这六个值转布尔值时，结果为 false）。 </p>
<p>题目的第二部分，一定要注意 y = Boolean(0)，而不是 y = new Boolean(0)。这两个有很大区别，用 new 调用构造函数会新建一个布尔对象，此处没有加 new，进行的是显示类型转换，正如上述第一条所说，0 转换布尔，结果为 false，所以此时 y 的值就是 false。</p>
<h3 id="182以下表达式不会出现错误的是？"><a href="#182以下表达式不会出现错误的是？" class="headerlink" title="182以下表达式不会出现错误的是？"></a>182以下表达式不会出现错误的是？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A 2.toString()B 2..toString()C 2 .toString()D (2).toString()</span><br></pre></td></tr></table></figure>

<p>BCD</p>
<p>.和数字在一块 会优先被认为是数字的小数点 而不是调用方法 所以toString() 前面没有点就报错</p>
<h3 id="183以下哪个表达式的值是true？"><a href="#183以下哪个表达式的值是true？" class="headerlink" title="183以下哪个表达式的值是true？"></a>183以下哪个表达式的值是true？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A &#39;1&#39; &#x3D;&#x3D;&#x3D; 1B isNaN(1&#x2F;0)C 1 in [1]D 1 &amp;&amp; 2 &gt; 1</span><br></pre></td></tr></table></figure>

<p>D</p>
<p>B选项。 任何数值除以0都会导致错误而终止程序执行。但是在 JavaScript 中，会返回出特殊的值，因此不会影响程序的执行。 比0大的数除以0，则会得到无穷大，所以 js 用 Infinity 来显示出来。 也就是1/0得到的是Infinity。isNaN(1/0)返回的是false。但是isNaN(0/0)返回的就是true </p>
<p>C选项。in操作符，对于数组属性需要指定数字形式的索引值来表示数组的属性名称（固有属性除外如length）。 所以说在这里，1 in [1]并不是表示数字1在不在数组里。而是表示数组中含不含有1这个索引index值。数组长度为1，所以只含有的index值为0，这个表达式返回fasle。 </p>
<p>D选项。1 &amp;&amp; 2 &gt; 1，先判断右边的表达式，2&gt;1返回true。1 &amp;&amp; true返回的结果也是true。</p>
<h3 id="184"><a href="#184" class="headerlink" title="184"></a>184</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#123;n: 1&#125;;(function (foo) &#123;	console.log(foo.n);	foo.n &#x3D; 3;	var foo &#x3D; &#123;n: 2&#125;;	console.log(foo.n);&#125;)(foo);console.log(foo.n);&#x2F;&#x2F;&#x2F;运行的结果是  1 2 3var foo &#x3D; &#123;n:1&#125;;(function(foo)&#123;  &#x2F;&#x2F;形参foo同实参foo一样指向同一片内存空间，这个空间里的n的值为1    var foo;               &#x2F;&#x2F;已经声明且赋值的变量再重新声明，重新声明是无效的    console.log(foo.n);    &#x2F;&#x2F;输出1    foo.n &#x3D; 3;             &#x2F;&#x2F;形参与实参foo指向的内存空间里的n的值被改为3    foo &#x3D; &#123;n:2&#125;;           &#x2F;&#x2F;形参foo指向了新的内存空间，里面n的值为2.    console.log(foo.n);    &#x2F;&#x2F;输出新的内存空间的n的值&#125;)(foo);console.log(foo.n);        &#x2F;&#x2F;实参foo的指向还是原来的内存空间，里面的n的值为3.</span><br></pre></td></tr></table></figure>

<h3 id="186说法正确的是"><a href="#186说法正确的是" class="headerlink" title="186说法正确的是"></a>186说法正确的是</h3><p>A 所有变量在使用之前必须做声明</p>
<p>B JS是面向对象的程序设计语言</p>
<p>C JS是解释性语言</p>
<p>D JS前身是Oak语言</p>
<p>C对。语言是相对于编译型语言存在的，源代码不是直接翻译成机器语言，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。比如Python/JavaScript / Perl /Shell等都是解释型语言。</p>
<p>A。如果是局部变量无需声明，也可以使用。</p>
<p>B面向对象语言提供了类、继承等成分，有识认性、多态性、类别性和继承性四个主要特点。而javascript没有这些，所以B错误。</p>
<p>D选项中JAVA的前身才是Oak，而不是JavaScript。所以D错误。</p>
<h3 id="187请阅读以下代码"><a href="#187请阅读以下代码" class="headerlink" title="187请阅读以下代码"></a>187请阅读以下代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;obj.log &#x3D; console.log;obj.log.call(console,this);&#x2F;&#x2F;该代码在浏览器中执行，输出的日志结果是什么？(window)&#x2F;&#x2F;call方法是用来改变this指向的，调用该方法的obj方法log中的this不再指向obj。没用明确指向的this都指向顶层对象window</span><br></pre></td></tr></table></figure>

<h3 id="188-1"><a href="#188-1" class="headerlink" title="188"></a>188</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function checkState()&#123;	alert(&quot;liyuming&quot;); &#125;window.setTimeout(checkState(), 10000); &#x2F;&#x2F;立即被调用window.setTimeout(checkState, 10000); &#x2F;&#x2F; 10s后被调用 window.setTimeout(&quot;checkState()&quot;, 10000); &#x2F;&#x2F;10s后被调用 注意和第一个的区别 有引号</span><br></pre></td></tr></table></figure>

<h3 id="189-1"><a href="#189-1" class="headerlink" title="189"></a>189</h3><p>Math.round(-11.5)  -11</p>
<p>Math.round(-11.55) -12</p>
<p>如果参数的小数部分大于0.5，则四舍五入到相邻的绝对值更大的整数，相反则舍入到绝对值更小的整数，如果刚好为0.5，则舍入到相邻的正无穷方向的整数</p>
<p>toFixed(n)只是保留n位小数，也是四舍五入</p>
<p>var result = Math.round(num * 10) / 10四舍五入保留一位小数</p>
<h3 id="190不支持冒泡的事件有abort-resize-error-load-unload-mouseenter-mouseleave-blur-focus"><a href="#190不支持冒泡的事件有abort-resize-error-load-unload-mouseenter-mouseleave-blur-focus" class="headerlink" title="190不支持冒泡的事件有abort resize error load unload mouseenter mouseleave blur focus"></a>190不支持冒泡的事件有abort resize error load unload mouseenter mouseleave blur focus</h3><h3 id="191-1"><a href="#191-1" class="headerlink" title="191"></a>191</h3><p>JS中slice()方法是选取数组的的一部分，并返回一个新数组，不会改变原数组。</p>
<hr>
<p>noscript 元素用来定义在脚本未被执行时的替代内容（文本）。</p>
<hr>
<p>Flash提供了ExternalInterface接口与JavaScript通信，ExternalInterface有两个方法，call和addCallback，call的作用是让Flash调用js里的方法，addCallback是用来注册flash函数让js调用。</p>
<hr>
<p>document.getElementById的返回值的类型为？Object</p>
<p>document.getElementById(‘id’)返回的类型? Function</p>
<hr>
<p>for循环是按顺序的，for in 循环是不按顺序的</p>
<hr>
<p>RegExp 对象有 3 个方法：test()、exec() 和 compile()。</p>
<p>test() 方法用来检测一个字符串是否匹配某个正则表达式，如果匹配成功，返回 true ，否则返回 false；</p>
<p>exec() 方法用来检索字符串中与正则表达式匹配的值。exec() 方法返回一个数组，其中存放匹配的结果。如果未找到匹配的值，则返回</p>
<p>compile() 方法可以在脚本执行过程中编译正则表达式，也可以改变已有表达式。</p>
<h3 id="192以下这些表达式的值为0"><a href="#192以下这些表达式的值为0" class="headerlink" title="192以下这些表达式的值为0"></a>192以下这些表达式的值为0</h3><p>(()=&gt;{}).length; 。获取方法形参个数，形参为0 </p>
<p>1&amp;2   1=0001 2=0010 按位与运算，同为1才为1，否则返回0 </p>
<p>+[] 。隐式类型转换，因为[]是对象，所以toPrimitive-&gt;valueOf-&gt;toString为’’，+空字符串就是Number(‘ ’) = 0，结果就是+’’===0 </p>
<p>[1, 2, -3].reducer((a, b) =&gt; a - b, 0)。reduce对数组中的每个元素执行一个reducer函数(升序执行)，reduce接受2个参数，回调函数和初始值。将其结果汇总为单个返回值。a为累计器累计回调的返回值，b为数组的每一项元素，传入初始值0-&gt;0-(1)-&gt;(-1)-2-&gt;(-3)-(-3)-&gt;0</p>
<h3 id="193Ajax和Flash比较"><a href="#193Ajax和Flash比较" class="headerlink" title="193Ajax和Flash比较"></a>193Ajax和Flash比较</h3><p>Ajax的优势：1.可搜索性 2.开放性 3.费用 4.易用性 5.易于开发。 </p>
<p>Flash的优势：1.多媒体处理 2.兼容性 3.矢量图形 4.客户端资源调度</p>
<p>Ajax的劣势：1.它可能破坏浏览器的后退功能  2.使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中，不过这些都有相关方法解决。 </p>
<p>Flash的劣势：1.二进制格式 2.格式私有 3.flash 文件经常会很大，用户第一次使用的时候需要忍耐较长的等待时间 4.性能问题</p>
<h3 id="194以下Js程序的输出是什么（）"><a href="#194以下Js程序的输出是什么（）" class="headerlink" title="194以下Js程序的输出是什么（）"></a>194以下Js程序的输出是什么（）</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT LANGUAGE&#x3D;&quot;JavaScript&quot;&gt;    var a&#x3D;&quot;undefined&quot;;    var b&#x3D;&quot;false&quot;;    var c&#x3D;&quot;&quot;;    function assert(aVar)&#123;        if(aVar)                  alert(true);        else              alert(false);    &#125;    assert(a);    assert(b);    assert(c);&lt;&#x2F;SCRIPT&gt;&#x2F;&#x2F;true true false&#x2F;&#x2F;变量abc都是字符串型的变量，而不是真正的undefined和false，在判断里都会被认为是真值，显示true，只有空串为false</span><br></pre></td></tr></table></figure>

<h3 id="195-1"><a href="#195-1" class="headerlink" title="195"></a>195</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [];arr[0] &#x3D; 0;arr[1] &#x3D; 1;arr.foo &#x3D; &#39;c&#39;;console.log(arr.length);&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>

<p>var arr = [‘1’，‘2’]这本质上是一系列操作：得到一个数组对象；调用了它的数组方法存入了一些数据，arr.length根据存入数据的数目被修改arr.length，对arr对象的length属性进行一个访问arr.foo = ‘c’ 对arr对象创建一个属性，所以.foo跟.length地位是并列的：就是arr的一个属性，同时arr的数组方法跟这些属性是毫不相关的</p>
<h3 id="196"><a href="#196" class="headerlink" title="196"></a>196</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">以下代码的执行后，str 的值是：Hello Worldvar str &#x3D; &quot;Hellllo world&quot;;str &#x3D; str.replace(&#x2F;(l)\1&#x2F;g, &#39;$1&#39;);(l)表示第一个分组里有l \1表示所获取的第1个()匹配的引用 &#x2F;g表示全局匹配 $1表示第一个分组里的值l (l)\l 表示匹配两个连续字符ll，即ll (l)\l&#x2F;g 表示全局匹配两个连续字符ll即llllstr.replace(&#x2F;(l)\1&#x2F;g, &#39;$1&#39;) 表示将ll替换成lHellllo &#x3D;》 Hello</span><br></pre></td></tr></table></figure>

<h3 id="197"><a href="#197" class="headerlink" title="197"></a>197</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Function.prototype.a &#x3D; &#39;a&#39;;Object.prototype.b &#x3D; &#39;b&#39;;function Person()&#123;&#125;;var p &#x3D; new Person();console.log(&#39;p.a: &#39;+ p.a); &#x2F;&#x2F; p.a: undefinedconsole.log(&#39;p.b: &#39;+ p.b); &#x2F;&#x2F; p.b: b  &#x2F;&#x2F;原型链是通过__proto__实现的</span><br></pre></td></tr></table></figure>

<h3 id="198请给出这段代码的运行结果"><a href="#198请给出这段代码的运行结果" class="headerlink" title="198请给出这段代码的运行结果"></a>198请给出这段代码的运行结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;SCRIPT LANGUAGE&#x3D;&quot;JavaScript&quot;&gt;var bb &#x3D; 1;function aa(bb) &#123;    bb &#x3D; 2;    alert(bb);&#125;;aa(bb);&#x2F;&#x2F;2alert(bb);&#x2F;&#x2F;1&lt;&#x2F;SCRIPT&gt;记住一句话就好了：“ECMA中所有函数的参数都是按值传递的”。 值传递：把一个值类型（也叫基本类型）传递给另一个变量时，其实是分配了一块新的存储空间，因此就本题来说，在内部改变这个值时，其实在函数外部对这个值没有影响。</span><br></pre></td></tr></table></figure>

<h3 id="199"><a href="#199" class="headerlink" title="199"></a>199</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function test () &#123;	var n &#x3D; 4399;	function add () &#123;		n++;		console.log(n);	&#125;	return &#123;n: n, add: add&#125;&#125;var result &#x3D; test();var result2 &#x3D; test();result.add();result.add();console.log(result.n);result2.add();&#x2F;&#x2F;输出结果为：4400 4401 4399 4400test构成了一个闭包，result跟result2各自有自己的test作用域，所以最后result2.add()结果是4400，第三个，这里&#123;n：n&#125;是对变量n里的值进行缓存，而不是本身n这个指针变量，这样生成n时候n里存的值是多少返回的对象里值就是多少result跟result2之所有有各自的作用域是两次调用了函数后必然产生的结果，两次调用函数，产生两个闭包留在内存里。至于第三个，如果你并没接触过指针的概念的话（指针其实就是对内存地址的上层说法，因为当我们说内存地址的时候就是在说硬件了，为了实现软硬件分离所以又给了内存地址一个指针的概念用于软件层面）</span><br></pre></td></tr></table></figure>

<h3 id="200写出程序运行的结果"><a href="#200写出程序运行的结果" class="headerlink" title="200写出程序运行的结果"></a>200写出程序运行的结果</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var k &#x3D; 0;for(var i&#x3D;0,j&#x3D;0;i&lt;10,j&lt;6;i++,j++)&#123;    k +&#x3D; i + j;&#125;console.log(k)&#x2F;&#x2F;30&#x2F;&#x2F;考察知识点： 逗号表达式 逗号表达式只有最后一项是有效的0+0&#x3D;0 1+1+0&#x3D;2 2+2+2&#x3D;6 3+3+6&#x3D;12 4+4+12&#x3D;20 5+5+20&#x3D;30 下一步j&#x3D;6循环结束尝试改为第二个条件i&lt;6,j&lt;10, 结果为90。第二个条件判断的是布尔值，取逗号后的最后一个运算符来判断一般判断想要两个条件都满足，中间用&amp;连接</span><br></pre></td></tr></table></figure>

<h3 id="201以下代码执行后，a-x-和-b-x-的结果分别是？"><a href="#201以下代码执行后，a-x-和-b-x-的结果分别是？" class="headerlink" title="201以下代码执行后，a.x 和 b.x 的结果分别是？"></a>201以下代码执行后，a.x 和 b.x 的结果分别是？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function A(x)&#123; 	this.x &#x3D; x;&#125;A.prototype.x &#x3D; 1;function B(x)&#123;	this.x &#x3D; x;&#125;B.prototype &#x3D; new A();var a &#x3D; new A(2), b &#x3D; new B(3);delete b.x;&#x2F;&#x2F;解析:2 undefinedfunction A(x)&#123; this.x &#x3D; x;&#125;A.prototype.x &#x3D; 1;function B(x)&#123;this.x &#x3D; x;&#125;B.prototype &#x3D; new A();var a &#x3D; new A(2), &#x2F;&#x2F;a.x首先要在自己的构造函数中查找，没有采取原型上找，这里有this.x &#x3D; x.所以a.x &#x3D; 2; b &#x3D; new B(3);&#x2F;&#x2F;B.prototype &#x3D; new A();形成原型链delete b.x;&#x2F;&#x2F;但是delete只能删除自己的x不能删除父级的x.    &#x2F;&#x2F;b.x通过原型链找到构造函数A里面的this.x&#x3D;x但是没有赋值，所以undefined</span><br></pre></td></tr></table></figure>



<h3 id="203"><a href="#203" class="headerlink" title="203"></a>203</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myObject &#x3D; &#123;    foo: &quot;bar&quot;,    func: function() &#123;        var self &#x3D; this;        console.log(this.foo);           console.log(self.foo);           (function() &#123;            console.log(this.foo);               console.log(self.foo);           &#125;());    &#125;&#125;;myObject.func();程序的输出是什么？bar bar undefined bar1.第一个this.foo输出bar，因为当前this指向对象myObject。2.第二个self.foo输出bar，因为self是this的副本，同指向myObject对象。3.第三个this.foo输出undefined，因为这个IIFE(立即执行函数表达式)中的this指向window。4.第四个self.foo输出bar，因为这个匿名函数所处的上下文中没有self，所以通过作用域链向上查找，从包含它的父函数中找到了指向myObject对象的self。</span><br></pre></td></tr></table></figure>

<h3 id="204解释型语言的特性是？非独立性、效率低"><a href="#204解释型语言的特性是？非独立性、效率低" class="headerlink" title="204解释型语言的特性是？非独立性、效率低"></a>204解释型语言的特性是？非独立性、效率低</h3><p>解释性语言和编译性语言的定义： </p>
<p>计算机不能直接理解高级语言，只能直接理解机器语言，所以必须要把高级语言翻译成机器语言，计算机才能执行高级语言编写的程序。</p>
<p>翻译的方式有两种，一个是编译，一个是解释。两种方式只是翻译的时间不同。</p>
<p>解释性语言的定义：js</p>
<p>解释性语言的程序不需要编译，在运行程序的时候才翻译，每个语句都是执行的时候才翻译。这样解释性语言每执行一次就需要逐行翻译一次，效率比较低。</p>
<p>现代解释性语言通常把源程序编译成中间代码，然后用解释器把中间代码一条条翻译成目标机器代码，一条条执行。</p>
<p>编译性语言的定义：</p>
<p>编译性语言写的程序在被执行之前，需要一个专门的编译过程，把程序编译成为机器语言的文件，比如exe文件，以后要运行的话就不用重新翻译了，直接使用编译的结果就行了（exe文件），因为翻译只做了一次，运行时不需要翻译，所以编译型语言的程序执行效率高。</p>
<h3 id="206"><a href="#206" class="headerlink" title="206"></a>206</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;	var x &#x3D; foo();	var foo &#x3D; function foo () &#123;		return &quot;foobar&quot;;	&#125;;	return x;&#125;)();&#x2F;&#x2F;var x;var foo;x &#x3D; foo();foo &#x3D; function foo() &#123;...&#125;当执行到 x &#x3D; foo() 时，由于foo未被定义为函数，所以会返回TypeError: foo is not a function</span><br></pre></td></tr></table></figure>

<h3 id="211以下哪些满足regexp-test-‘abc’-true"><a href="#211以下哪些满足regexp-test-‘abc’-true" class="headerlink" title="211以下哪些满足regexp.test(‘abc’) === true"></a>211以下哪些满足regexp.test(‘abc’) === true</h3><p>A /^abc$/</p>
<p>B /…(?=.)/</p>
<p>C /[ab]{2}[^defgh]/</p>
<p>D /[defgh]*/</p>
<p>ACD</p>
<p>B  …三个点没问题可以匹配到abc但是（）内的字符串也必须匹配到故fail掉 </p>
<p>B.”.”表示匹配除换行符的任意字符，”x(?=y)”匹配’x’仅仅当’x’后面跟着’y’.这种叫做先行断言。所以这里可以理解为： </p>
<p>1.当没有换行符时，只要字符前面是三的倍数/…/，并且后面跟有字符/(?=.)/，就可匹配，</p>
<p>2.有换行符时，每一行要重新匹配，即字符长度独立，从0开始（下划线处为匹配项） </p>
<p>C []内匹配两次a或b故可以为aa、bb、ab、ba、[^defgh]表示匹配除了defgh之外的数故可以匹配； </p>
<p>D []内匹配d或者e或f或g或h，但是*代表匹配0或多次故也可以不匹配</p>
<h3 id="213为什么利用多个域名来存储网站资源会更有效？"><a href="#213为什么利用多个域名来存储网站资源会更有效？" class="headerlink" title="213为什么利用多个域名来存储网站资源会更有效？"></a>213为什么利用多个域名来存储网站资源会更有效？</h3><p>CDN 缓存更方便 </p>
<p>突破浏览器并发限制 </p>
<p>节约 cookie 带宽 </p>
<p>节约主域名的连接数，优化页面响应速度</p>
<p> 防止不必要的安全问题</p>
<h3 id="214知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？"><a href="#214知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？" class="headerlink" title="214知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？"></a>214知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</h3><p>微格式（Microformats）是一种让机器可读的语义化 XHTML 词汇的集合，是结构化数据的开放标准。是为特殊应用而制定的特殊格式。</p>
<p> 优点：将智能数据添加到网页上，让网站内容在搜索引擎结果界面可以显示额外的提示。（应 用范例：豆瓣，有兴趣自行 google） </p>
<h3 id="215在-css-js-代码上线之后开发人员经常会优化性能，从用户刷新网页开始，-一次-js-请求一般情况下有哪些地方会有缓存处理？"><a href="#215在-css-js-代码上线之后开发人员经常会优化性能，从用户刷新网页开始，-一次-js-请求一般情况下有哪些地方会有缓存处理？" class="headerlink" title="215在 css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始， 一次 js 请求一般情况下有哪些地方会有缓存处理？"></a>215在 css/js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始， 一次 js 请求一般情况下有哪些地方会有缓存处理？</h3><p>dns 缓存，cdn 缓存，浏览器缓存，服务器缓存。</p>
<h3 id="216CSS-中可以通过哪些属性定义，使得一个-DOM-元素不显示在浏览器可视范围-内？"><a href="#216CSS-中可以通过哪些属性定义，使得一个-DOM-元素不显示在浏览器可视范围-内？" class="headerlink" title="216CSS 中可以通过哪些属性定义，使得一个 DOM 元素不显示在浏览器可视范围 内？"></a>216CSS 中可以通过哪些属性定义，使得一个 DOM 元素不显示在浏览器可视范围 内？</h3><p>最基本的： 设置 display 属性为 none，或者设置 visibility 属性为 hidden </p>
<p>技巧性： 设置宽高为 0，设置透明度为 0，设置 z-index 位置在-1000</p>
<h3 id="217什么是-Css-Hack？ie6-7-8-的-hack-分别是什么？"><a href="#217什么是-Css-Hack？ie6-7-8-的-hack-分别是什么？" class="headerlink" title="217什么是 Css Hack？ie6,7,8 的 hack 分别是什么？"></a>217什么是 Css Hack？ie6,7,8 的 hack 分别是什么？</h3><p>针对不同的浏览器写不同的 CSS code 的过程，就是 CSS hack</p>
<h3 id="218rgba-和-opacity-的透明效果有什么不同？"><a href="#218rgba-和-opacity-的透明效果有什么不同？" class="headerlink" title="218rgba()和 opacity 的透明效果有什么不同？"></a>218rgba()和 opacity 的透明效果有什么不同？</h3><p> rgba()和 opacity 都能实现透明效果，但最大的不同是 opacity 作用于元素，以及元素内的所有内容的透明度，而 rgba()只作用于元素的颜色或其背景色。（设置 rgba 透明的元素的子元素不会继承透明效果！）</p>
<h3 id="219css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？"><a href="#219css-中可以让文字在垂直和水平方向上重叠的两个属性是什么？" class="headerlink" title="219css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？"></a>219css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？</h3><p> 垂直方向：line-height 水平方向：letter-spacing</p>
<h3 id="220"><a href="#220" class="headerlink" title="220"></a>220</h3><p>严格模式下：页面排版及 JS 解析是以该浏览器支持的最高标准来执行 </p>
<p>混杂模式：不严格按照标准执行，主要用来兼容旧的浏览器，向后兼容</p>
<p>Quirks 模式（怪癖模式，诡异模式，怪异模式）</p>
<hr>
<p>为什么扩展 javascript 内置对象不是好的做法？ </p>
<p>因为扩展内置对象会影响整个程序中所使用到的该内置对象的原型属性</p>
<hr>
<p>用 H5+CSS3 解决下导航栏最后一项掉下来的问题</p>
<p>(书)</p>
<hr>
<p>readonly 只针对 input(text / password)和 textarea 有效， 而 disabled 对于所有的表单元素都有效，当表单元素在使用了 disabled 后，当我们将表单以 POST 或 GET 的方式提交的话，这个元素的值不会被传递出去，而 readonly 会将该值传递出 去</p>
<h3 id="223有-1-到-10w-这个-10w-个数，去除-2-个并打乱次序，如何找出那两个数"><a href="#223有-1-到-10w-这个-10w-个数，去除-2-个并打乱次序，如何找出那两个数" class="headerlink" title="223有 1 到 10w 这个 10w 个数，去除 2 个并打乱次序，如何找出那两个数"></a>223有 1 到 10w 这个 10w 个数，去除 2 个并打乱次序，如何找出那两个数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arrA &#x3D; [];var arrB &#x3D; [];var arrC &#x3D; [];&#x2F;&#x2F;求出A数组的值for(var i &#x3D; 0; i &lt; 10000; i++) &#123;	arrA.push(i);&#125;&#x2F;&#x2F;A排序arrA.sort(function(a, b) &#123;	return Math.random() - 0.5&#125;)&#x2F;&#x2F;求出B数组的值for(var i &#x3D; 0; i &lt; arrA.length - 2; i++) &#123;	arrB[arrA[i]] &#x3D; arrA[i];&#125;&#x2F;&#x2F;如果B数组里的第i项为undefind，打印出i放在arrCfor(var i &#x3D; 0; i&lt;arrB.length; i++)&#123;    if(arrB[i] &#x3D;&#x3D; undefined)&#123;    	arrC.push(i);    &#125;&#125;console.log(arrC);</span><br></pre></td></tr></table></figure>

<h3 id="229"><a href="#229" class="headerlink" title="229"></a>229</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var t &#x3D; 10;function test(test)&#123;	t &#x3D; t + test;&#x2F;&#x2F;undefined+10&#x3D;NaN    console.log(t);    var t &#x3D; 3;&#125;test(t);console.log(t);答案：NaN 10下列 JavaScript 代码执行后，依次 alert 的结果是var obj &#x3D; &#123;proto: &#123;a:1,b:2&#125;&#125;;function F()&#123;&#125;;F.prototype &#x3D; obj.proto;var f &#x3D; new F();obj.proto.c &#x3D; 3;obj.proto &#x3D; &#123;a:-1, b:-2&#125;;alert(f.a);&#x2F;&#x2F;1alert(f.c);&#x2F;&#x2F;3delete F.prototype[&#39;a&#39;];alert(f.a);&#x2F;&#x2F;undefinedalert(obj.proto.a);&#x2F;&#x2F;-1用 js 实现随机选取 10–100 之间的 10 个数字，存入一个数组，并排序。var iArray &#x3D; [];funtion getRandom(istart, iend)&#123;    var iChoice &#x3D; istart - iend +1;    return Math.floor(Math.random() * iChoice + istart;&#125;for(var i&#x3D;0; i&lt;10; i++)&#123;	iArray.push(getRandom(10,100));&#125;iArray.sort();function bar() &#123;    return foo;    foo &#x3D; 10;    function foo() &#123;&#125;    &#x2F;&#x2F;var foo &#x3D; 11;&#125;alert(typeof bar());&#x2F;&#x2F;&quot;function&quot;&#x2F;&#x2F;console.log(a);&#x2F;&#x2F;是一个函数var a &#x3D; 3;function a()&#123;&#125;console.log(a);&#x2F;&#x2F;&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>

<h3 id="231页面编码和被请求的资源编码如果不一致如何处理？"><a href="#231页面编码和被请求的资源编码如果不一致如何处理？" class="headerlink" title="231页面编码和被请求的资源编码如果不一致如何处理？"></a>231页面编码和被请求的资源编码如果不一致如何处理？</h3><p>对于 ajax 请求传递的参数，如果是 get 请求方式，参数如果传递中文，在有些浏览器 会乱码，不同的浏览器对参数编码的处理方式不同，所以对于 get 请求的参数需要使用 encodeURIComponent 函数对参数进行编码处理，后台开发语言都有相应的解码 api。对于 post 请求不需要 进行编码</p>
<h3 id="234-javascript-的本地对象，内置对象和宿主对象"><a href="#234-javascript-的本地对象，内置对象和宿主对象" class="headerlink" title="234.javascript 的本地对象，内置对象和宿主对象"></a>234.javascript 的本地对象，内置对象和宿主对象</h3><p>本地对象为独立于宿主环境的 ECMAScript 提供的对象，包括 Array Object RegExp 等可以 new 实例化的对象 </p>
<p>内置对象为 Gloal，Math 等不可以实例化的(他们也是本地对象，内置对象是本地对象 的一个子集) </p>
<p>宿主对象为所有的非本地对象，所有的 BOM 和 DOM 对象都是宿主对象，如浏览器自带的 document,window 等对象</p>
<h3 id="236用-js-实现千位分隔符"><a href="#236用-js-实现千位分隔符" class="headerlink" title="236用 js 实现千位分隔符"></a>236用 js 实现千位分隔符</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function format (num) &#123;    var reg&#x3D;&#x2F;\d&#123;1,3&#125;(?&#x3D;(\d&#123;3&#125;)+$)&#x2F;g;     return (num + &#39;&#39;).replace(reg, &#39;$&amp;,&#39;);&#125;function format(num)&#123; num&#x3D;num+&#39;&#39;;&#x2F;&#x2F;数字转字符串  var str&#x3D;&quot;&quot;;&#x2F;&#x2F;字符串累加  for(var i&#x3D;num.length- 1,j&#x3D;1;i&gt;&#x3D;0;i--,j++)&#123;      if(j%3&#x3D;&#x3D;0 &amp;&amp; i!&#x3D;0)&#123;&#x2F;&#x2F;每隔三位加逗号，过滤正好在第一个数字的情况          str+&#x3D;num[i]+&quot;,&quot;;&#x2F;&#x2F;加千分位逗号          continue;      &#125;      str+&#x3D;num[i];&#x2F;&#x2F;倒着累加数字  &#125;  return str.split(&#39;&#39;).reverse().join(&quot;&quot;);&#x2F;&#x2F;字符串&#x3D;&gt;数组&#x3D;&gt;反转&#x3D;&gt;字符串&#125;</span><br></pre></td></tr></table></figure>

<h3 id="242想实现一个对页面某个节点的拖曳？如何做？"><a href="#242想实现一个对页面某个节点的拖曳？如何做？" class="headerlink" title="242想实现一个对页面某个节点的拖曳？如何做？"></a>242想实现一个对页面某个节点的拖曳？如何做？</h3><p>（使用原生 JS） 回答出概念即可，下面是几个要点 </p>
<p>给需要拖拽的节点绑定 mousedown, mousemove, mouseup 事件 </p>
<p>mousedown 事件触发后，开始拖拽 </p>
<p>mousemove 时，需要通过 event.clientX 和 clientY 获取拖拽位置，并实时更新位置 </p>
<p>mouseup 时，拖拽结束 </p>
<p>需要注意浏览器边界的情况</p>
<h3 id="250外部-JS-文件出现中文字符，会出现什么问题，怎么解决？"><a href="#250外部-JS-文件出现中文字符，会出现什么问题，怎么解决？" class="headerlink" title="250外部 JS 文件出现中文字符，会出现什么问题，怎么解决？"></a>250外部 JS 文件出现中文字符，会出现什么问题，怎么解决？</h3><p>会出现乱码，加 charset=”GB2312”</p>
<h3 id="251谈谈浏览器的内核，并且说一下什么是内核？"><a href="#251谈谈浏览器的内核，并且说一下什么是内核？" class="headerlink" title="251谈谈浏览器的内核，并且说一下什么是内核？"></a>251谈谈浏览器的内核，并且说一下什么是内核？</h3><p>浏览器内核又可以分成两部分：渲染引擎和 JS 引擎。它负责取得网页的内容（HTML、XML、 图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。JS 引擎则是解析 Javascript 语言，执行 javascript 语言来实现网页的动态效果</p>
<h3 id="253"><a href="#253" class="headerlink" title="253"></a>253</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(function(x)&#123;    delete x;    alert(x);&#125;)(1+5);函数参数无法 delete 删除，delete 只能删除通过 for in 访问的属性。当然，删除失败也不会报错，所以代码运行会弹出“6”。</span><br></pre></td></tr></table></figure>

<h3 id="254-reduce-汇总：一堆出来一个"><a href="#254-reduce-汇总：一堆出来一个" class="headerlink" title="254 reduce 汇总：一堆出来一个"></a>254 reduce 汇总：一堆出来一个</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [12,69,180,8763];let result &#x3D; arr.reduce(function(temp,item,index)&#123;	&#x2F;&#x2F;temp是中间结果，item是下一个参数，index是索引	alert(temp + ‘,’ + item + ‘,’ + index)&#125;);&#x2F;&#x2F;12,69,1&#x2F;&#x2F;这也是index从1开始的原因&#x2F;&#x2F;undefined,180,2&#x2F;&#x2F;undefined,8763,3let arr &#x3D; [12,69,180,8763];let result &#x3D; arr.reduce(function(temp,item,index)&#123;	return temp + item;&#125;);alert(result);&#x2F;&#x2F;9024&#x2F;&#x2F;12 69 &#x3D;&gt;81&#x2F;&#x2F;81 180 &#x3D;&gt;261&#x2F;&#x2F;261 8763 &#x3D;&gt;9024</span><br></pre></td></tr></table></figure>

<h3 id="255"><a href="#255" class="headerlink" title="255"></a>255</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let json &#x3D; &#123;”a”:12, “b”:5&#125;;let str &#x3D; ‘abc’ + json; alert(str); &#x2F;&#x2F;abc[object Object]let str &#x3D; ‘abc’ + JSON.stringify(json); &#x2F;&#x2F;abc&#123;“a”:12, “b”:5&#125;</span><br></pre></td></tr></table></figure>

<h3 id="256-generator生成器"><a href="#256-generator生成器" class="headerlink" title="256 generator生成器"></a>256 generator生成器</h3><p>是一个特殊一点的函数，generator函数不能写成箭头函数的形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function *show()&#123;&#x2F;&#x2F;三种形式，function *show()或function * show()或function* show()，	&#x2F;&#x2F;但这种*两边都贴上的形式不可以，function*show()	alert(’a’);	yield;&#x2F;&#x2F;放弃,暂时不往下执行	alert(’b’);&#125;&#x2F;&#x2F;show()不会执行&#x2F;&#x2F;因为generator函数不会直接运行函数里面的代码，而是创建了一个generator对象出来let genObj &#x3D; show();alert(genObj);&#x2F;&#x2F;[object Generator]genObj.next();&#x2F;&#x2F;a弹出&#x2F;&#x2F;遇到yield放弃执行下面代码genObj.next();&#x2F;&#x2F;b弹出</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function *show(num1,num2)&#123;	alert(&#96;$&#123;num1&#125;&#96;, &#96;$&#123;num2&#125;&#96;);&#x2F;&#x2F;99,88	alert(’a’);	let a &#x3D; yield;	alert(’b’);	alert(a);&#x2F;&#x2F;5,原因看下图解析，将5直接传给了a&#125;let genObj &#x3D; show(99,88);&#x2F;&#x2F;第一个过程传参和正常函数一样传参genObj.next(12);&#x2F;&#x2F;第一个next对于传参来说是废的，是没有办法给yield传参的genObj.next(5);&#x2F;&#x2F;next里的参数是传给yield的</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function *show()&#123;	alert(’a’);	yield 12;	alert(’b’);&#125;let gen &#x3D; show();let res1 &#x3D; gen.next();console.log(res1);&#x2F;&#x2F;&#123;value:12, done:false&#125;&#x2F;&#x2F;done：false表示还没完成let res2 &#x3D; gen.next();console.log(res2);&#x2F;&#x2F;&#123;value:undefined, done:true&#125;&#x2F;&#x2F;function *show()&#123;	alert(’a’);	yield 12;	alert(’b’);	return 55;&#x2F;&#x2F;最后的结果用return往外给&#125;let gen &#x3D; show();let res1 &#x3D; gen.next();console.log(res1);&#x2F;&#x2F;&#123;value:12, done:false&#125;&#x2F;&#x2F;done：false表示还没完成let res2 &#x3D; gen.next();console.log(res2);&#x2F;&#x2F;&#123;value:55, done:true&#125;</span><br></pre></td></tr></table></figure>

<h3 id="257"><a href="#257" class="headerlink" title="257"></a>257</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let arr &#x3D; [12,4,5];for(let entry of arr.entries())&#123;	alert(entry);&#x2F;&#x2F;循环0,12 1,4 2,5&#125;for(let [key,value] of arr.entries())&#123;	alert(&#96;$&#123;key&#125;&#x3D;$&#123;value&#125;&#96;);	&#x2F;&#x2F;循环0&#x3D;12 1&#x3D;4 2&#x3D;5	&#x2F;&#x2F;也一定程度上解决了values()还不支持的问题&#125;</span><br></pre></td></tr></table></figure>

<h3 id="259创建函数有3种："><a href="#259创建函数有3种：" class="headerlink" title="259创建函数有3种："></a>259创建函数有3种：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1.函数声明function f() &#123;…&#125;2.函数表达式var f &#x3D; function () &#123;…&#125;3.Function构造函数var f &#x3D; new Function(“参数”,”函数体”)&#x2F;&#x2F;这种方式创建的作用域永远指向全局，而不是它的父</span><br></pre></td></tr></table></figure>

<h3 id="260类的继承四部曲："><a href="#260类的继承四部曲：" class="headerlink" title="260类的继承四部曲："></a>260类的继承四部曲：</h3><p>1创建父类以及添加父类的属性和方法</p>
<p>2创建子类</p>
<p>3立即继承</p>
<p>上面实现了继承，但是应该本能地将子类原型的constructor修正回子类的构造函数</p>
<p>4此时再添加子类的属性，</p>
<p>假如3和4颠倒，继承的时候有等号，相当于完完全全把子类重写成了父类的样子</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;&#x2F;&#x2F;创建父类Person.prototype.headCount &#x3D; 1;&#x2F;&#x2F;添加父类属性Person.prototype.eat &#x3D; function()&#123;&#x2F;&#x2F;添加父类方法	console.log(”eating...”);&#125;function Programmer()&#123;&#125;&#x2F;&#x2F;创建子类Programmer.prototype &#x3D; Object.create(Person.prototype);&#x2F;&#x2F;继承aProgrammer.prototype.constructor &#x3D; Programmer;&#x2F;&#x2F;将子类原型的constructor修正回来（本能）aProgrammer.prototype.language &#x3D; “Javascript”;&#x2F;&#x2F;添加子类属性Programmer.prototype.work &#x3D; function()&#123;&#x2F;&#x2F;添加子类方法	console.log(”i am writing code in” + this.language);&#125;var js &#x3D; new Programmer();console.log(js.eat());&#x2F;&#x2F;eating...console.log(js.language);&#x2F;&#x2F;“Javascript”js.language &#x3D; “JS”;console.log(js.language);&#x2F;&#x2F;“JS”console.log(js.work());&#x2F;&#x2F;i am writing code in JS</span><br></pre></td></tr></table></figure>

<h3 id="类的继承四部曲："><a href="#类的继承四部曲：" class="headerlink" title="类的继承四部曲："></a>类的继承四部曲：</h3><p>1创建父类以及添加父类的属性和方法</p>
<p>2创建子类</p>
<p>3立即继承</p>
<p>上面实现了继承，但是应该本能地将子类原型的constructor修正回子类的构造函数</p>
<p>4此时再添加子类的属性，</p>
<p>假如3和4颠倒，继承的时候有等号，相当于完完全全把子类重写成了父类的样子</p>
<p>//举例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function Person()&#123;&#125;&#x2F;&#x2F;创建父类Person.prototype.headCount &#x3D; 1;&#x2F;&#x2F;添加父类属性Person.prototype.eat &#x3D; function()&#123;&#x2F;&#x2F;添加父类方法	console.log(”eating...”);&#125;function Programmer()&#123;&#125;&#x2F;&#x2F;创建子类Programmer.prototype &#x3D; Object.create(Person.prototype);&#x2F;&#x2F;继承aProgrammer.prototype.constructor &#x3D; Programmer;&#x2F;&#x2F;将子类原型的constructor修正回来（本能）aProgrammer.prototype.language &#x3D; “Javascript”;&#x2F;&#x2F;添加子类属性Programmer.prototype.work &#x3D; function()&#123;&#x2F;&#x2F;添加子类方法	console.log(”i am writing code in” + this.language);&#125;var js &#x3D; new Programmer();console.log(js.eat());&#x2F;&#x2F;eating...console.log(js.language);&#x2F;&#x2F;“Javascript”js.language &#x3D; “JS”;console.log(js.language);&#x2F;&#x2F;“JS”console.log(js.work());&#x2F;&#x2F;i am writing code in JS</span><br></pre></td></tr></table></figure>

<h3 id="261多态"><a href="#261多态" class="headerlink" title="261多态"></a>261多态</h3><p>拥有</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function F()&#123;&#125;;var f &#x3D; new F();f.name &#x3D; “cj”;console.log(f.hasOwnProperty(”name”));&#x2F;&#x2F;true&#x2F;&#x2F;是否有F.prototype.age &#x3D; 22;console.log(f.hasOwnProperty(”age”));&#x2F;&#x2F;false&#x2F;&#x2F;f对象和原型对象是两个对象，不存在拥有console.log(Object.hasOwnProperty(f, ”name”));&#x2F;&#x2F;false&#x2F;&#x2F;不要这么用，因为是对象级别的hasOwnPorpertyconsole.log(F.prototype.isPrototypeOf(f));&#x2F;&#x2F;true&#x2F;&#x2F;是否是...的原型console.log(Object.getPrototypeOf(f));&#x2F;&#x2F;F&#123;&#125;&#x2F;&#x2F;找f的原型</span><br></pre></td></tr></table></figure>

<h4 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h4><p>编译时的多态，典型的代表是方法重载（大概意思就是调用一个参数时，就是一个参数的//A方法，调用两个参数时就是两个参数的A方法），编译时就确定了</p>
<p>JS中不允许同名的方法，后者会覆盖前者</p>
<p>arguments，实参的个数，在函数里才会有这个对象，是类似数组的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fucntion demo(a, b)&#123;	console.log(demo.length);&#x2F;&#x2F;形参的个数	console.log(arguments.length);&#x2F;&#x2F;实参的个数&#125;</span><br></pre></td></tr></table></figure>

<h4 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h4><p>运行时多态：重写</p>
<h3 id="262封装"><a href="#262封装" class="headerlink" title="262封装"></a>262封装</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Person ()&#123;</span><br><span class="line">	var age &#x3D; 100;&#x2F;&#x2F;私有成员，外界访问不了</span><br><span class="line">	function pm()&#123;&#x2F;&#x2F;私有成员</span><br><span class="line">		console.log(”private method”);</span><br><span class="line">	&#125;</span><br><span class="line">	this.name &#x3D; name;&#x2F;&#x2F;公有成员</span><br><span class="line">	this.text &#x3D; function()&#123;&#x2F;&#x2F;公有成员</span><br><span class="line">		console.log(”public method”);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>//上面的代码这样写就没有意义了，应该向下面这样写才有意义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Person ()&#123;</span><br><span class="line">	var age &#x3D; 100;</span><br><span class="line">	function pm()&#123;</span><br><span class="line">		console.log(this.name);</span><br><span class="line">	&#125;</span><br><span class="line">	this.name &#x3D; name;&#x2F;&#x2F;公有成员</span><br><span class="line">	this.text &#x3D; function()&#123;&#x2F;&#x2F;公有成员</span><br><span class="line">		console.log(”public method”);</span><br><span class="line">		pm();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">var p1 &#x3D; new Person(”cj”);</span><br><span class="line">console.log(p1.text());&#x2F;&#x2F;public method undefined</span><br><span class="line">&#x2F;&#x2F;因为pm()前面没前缀，所以调用window中的pm(),为undefined</span><br><span class="line">&#x2F;&#x2F;将代码pm()变换为pm.call(this)将this的指向为Person</span><br></pre></td></tr></table></figure>
</html>
    </article>
    <!-- license  -->
    
        <div class="license-wrapper">
            <p>Author：<a href="https://lixins319070033.github.io">Nice</a>
            <p>原文链接：<a href="https://lixins319070033.github.io/2021/10/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">https://lixins319070033.github.io/2021/10/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/</a>
            <p>发表日期：<a href="https://lixins319070033.github.io/2021/10/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">October 24th 2021, 7:48:46 pm</a>
            <p>更新日期：<a href="https://lixins319070033.github.io/2021/10/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/">October 31st 2021, 11:41:56 pm</a>
            <p>版权声明：本文采用<a rel="license noopener" target="_blank" href="http://creativecommons.org/licenses/by-nc/4.0/">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可</p>
        </div>
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
                <div class="nextSlogan">Next Post</div>
                <a href= "/2021/10/24/weka%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8CCBR%E9%9D%9E%E5%81%B6%E7%84%B6%E6%80%A7%E8%A7%84%E5%88%92/" title= "weka软件的使用，CBR非偶然性规划">
                    <div class="nextTitle">weka软件的使用，CBR非偶然性规划</div>
                </a>
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E8%A1%A8-JS/" title= "数据结构与算法--哈希表--JS">
                    <div class="prevTitle">数据结构与算法--哈希表--JS</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- gitalk评论 -->

    <!-- utteranc评论 -->

    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    

    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
    <!-- social  -->
    
    <div class="social">
        
    
        
            
                <a href="mailto:1753304332@qq.com" class="iconfont-archer email" title=email ></a>
            
        
    
        
            
                <a href="https://github.com/LiXinS319070033" class="iconfont-archer github" target="_blank" title=github></a>
            
        
    
        
            
                <span class="iconfont-archer wechat" title=wechat>
                  
                  <img class="profile-qr" src="/weixin.png" />
                </span>
            
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    
        
    

    </div>
    
    <!-- powered by Hexo  -->
    <div class="copyright">
        <span id="hexo-power">Powered by <a href="https://hexo.io/" target="_blank">Hexo</a></span><span class="iconfont-archer power">&#xe635;</span><span id="theme-info">theme <a href="https://github.com/fi3ework/hexo-theme-archer" target="_blank">Archer</a></span>
    </div>
    <!-- 不蒜子  -->
    
    <div class="busuanzi-container">
    
     
    <span id="busuanzi_container_site_pv">PV: <span id="busuanzi_value_site_pv"></span> :)</span>
    
    </div>
    
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:50vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93"><span class="toc-number">1.</span> <span class="toc-text">前端面试题总结</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4%E4%BB%A5%E4%B8%8B%E5%AF%B9-Ajax-%E6%8F%8F%E8%BF%B0%E4%B8%8D%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF-A"><span class="toc-number">1.0.1.</span> <span class="toc-text">4以下对 Ajax 描述不正确的是( A )</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Ajax%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">Ajax原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5typeOf%EF%BC%88null%EF%BC%89-Object"><span class="toc-number">1.0.2.</span> <span class="toc-text">5typeOf（null）&#x2F;&#x2F;Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6alert-null-instanceof-Object-%E8%BF%94%E5%9B%9E%E5%80%BC%E4%B8%BAfalse-null%E8%A1%A8%E7%A4%BA%E4%B8%BA%E7%A9%BA%E7%9A%84%E5%BC%95%E7%94%A8%EF%BC%9Binstanceof-%E8%A1%A8%E7%A4%BA%E6%9F%90%E4%B8%AA%E5%8F%98%E9%87%8F%E6%98%AF%E5%90%A6%E6%98%AF%E6%9F%90%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.0.3.</span> <span class="toc-text">6alert(null instanceof Object); 返回值为false,( null表示为空的引用；instanceof 表示某个变量是否是某个对象的实例)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8HTTP%E7%9A%84GET%E5%92%8CPOST%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.4.</span> <span class="toc-text">8HTTP的GET和POST有什么区别?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9HTTP%E7%8A%B6%E6%80%81%E7%A0%81200%E3%80%81302%E3%80%81401%E3%80%81404%E3%80%81500%E5%88%86%E5%88%AB%E4%BB%A3%E8%A1%A8%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D"><span class="toc-number">1.0.5.</span> <span class="toc-text">9HTTP状态码200、302、401、404、500分别代表什么意思?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E4%B8%8A%E6%9C%89%E5%A4%A7%E9%87%8F%E7%9A%84%E5%9B%BE%E7%89%87%EF%BC%88%E5%A4%A7%E5%9E%8B%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%EF%BC%89%EF%BC%8C%E5%8A%A0%E8%BD%BD%E5%BE%88%E6%85%A2%EF%BC%8C%E4%BD%A0%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9B%BE%E7%89%87%E4%BC%98%E5%8C%96%E8%BF%99%E4%BA%9B%E5%9B%BE%E7%89%87%E7%9A%84%E5%8A%A0%E8%BD%BD%EF%BC%8C%E7%BB%99%E7%94%A8%E6%88%B7%E6%9B%B4%E5%A5%BD"><span class="toc-number">1.0.6.</span> <span class="toc-text">10一个页面上有大量的图片（大型电商网站），加载很慢，你有哪些图片优化这些图片的加载，给用户更好</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14base64%E7%9A%84%E5%8E%9F%E7%90%86%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.0.7.</span> <span class="toc-text">14base64的原理及优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11%E8%AF%B4%E4%B8%80%E8%AF%B4%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.8.</span> <span class="toc-text">11说一说前端性能优化有哪些方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12Vue%E6%9C%89%E5%93%AA%E4%BA%9B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.9.</span> <span class="toc-text">12Vue有哪些生命周期函数?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15%E5%85%B3%E4%BA%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%EF%BC%8C%E4%B8%8B%E5%88%97%E8%AF%B4%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E6%9C%89-%E4%BB%A5%E4%B8%8B%E4%B8%89%E4%B8%AA%E9%83%BD%E6%98%AF%E9%94%99%E7%9A%84"><span class="toc-number">1.0.10.</span> <span class="toc-text">15关于类型转换，下列说法错误的有?以下三个都是错的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16%E8%AF%B7%E5%AE%8C%E6%88%90%E4%BB%A3%E7%A0%81%EF%BC%8C%E7%82%B9%E5%87%BB%E6%8C%89%E9%92%AE%E2%80%9Cbutton%E2%80%9D%E5%90%8E%EF%BC%8C%E4%BB%A5%E5%BC%B9%E7%AA%97%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%BE%E7%A4%BA%E6%8C%89%E9%92%AE%E2%80%9Cbutton%E2%80%9D%E7%9A%84%E5%80%BC"><span class="toc-number">1.0.11.</span> <span class="toc-text">16请完成代码，点击按钮“button”后，以弹窗的方式显示按钮“button”的值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17%E5%AE%8C%E6%88%90function-a-%E4%BB%A3%E7%A0%81%EF%BC%8C%E5%AE%9E%E7%8E%B0%E7%82%B9%E5%87%BB%E2%80%9C%E8%BF%99%E6%98%AF%E7%AC%ACN%E6%9D%A1%E2%80%9D%E5%88%97%E8%A1%A8%E9%A1%B9%E7%9A%84%E6%97%B6%E5%80%99alert-n-n-gt-0-amp-amp-n-lt-2"><span class="toc-number">1.0.12.</span> <span class="toc-text">17完成function a()代码，实现点击“这是第N条”列表项的时候alert n (n &gt;&#x3D; 0 &amp;&amp; n &lt;&#x3D; 2)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18%E8%AF%B7%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAJavaScript%E5%87%BD%E6%95%B0parseQueryString%EF%BC%8C%E6%8A%8AURL%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%90%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%8Cvar-url-%E2%80%9Chttp-witmax-cn-index-php-key0-0-amp-key1-1-amp-key2-2-quot"><span class="toc-number">1.0.13.</span> <span class="toc-text">18请编写一个JavaScript函数parseQueryString，把URL参数解析为一个对象，var url &#x3D; “http:&#x2F;&#x2F;witmax.cn&#x2F;index.php?key0&#x3D;0&amp;key1&#x3D;1&amp;key2&#x3D;2&quot;;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F-%E4%B8%89%E7%A7%8D%E4%BB%A5%E4%B8%8A%EF%BC%88%E8%80%83%E8%99%91%E5%88%B0%E5%85%BC%E5%AE%B9%E6%80%A7%E7%9A%84%E8%AF%9D%E7%94%A8%E5%93%AA%E7%A7%8D%EF%BC%89"><span class="toc-number">1.0.14.</span> <span class="toc-text">21有哪些方法可以解决跨域?三种以上（考虑到兼容性的话用哪种）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21%E8%A1%A5-vue%E5%92%8Creact%E5%86%85%E9%83%A8%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%E7%9A%84%EF%BC%9Freact%E9%92%A9%E5%AD%90%E7%9A%84%E7%8A%B6%E6%80%81%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.15.</span> <span class="toc-text">*21补 vue和react内部是怎么实现数据的双向绑定的？react钩子的状态的实现???</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#React%E5%B9%B6%E6%B2%A1%E6%9C%89%E8%87%AA%E5%B8%A6%E7%9A%84%E5%8F%8C%E5%90%91%E7%BB%91%E5%AE%9A%EF%BC%8C%E9%9C%80%E8%A6%81%E8%87%AA%E5%B7%B1%E5%AE%9E%E7%8E%B0%EF%BC%8C%E7%BB%93%E5%90%88setState-%E4%BB%A5%E5%8F%8AonChange%E4%BA%8B%E4%BB%B6%E6%9D%A5%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%AF%8F%E6%AC%A1%E6%96%87%E6%9C%AC%E6%A1%86%E6%94%B9%E5%8F%98%E6%96%87%E6%9C%AC%EF%BC%88%E5%8D%B3%E8%A7%A6%E5%8F%91onChange%E4%BA%8B%E4%BB%B6%EF%BC%89%EF%BC%8C%E5%B0%B1%E4%BD%BF%E7%94%A8setState-%E6%94%B9%E5%8F%98state%E6%95%B0%E6%8D%AE"><span class="toc-number">1.0.15.1.</span> <span class="toc-text">React并没有自带的双向绑定，需要自己实现，结合setState()以及onChange事件来实现，每次文本框改变文本（即触发onChange事件），就使用setState()改变state数据</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#99Vue-%E5%92%8C-React-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.16.</span> <span class="toc-text">99Vue 和 React 之间的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#102%E5%8F%91%E5%B8%83-%E8%AE%A2%E9%98%85%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.17.</span> <span class="toc-text">102发布-订阅模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22%E5%87%BD%E6%95%B0%E7%9A%84%E5%93%AA%E4%BA%9B%E5%8E%9F%E7%94%9F%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E6%94%B9%E5%8F%98%E5%85%B6%E6%89%A7%E8%A1%8C%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87-call-apply-bind"><span class="toc-number">1.0.18.</span> <span class="toc-text">22函数的哪些原生方法可以改变其执行的上下文 call apply bind</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-ES6%E6%96%B0%E5%A2%9E%E4%BA%86%E5%93%AA%E4%BA%9B%E7%89%B9%E6%80%A7%E8%87%B3%E5%B0%91%E4%BA%94%E4%B8%AA"><span class="toc-number">1.0.19.</span> <span class="toc-text">25 ES6新增了哪些特性至少五个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26%E6%B5%85%E6%8B%B7%E8%B4%9D"><span class="toc-number">1.0.20.</span> <span class="toc-text">26浅拷贝</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E6%8B%B7%E8%B4%9D%EF%BC%88%E9%81%8D%E5%8E%86%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%94%A8for-in%EF%BC%89"><span class="toc-number">1.0.21.</span> <span class="toc-text">深拷贝（遍历一个对象用for in）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#111%E6%89%81%E5%B9%B3%E5%8C%96%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.22.</span> <span class="toc-text">111扁平化数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27%E8%AF%B7%E5%9F%BA%E4%BA%8Evue%E6%A1%86%E6%9E%B6%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%88%B6%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E5%AD%90%E7%BB%84%E4%BB%B6%E6%96%B9%E6%B3%95%E7%9A%84%E7%A4%BA%E4%BE%8B"><span class="toc-number">1.0.23.</span> <span class="toc-text">27请基于vue框架，实现一个父组件调用子组件方法的示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29%E8%AF%B7%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%95%B0%E7%BB%84-a-2-a-1-a-0-a-10-a-2-1-%E6%8C%89%E5%B1%9E%E6%80%A7a%E4%BB%8E%E5%B0%8F%E5%88%B0%E5%A4%A7%E6%8E%92%E5%BA%8F%E3%80%82"><span class="toc-number">1.0.24.</span> <span class="toc-text">29请实现对数组[{a:2},{a:1},{a:0},{a:10},{a:2.1}]按属性a从小到大排序。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#js%E5%AE%9E%E7%8E%B0%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D"><span class="toc-number">1.0.25.</span> <span class="toc-text">js实现二维数组去重</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E2%BD%85%E6%B3%95%E6%80%BB%E7%BB%93"><span class="toc-number">1.0.25.1.</span> <span class="toc-text">数组去重⽅法总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#32%E4%BD%BF%E7%94%A8setTimeout%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAsetInterval%E7%9A%84%E5%8A%9F%E8%83%BD"><span class="toc-number">1.0.26.</span> <span class="toc-text">32使用setTimeout模拟实现一个setInterval的功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E8%AF%B7%E5%86%99%E5%87%BAReact16%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%8C%E8%87%B3%E5%B0%91%E4%BA%94%E4%B8%AA"><span class="toc-number">1.0.27.</span> <span class="toc-text">34请写出React16的新特性，至少五个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35%E8%AF%B7%E7%AE%80%E8%BF%B0display-none%E5%92%8Cvisibility-hidden%E5%AF%B9%E6%AF%94%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.0.28.</span> <span class="toc-text">35请简述display: none和visibility: hidden对比的优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#36%E4%BB%8B%E7%BB%8D%E4%B8%8Bvuex%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">1.0.29.</span> <span class="toc-text">36介绍下vuex以及应用的场景***</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39%E9%97%AD%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E6%80%A7-%E8%AF%B7%E7%AE%80%E5%8D%95%E4%B9%A6%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.0.30.</span> <span class="toc-text">39闭包是什么,有什么特性,请简单书写一个简单实例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#40ES5-%E7%9A%84%E7%BB%A7%E6%89%BF%E5%92%8C-ES6-%E7%9A%84%E7%BB%A7%E6%89%BF%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB-%EF%BC%9F"><span class="toc-number">1.0.31.</span> <span class="toc-text">40ES5 的继承和 ES6 的继承有什么区别 ？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#107vue-router"><span class="toc-number">1.0.32.</span> <span class="toc-text">107vue-router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1hash-history%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.33.</span> <span class="toc-text">84动态路由hash history区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E6%80%8E%E4%B9%88%E5%AE%9A%E4%B9%89vue-router%E7%9A%84%E5%8A%A8%E6%80%81%E8%B7%AF%E7%94%B1-%E6%80%8E%E4%B9%88%E8%8E%B7%E5%8F%96%E4%BC%A0%E8%BF%87%E6%9D%A5%E7%9A%84%E5%8A%A8%E6%80%81%E5%8F%82%E6%95%B0"><span class="toc-number">1.0.34.</span> <span class="toc-text">41怎么定义vue-router的动态路由?怎么获取传过来的动态参数?</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44vue-router%E6%9C%89%E5%93%AA%E5%87%A0%E7%A7%8D%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%EF%BC%8C%E5%AF%BC%E8%88%AA%E9%92%A9%E5%AD%90%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.35.</span> <span class="toc-text">44vue-router有哪几种导航钩子，导航钩子的作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#93%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEReact-Router"><span class="toc-number">1.0.36.</span> <span class="toc-text">93如何配置React-Router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#96react-router%E2%BE%A5%E7%9A%84-lt-Link-gt-%E6%A0%87%E7%AD%BE%E5%92%8C-lt-a-gt-%E6%A0%87%E7%AD%BE%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.37.</span> <span class="toc-text">96react-router⾥的&lt;Link&gt;标签和&lt;a&gt;标签有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42Vue%E5%BC%95%E5%85%A5%E4%BA%86%E8%99%9A%E6%8B%9FDom%E4%B8%BB%E8%A6%81%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.38.</span> <span class="toc-text">42Vue引入了虚拟Dom主要解决了什么问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">1.0.39.</span> <span class="toc-text">43输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45vue-loader%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BD%BF%E7%94%A8%E5%AE%83%E7%9A%84%E9%80%94%E5%BE%84%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.0.40.</span> <span class="toc-text">45vue-loader是什么？使用它的途径有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30%E8%AF%B7%E5%86%99%E5%87%BA%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E5%85%83%E7%B4%A0%E7%9A%84%E5%87%A0%E7%A7%8D%E5%8E%9F%E7%94%9F%E7%AE%97%E6%B3%95"><span class="toc-number">1.0.41.</span> <span class="toc-text">30请写出删除数组元素的几种原生算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#46delete%E5%92%8CVue-delete%E5%88%A0%E9%99%A4%E6%95%B0%E7%BB%84%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.42.</span> <span class="toc-text">46delete和Vue.delete删除数组的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50%E4%BD%BF%E7%94%A8%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E6%88%96%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%E5%AF%B9%E6%95%B0%E7%BB%84let-arr-3-5-1-9-4-2-%E8%BF%9B%E8%A1%8C%E6%8E%92%E5%BA%8F"><span class="toc-number">1.0.43.</span> <span class="toc-text">50使用选择排序或冒泡排序方法对数组let arr &#x3D; [3, 5, 1, 9, 4, 2]进行排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BVue%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.0.44.</span> <span class="toc-text">52介绍一下Vue组件的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53%E4%BD%BF%E7%94%A8CSS%E7%9A%84flexbox%E5%B8%83%E5%B1%80%EF%BC%8C%E4%B8%8D%E8%83%BD%E5%AE%9E%E7%8E%B0%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%B8%80%E4%B8%AA%E6%95%88%E6%9E%9C%EF%BC%9A"><span class="toc-number">1.0.45.</span> <span class="toc-text">53使用CSS的flexbox布局，不能实现以下哪一个效果：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#54%E4%B8%8B%E9%9D%A2%E5%85%B3%E4%BA%8Ethis%E7%9A%84%E8%AF%B4%E6%B3%95%E9%94%99%E8%AF%AF%E7%9A%84%E6%98%AFA"><span class="toc-number">1.0.46.</span> <span class="toc-text">54下面关于this的说法错误的是A</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#55new-Date-%E2%80%98yyyy-mm-dd%E2%80%99-%E8%BF%94%E5%9B%9E%E6%9C%AC%E5%9C%B0%E6%97%B6%E9%97%B4%EF%BC%8Cnew-Date-%E2%80%98yyyy-mm-dd%E2%80%99-%E8%BF%94%E5%9B%9EUTC%E6%97%B6%E9%97%B4"><span class="toc-number">1.0.47.</span> <span class="toc-text">55new Date(‘yyyy-mm-dd’)返回本地时间，new Date(‘yyyy&#x2F;mm&#x2F;dd’)返回UTC时间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#56%E8%BF%94%E5%9B%9Ea1-undefined-a2"><span class="toc-number">1.0.48.</span> <span class="toc-text">56返回a1 undefined a2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#57"><span class="toc-number">1.0.49.</span> <span class="toc-text">57</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#58ES6%E5%86%85%E9%83%A8%E4%BD%BF%E7%94%A8%E4%B8%A5%E6%A0%BC%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6%EF%BC%88-%EF%BC%89%EF%BC%8C%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E4%BD%8D%E7%BD%AE%E6%98%AF%E5%90%A6%E6%9C%89%E5%80%BC%E3%80%82%E6%89%80%E4%BB%A5%EF%BC%8C%E5%A6%82%E6%9E%9C%E4%B8%80%E4%B8%AA%E6%95%B0%E7%BB%84%E6%88%90%E5%91%98%E4%B8%8D%E4%B8%A5%E6%A0%BC%E7%AD%89%E4%BA%8Eundefined%EF%BC%8C%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF%E4%B8%8D%E4%BC%9A%E7%94%9F%E6%95%88%E7%9A%84%E3%80%82"><span class="toc-number">1.0.50.</span> <span class="toc-text">58ES6内部使用严格相等运算符（&#x3D;&#x3D;&#x3D;），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#59%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E3%80%81%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%E3%80%81%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.0.51.</span> <span class="toc-text">59冒泡排序、选择排序、快速排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#60div%E5%B5%8C%E5%A5%97%EF%BC%8C%E5%B1%85%E4%B8%AD%E5%B8%83%E5%B1%80%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%8C%E5%90%84%E8%87%AA%E7%9A%84%E9%80%82%E5%90%88%E8%8C%83%E5%9B%B4%E5%92%8C%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.52.</span> <span class="toc-text">60div嵌套，居中布局有几种方式，各自的适合范围和问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E5%A6%82%E4%BD%95%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD%E2%BC%80%E4%B8%AA%E6%B5%AE%E5%8A%A8%E5%85%83%E7%B4%A0-%EF%BC%9F"><span class="toc-number">1.0.53.</span> <span class="toc-text">20 如何垂直居中⼀个浮动元素***？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-number">1.0.53.0.1.</span> <span class="toc-text">水平居中</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">1.0.53.0.2.</span> <span class="toc-text">垂直居中</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#62http%E8%BF%94%E5%9B%9E%E7%9A%84%E7%8A%B6%E6%80%81%E6%9C%89%E5%87%A0%E7%A7%8D%EF%BC%8C403%E3%80%81401%E3%80%81302%E3%80%81304"><span class="toc-number">1.0.54.</span> <span class="toc-text">62http返回的状态有几种，403、401、302、304</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64%E8%BE%93%E5%85%A51%E8%BF%94%E5%9B%9E2%EF%BC%8C%E8%BE%93%E5%85%A52%E8%BF%94%E5%9B%9E1%EF%BC%8C%E6%9C%89%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.55.</span> <span class="toc-text">64输入1返回2，输入2返回1，有几种方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#65%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95%EF%BC%8C%E4%BD%BF%E7%94%A8%E8%8C%83%E5%9B%B4%EF%BC%8C%E5%B7%A6%E4%BE%A7200px%EF%BC%8C%E5%8F%B3%E4%BE%A7%E8%87%AA%E9%80%82%E5%BA%94"><span class="toc-number">1.0.56.</span> <span class="toc-text">65自适应布局几种方法，使用范围，左侧200px，右侧自适应</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71sort%E6%8E%92%E5%BA%8F"><span class="toc-number">1.0.57.</span> <span class="toc-text">71sort排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79%E4%B8%8D%E7%94%A8%E7%BB%84%E4%BB%B6%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E8%BD%AE%E6%92%AD%E5%9B%BE%EF%BC%8C%E5%BD%93%E9%BC%A0%E6%A0%87%E5%81%9C%E7%95%99%E5%9C%A8%E5%9B%BE%E7%89%87%E4%B8%8A%E6%97%B6%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E8%BD%AE%E6%92%AD%E4%B8%8D%E5%8A%A8"><span class="toc-number">1.0.58.</span> <span class="toc-text">79不用组件怎么实现轮播图，当鼠标停留在图片上时怎么实现图片轮播不动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80v-if-v-show-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.59.</span> <span class="toc-text">80v-if v-show 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#81key%E4%BD%9C%E7%94%A8"><span class="toc-number">1.0.60.</span> <span class="toc-text">81key作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#85-%E9%83%BD%E6%9C%89%E5%93%AA%E4%BA%9B%E6%8C%87%E4%BB%A4"><span class="toc-number">1.0.61.</span> <span class="toc-text">85 都有哪些指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#86%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.62.</span> <span class="toc-text">86如何判断类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87%E7%BD%AE%E6%8D%A2%E5%85%83%E7%B4%A0-%E5%93%88%E5%B8%8C-require-js-common-js-AMD-CMD"><span class="toc-number">1.0.63.</span> <span class="toc-text">87置换元素  哈希  require.js common.js AMD CMD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#88%E5%AF%B9async%E3%80%81await%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%8C%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86"><span class="toc-number">1.0.64.</span> <span class="toc-text">88对async、await的理解，内部原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#91redux%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3-%E6%8E%A5%E2%BC%8Aredux%E7%9A%84%E8%BF%87%E7%A8%8B-%E7%BB%91%E5%AE%9Aconnect%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">1.0.65.</span> <span class="toc-text">91redux的设计思想 接⼊redux的过程 绑定connect的过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92webpack%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.0.66.</span> <span class="toc-text">92webpack介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#95promise%E3%80%81async%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.67.</span> <span class="toc-text">95promise、async有什么区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#97cookie%E6%94%BE%E5%93%AA%E2%BE%A5"><span class="toc-number">1.0.68.</span> <span class="toc-text">97cookie放哪⾥</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#103-es5%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A0%81%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.69.</span> <span class="toc-text">103 es5异步编码的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#es6"><span class="toc-number">1.0.69.1.</span> <span class="toc-text">es6</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104js%E5%B8%B8%E8%A7%81%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F"><span class="toc-number">1.0.70.</span> <span class="toc-text">104js常见的内存泄漏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-number">1.0.71.</span> <span class="toc-text">105前端工程化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#106%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.72.</span> <span class="toc-text">106函数调用的方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#108%E5%8A%A8%E7%94%BB%E7%9A%84%E4%BE%8B%E5%AD%90%EF%BC%8C%E5%A5%BD%E5%A5%BD%E7%9C%8B%E4%B8%80%E4%B8%8B%EF%BC%8C%E4%BC%9A%E6%89%8B%E5%86%99"><span class="toc-number">1.0.73.</span> <span class="toc-text">108动画的例子，好好看一下，会手写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#110"><span class="toc-number">1.0.74.</span> <span class="toc-text">110</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#113vue%E6%A8%A1%E6%9D%BF%E8%AF%AD%E6%B3%95%E5%BA%95%E5%B1%82%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">1.0.75.</span> <span class="toc-text">113vue模板语法底层是怎么实现的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#114-vue%E4%B8%ADaction%E5%92%8Cmutation%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.76.</span> <span class="toc-text">114 vue中action和mutation的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#115https%E6%98%AF%E6%80%8E%E4%B9%88%E5%8A%A0%E5%AF%86%E7%9A%84"><span class="toc-number">1.0.77.</span> <span class="toc-text">115https是怎么加密的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#116-rem-em%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%EF%BC%88%E7%9C%8B%E4%B9%A6%EF%BC%89"><span class="toc-number">1.0.78.</span> <span class="toc-text">116 rem em相关知识（看书）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#117url%E9%A1%B5%E9%9D%A2%E6%B5%81%E7%A8%8B"><span class="toc-number">1.0.79.</span> <span class="toc-text">117url页面流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#118-vue%E4%B8%ADnextTick-process-nextTick"><span class="toc-number">1.0.80.</span> <span class="toc-text">118 vue中nextTick()   process.nextTick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#119HTTP-2-0"><span class="toc-number">1.0.81.</span> <span class="toc-text">119HTTP &#x2F; 2.0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#120%E6%9F%A5%E6%89%BE%E4%B8%A4%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E4%B8%B2%E7%9A%84JavaScript%E5%87%BD%E6%95%B0"><span class="toc-number">1.0.82.</span> <span class="toc-text">120查找两个字符串的最长公共子串的JavaScript函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#121"><span class="toc-number">1.0.83.</span> <span class="toc-text">121</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#122%E5%93%AA%E4%BA%9B%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95%E6%94%B9%E5%8F%98%E8%87%AA%E8%BA%AB%E6%95%B0%E7%BB%84%EF%BC%9Asplice-sort-pop-push"><span class="toc-number">1.0.84.</span> <span class="toc-text">122哪些数组方法改变自身数组：splice sort pop push</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%AA%E4%BA%9B%E4%B8%8D%E6%94%B9%E5%8F%98%EF%BC%9Aconcat"><span class="toc-number">1.0.85.</span> <span class="toc-text">哪些不改变：concat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#124%E5%AF%B9%E4%BA%8E%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%EF%BC%8CObject-defineProperty-%E6%9C%89%E4%BB%80%E4%B9%88%E7%BC%BA%E7%82%B9%EF%BC%9F%E6%9C%89%E6%B2%A1%E6%9C%89%E6%9B%B4%E5%A5%BD%E7%9A%84%E6%96%B9%E6%B3%95%E6%9D%A5%E5%AE%9E%E7%8E%B0%EF%BC%9F"><span class="toc-number">1.0.86.</span> <span class="toc-text">124对于实现双向数据绑定，Object.defineProperty()有什么缺点？有没有更好的方法来实现？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#129%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AA%E7%9F%A9%E5%BD%A2%E7%B1%BBRectangle%EF%BC%8C%E5%AE%83%E6%98%AF%E7%94%B1%E5%AE%BDwidth%E5%92%8C%E9%95%BFheight%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E6%9E%84%E9%80%A0%E7%9A%84%EF%BC%8C%E7%84%B6%E5%90%8E%E5%9C%A8%E7%B1%BB%E4%B8%AD%E5%AE%9A%E4%B9%89%E4%B8%80%E4%B8%AAgetArea-%E6%96%B9%E6%B3%95%EF%BC%8C%E7%94%A8%E6%9D%A5%E8%AE%A1%E7%AE%97%E7%9F%A9%E5%BD%A2%E7%9A%84%E9%9D%A2%E7%A7%AF%E3%80%82"><span class="toc-number">1.0.86.1.</span> <span class="toc-text">129定义一个矩形类Rectangle，它是由宽width和长height两个参数构造的，然后在类中定义一个getArea()方法，用来计算矩形的面积。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#130vue%E7%9A%84%E4%BD%9C%E7%94%A8%E5%92%8C%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-number">1.0.87.</span> <span class="toc-text">130vue的作用和核心功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#132URL-URI%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.88.</span> <span class="toc-text">132URL URI区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#133ajax%E8%BF%87%E7%A8%8B%EF%BC%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">1.0.89.</span> <span class="toc-text">133ajax过程，代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#134-email%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.0.90.</span> <span class="toc-text">134 email正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#137-UDP%E5%92%8CTCP%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.91.</span> <span class="toc-text">137 UDP和TCP的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#138%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0%E6%95%B0%E7%BB%84-nums-%E5%92%8C%E4%B8%80%E4%B8%AA%E7%9B%AE%E6%A0%87%E5%80%BC-target%EF%BC%8C%E8%AF%B7%E4%BD%A0%E5%9C%A8%E8%AF%A5%E6%95%B0%E7%BB%84%E4%B8%AD%E6%89%BE%E5%87%BA%E5%92%8C%E4%B8%BA%E7%9B%AE%E6%A0%87%E5%80%BC%E7%9A%84%E9%82%A3%E4%B8%A4%E4%B8%AA%E6%95%B4%E6%95%B0%EF%BC%8C%E5%B9%B6%E8%BF%94%E5%9B%9E%E4%BB%96%E4%BB%AC%E7%9A%84%E6%95%B0%E7%BB%84%E4%B8%8B%E6%A0%87"><span class="toc-number">1.0.92.</span> <span class="toc-text">138给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#140-react%E4%B8%ADpureComponent%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8C%E5%A4%84%E7%90%86%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E7%94%A8%E4%BB%80%E4%B9%88%EF%BC%88react-thunk%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%8Cdispatch%E7%9A%84%E5%8D%87%E7%BA%A7%EF%BC%89"><span class="toc-number">1.0.93.</span> <span class="toc-text">140 react中pureComponent的作用，处理异步操作用什么（react-thunk的作用，dispatch的升级）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#141-vue%E4%B8%AD%E7%88%B6beforeCreate-gt-%E7%88%B6created-gt-%E7%88%B6beforeMount-gt-%E5%AD%90beforeCreate-gt-%E5%AD%90created-gt-%E5%AD%90beforeMount-gt-%E5%AD%90mounted-gt-%E7%88%B6mounted"><span class="toc-number">1.0.94.</span> <span class="toc-text">141 vue中父beforeCreate-&gt;父created-&gt;父beforeMount-&gt;子beforeCreate-&gt;子created-&gt;子beforeMount-&gt;子mounted-&gt;父mounted</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142-max-age-0"><span class="toc-number">1.0.95.</span> <span class="toc-text">142 max-age&#x3D;0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#144%E9%97%AD%E5%8C%85%E7%9A%84%E5%A5%BD%E5%A4%84"><span class="toc-number">1.0.96.</span> <span class="toc-text">144闭包的好处</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">1.0.96.1.</span> <span class="toc-text">闭包的注意事项：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#145this"><span class="toc-number">1.0.97.</span> <span class="toc-text">145this</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#call%E5%92%8Capply%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.0.97.1.</span> <span class="toc-text">call和apply的区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#146%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%9A%E5%8E%BB%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E8%BF%9E%E7%BB%AD%E9%87%8D%E5%A4%8D%E5%AD%97%E6%AF%8D"><span class="toc-number">1.0.98.</span> <span class="toc-text">146算法题：去除字符串中的连续重复字母</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#147js-%E4%B8%8D%E5%A2%9E%E5%8A%A0%E5%8F%98%E9%87%8F%EF%BC%8C%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%8F%98%E9%87%8F%E5%80%BC%E7%9A%84%E4%BA%92%E6%8D%A2"><span class="toc-number">1.0.99.</span> <span class="toc-text">147js 不增加变量，怎么实现两个变量值的互换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#148js%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.100.</span> <span class="toc-text">148js中的基本类型与包装类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#149-document-write-eval-%E2%80%9C2-2%E2%80%9D-4"><span class="toc-number">1.0.101.</span> <span class="toc-text">149 document.write(eval(“2+2”))&#x2F;&#x2F;4</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#150-%E5%9F%9F%E5%90%8D%E5%88%86%E5%8F%91"><span class="toc-number">1.0.102.</span> <span class="toc-text">150 域名分发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#151%E8%87%AA%E9%80%82%E5%BA%94%E5%B8%83%E5%B1%80%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.103.</span> <span class="toc-text">151自适应布局的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#152%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F"><span class="toc-number">1.0.104.</span> <span class="toc-text">152数组乱序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#153%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-number">1.0.105.</span> <span class="toc-text">153输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#154"><span class="toc-number">1.0.106.</span> <span class="toc-text">154</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#155-http%E4%B8%ADput%E5%92%8Cpatch%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.107.</span> <span class="toc-text">155 http中put和patch的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#156"><span class="toc-number">1.0.108.</span> <span class="toc-text">156</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#157typeof-typeof-123-%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AFstring%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.109.</span> <span class="toc-text">157typeof typeof 123 返回的是string类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#158getElementById-%E8%BF%94%E5%9B%9E%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.0.110.</span> <span class="toc-text">158getElementById()返回的是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#159-ts-js-TypeScript%E5%92%8CJavaScript%E7%9A%84%E5%AF%B9%E6%AF%94%EF%BC%9A"><span class="toc-number">1.0.111.</span> <span class="toc-text">159 ts js TypeScript和JavaScript的对比：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#160%E5%B0%86%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E7%9A%84%E6%95%B0%E7%BB%84%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84"><span class="toc-number">1.0.112.</span> <span class="toc-text">160将两个有序的数组合并成一个有序数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23%E8%AF%B7%E7%AE%80%E8%BF%B0%E6%95%B0%E7%BB%84%E7%9A%84%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%E8%AF%BB%E5%86%99%E4%B8%8E%E6%96%B0%E5%A2%9E%E7%9A%84%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94"><span class="toc-number">1.0.113.</span> <span class="toc-text">23请简述数组的基础操作读写与新增的性能对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#161%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E9%9C%80%E8%A6%81%E8%BD%AC%E4%B9%89%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="toc-number">1.0.114.</span> <span class="toc-text">161正则表达式需要转义的字符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#162-Tab%E9%80%89%E9%A1%B9%E5%8D%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%E3%80%81flex%E7%9F%A5%E8%AF%86%E3%80%81%E6%87%92%E5%8A%A0%E8%BD%BD%E3%80%81%E5%90%B8%E9%A1%B6%E5%8A%9F%E8%83%BD"><span class="toc-number">1.0.115.</span> <span class="toc-text">162 Tab选项卡的实现、flex知识、懒加载、吸顶功能</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.0.115.0.1.</span> <span class="toc-text">图片懒加载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%B8%E9%A1%B6%E5%8A%9F%E8%83%BD"><span class="toc-number">1.0.115.0.2.</span> <span class="toc-text">吸顶功能</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#163Object-assign%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.116.</span> <span class="toc-text">163Object.assign实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#164"><span class="toc-number">1.0.117.</span> <span class="toc-text">164</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#165"><span class="toc-number">1.0.118.</span> <span class="toc-text">165</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#166%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E5%85%B7%E4%BD%93%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="toc-number">1.0.119.</span> <span class="toc-text">166冒泡排序具体的次数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#167%E5%8E%9F%E7%94%9FindexOf%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.120.</span> <span class="toc-text">167原生indexOf的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#168"><span class="toc-number">1.0.121.</span> <span class="toc-text">168</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#169"><span class="toc-number">1.0.122.</span> <span class="toc-text">169</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#170"><span class="toc-number">1.0.123.</span> <span class="toc-text">170</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#171%E8%AF%B7%E7%94%A8%E5%8E%9F%E7%94%9F-js-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0-%E7%BB%99%E9%A1%B5%E9%9D%A2%E5%88%B6%E5%AE%9A%E7%9A%84%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E5%85%83%E7%B4%A0%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E9%80%8F%E6%98%8E%E9%81%AE%E7%BD%A9-%E9%80%8F%E6%98%8E%E5%BA%A6%E5%8F%AF%E5%8F%98-%E9%BB%98%E8%AE%A4-0-2-%E4%BD%BF%E8%BF%99%E4%B8%AA%E5%8C%BA%E5%9F%9F%E7%82%B9%E5%87%BB%E6%97%A0%E6%95%88-%E8%A6%81%E6%B1%82%E5%85%BC%E5%AE%B9-IE8-%E5%8F%8A%E5%90%84%E4%B8%BB%E6%B5%81%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">1.0.124.</span> <span class="toc-text">171请用原生 js 实现一个函数,给页面制定的任意一个元素添加一个透明遮罩(透明度可变,默认 0.2),使这个区域点击无效,要求兼容 IE8+及各主流浏览器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#172"><span class="toc-number">1.0.125.</span> <span class="toc-text">172</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#173%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.0.126.</span> <span class="toc-text">173斐波那契数列的其他实现形式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#174%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E7%9A%84%E6%9C%80%E5%A4%A7%E5%85%AC%E7%BA%A6%E6%95%B0"><span class="toc-number">1.0.127.</span> <span class="toc-text">174求两个数的最大公约数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#175vue%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.128.</span> <span class="toc-text">175vue中的异步操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72add-1-2-3-4-10"><span class="toc-number">1.0.129.</span> <span class="toc-text">72add(1)(2)(3)(4) &#x3D;&#x3D; 10</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E2%80%9C1%E2%80%9D-%E2%80%9D2%E2%80%9D-%E2%80%9D3%E2%80%9D-map-parseInt-%E7%BB%93%E6%9E%9C"><span class="toc-number">1.0.130.</span> <span class="toc-text">3 [“1”,”2”,”3”].map(parseInt)结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E5%9C%A8%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8js%E7%9B%B4%E6%8E%A5%E8%AE%A1%E7%AE%970-1-0-2%E7%9A%84%E5%80%BC%E6%97%B6%EF%BC%8C%E5%BE%97%E5%88%B0%E7%9A%84%E7%BB%93%E6%9E%9C%E4%B8%BA0-30000000000000004%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E5%86%99%E4%BB%A3%E7%A0%81%E6%89%8D%E8%83%BD%E9%81%BF%E5%85%8D%E8%AF%A5%E6%83%85%E5%86%B5%EF%BC%88%E8%AF%B7%E5%86%99%E5%87%BA%E4%BB%A3%E7%A0%81%EF%BC%89%EF%BC%9F"><span class="toc-number">1.0.131.</span> <span class="toc-text">19在前端使用js直接计算0.1+0.2的值时，得到的结果为0.30000000000000004，为什么，如何写代码才能避免该情况（请写出代码）？</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B1%82%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AF%B9%E7%9A%84%E5%92%8C%EF%BC%88%E6%95%B4%E6%95%B0%E6%88%96%E6%B5%AE%E7%82%B9%E6%95%B0%EF%BC%89"><span class="toc-number">1.0.131.0.1.</span> <span class="toc-text">求两个数对的和（整数或浮点数）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#176-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E5%90%8E%E7%A9%BA%E4%BD%8D%E7%9A%84%E5%88%A0%E9%99%A4%EF%BC%8Ctirm%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.0.132.</span> <span class="toc-text">176 字符串前后空位的删除，tirm方法的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#109-%E6%AF%8F%E9%9A%94%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E5%87%BD%E6%95%B0%EF%BC%8C%E6%89%A7%E8%A1%8C%E6%AC%A1%E6%95%B0%E4%B8%80%E5%AE%9A"><span class="toc-number">1.0.133.</span> <span class="toc-text">109 每隔一段时间执行一次函数，执行次数一定</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#177css3%E4%B8%8D%E9%9C%80%E8%A6%81%E5%9B%9E%E6%B5%81%E5%92%8C%E9%87%8D%E7%BB%98%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%9A"><span class="toc-number">1.0.134.</span> <span class="toc-text">177css3不需要回流和重绘的属性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#179"><span class="toc-number">1.0.135.</span> <span class="toc-text">179</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#180"><span class="toc-number">1.0.136.</span> <span class="toc-text">180</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#181reverse-%E6%98%AF%E9%A2%A0%E5%80%92%E6%95%B0%E7%BB%84%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">1.0.137.</span> <span class="toc-text">181reverse()是颠倒数组的方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD%E8%A1%A8%E7%A4%BA%E4%BC%A0%E5%85%A5%E7%9A%84%E5%8F%82%E6%95%B0%E4%B8%8D%E5%90%8C"><span class="toc-number">1.0.138.</span> <span class="toc-text">方法重载表示传入的参数不同</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#182%E9%87%91%E9%A2%9D%E8%BD%AC%E6%8D%A2%E4%B8%BA%E5%8D%83%E5%88%86%E4%BD%8D"><span class="toc-number">1.0.139.</span> <span class="toc-text">182金额转换为千分位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#183%E4%BA%8C%E7%BB%B4%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.140.</span> <span class="toc-text">183二维路径规划问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#184%E5%AE%9E%E7%8E%B0set"><span class="toc-number">1.0.141.</span> <span class="toc-text">184实现set</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#185"><span class="toc-number">1.0.142.</span> <span class="toc-text">185</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#186-splice"><span class="toc-number">1.0.143.</span> <span class="toc-text">186 splice</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#187"><span class="toc-number">1.0.144.</span> <span class="toc-text">187</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#112%E6%89%8B%E5%86%99Promise-all%E5%92%8CPromise-race"><span class="toc-number">1.0.145.</span> <span class="toc-text">112手写Promise.all和Promise.race</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#202%E4%B8%8B%E5%88%97%E4%BB%A3%E7%A0%81%E5%AD%98%E5%9C%A8%E5%87%A0%E4%B8%AA%E5%8F%98%E9%87%8F%E6%B2%A1%E6%9C%89%E8%A2%AB%E5%9B%9E%E6%94%B6%EF%BC%9F"><span class="toc-number">1.0.146.</span> <span class="toc-text">202下列代码存在几个变量没有被回收？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#188"><span class="toc-number">1.0.147.</span> <span class="toc-text">188</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#42%E5%A6%82%E4%BD%95%E6%B8%B2%E6%9F%93%E2%BC%8F%E4%B8%87%E6%9D%A1%E6%95%B0%E6%8D%AE%E5%B9%B6%E4%B8%8D%E5%8D%A1%E4%BD%8F%E7%95%8C%E2%BE%AF"><span class="toc-number">1.0.148.</span> <span class="toc-text">42如何渲染⼏万条数据并不卡住界⾯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#189"><span class="toc-number">1.0.149.</span> <span class="toc-text">189</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#190"><span class="toc-number">1.0.150.</span> <span class="toc-text">190</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#setState-%E5%8F%AA%E5%9C%A8%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E5%92%8C%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E4%B8%AD%E6%98%AF%E2%80%9C%E5%BC%82%E6%AD%A5%E2%80%9D%E7%9A%84%EF%BC%8C%E5%9C%A8%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E5%92%8C-setTimeout-%E4%B8%AD%E9%83%BD%E6%98%AF%E5%90%8C%E6%AD%A5%E7%9A%84%E3%80%82"><span class="toc-number">1.0.150.1.</span> <span class="toc-text">setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%EF%BC%9A%E5%B0%B1%E6%98%AFreact-%E5%9C%A8%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%9A%84onClick%E7%AD%89%E9%83%BD%E6%98%AF%E5%B1%9E%E4%BA%8E%E5%AE%83%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.0.150.1.1.</span> <span class="toc-text">合成事件：就是react 在组件中的onClick等都是属于它自定义的合成事件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%EF%BC%9A%E6%AF%94%E5%A6%82%E9%80%9A%E8%BF%87addeventListener%E6%B7%BB%E5%8A%A0%E7%9A%84%EF%BC%8Cdom%E4%B8%AD%E7%9A%84%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.0.150.1.2.</span> <span class="toc-text">原生事件：比如通过addeventListener添加的，dom中的原生事件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#191"><span class="toc-number">1.0.151.</span> <span class="toc-text">191</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#192"><span class="toc-number">1.0.152.</span> <span class="toc-text">192</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#193js%E5%AE%9E%E7%8E%B0%E4%B8%A4%E4%B8%AA%E5%A4%A7%E6%95%B4%E6%95%B0%E7%9B%B8%E4%B9%98"><span class="toc-number">1.0.153.</span> <span class="toc-text">193js实现两个大整数相乘</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#194Postman%E4%B8%ADpost%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.154.</span> <span class="toc-text">194Postman中post的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#195"><span class="toc-number">1.0.155.</span> <span class="toc-text">195</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#196BIGO"><span class="toc-number">1.0.156.</span> <span class="toc-text">196BIGO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#197%E5%89%8D%E5%BA%8F%E9%A1%BA%E5%BA%8F%E6%98%AF%EF%BC%88%E6%A0%B9%E8%8A%82%E7%82%B9%E6%8E%92%E6%9C%80%E5%85%88%EF%BC%8C%E7%84%B6%E5%90%8E%E5%90%8C%E7%BA%A7%E5%85%88%E5%B7%A6%E5%90%8E%E5%8F%B3%EF%BC%89%EF%BC%9B%E4%B8%AD%E5%BA%8F%E9%A1%BA%E5%BA%8F%E6%98%AF-%E5%85%88%E5%B7%A6%E5%90%8E%E6%A0%B9%E6%9C%80%E5%90%8E%E5%8F%B3%EF%BC%89%EF%BC%9B%E5%90%8E%E5%BA%8F%E9%A1%BA%E5%BA%8F%E6%98%AF%EF%BC%88%E5%85%88%E5%B7%A6%E5%90%8E%E5%8F%B3%E6%9C%80%E5%90%8E%E6%A0%B9%EF%BC%89%E3%80%82"><span class="toc-number">1.0.157.</span> <span class="toc-text">197前序顺序是（根节点排最先，然后同级先左后右）；中序顺序是(先左后根最后右）；后序顺序是（先左后右最后根）。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1%E8%AE%BE%E7%BD%AE%E5%85%83%E7%B4%A0%E6%B5%AE%E5%8A%A8%E5%90%8E%EF%BC%8C%E8%AF%A5%E5%85%83%E7%B4%A0%E7%9A%84display%E5%80%BC%E6%98%AF%EF%BC%88block%EF%BC%89"><span class="toc-number">1.0.158.</span> <span class="toc-text">1设置元素浮动后，该元素的display值是（block）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2document-load-%E4%B8%8Edocument-ready%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.159.</span> <span class="toc-text">2document load 与document ready的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13LocalStorage%E7%94%A8%E4%BA%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E4%BF%9D%E5%AD%98%E6%8C%81%E4%B9%85%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%EF%BC%8C%E5%B7%B2%E6%9C%89%E4%BF%9D%E5%AD%98%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3setItem-key-value-%E5%92%8C%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3getItem-key-%E3%80%82%E5%9B%A0%E9%A1%B9%E7%9B%AE%E9%9C%80%E8%A6%81%E6%88%91%E4%BB%AC%E9%9C%80%E8%A6%81%E4%B8%BA%E8%BF%99%E4%B8%AAlocalStorage%E7%9A%84%E6%95%B0%E6%8D%AE%E4%BF%9D%E5%AD%98%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4time%EF%BC%88%E5%8D%95%E4%BD%8D%EF%BC%9A%E7%A7%92%EF%BC%89%EF%BC%8C%E6%BB%A1%E8%B6%B3%E5%9C%A8%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4%E5%86%85%EF%BC%8Ckey-value%E6%9C%89%E6%95%88%EF%BC%8C%E8%B6%85%E8%BF%87%E6%9C%89%E6%95%88%E6%97%B6%E9%97%B4-%E5%8D%B3time%E7%A7%92%E5%90%8E%E5%A4%B1%E6%95%88%E3%80%82%E6%88%91%E4%BB%AC%E6%8A%8A%E8%BF%99%E4%B8%AA%E6%94%B9%E8%A3%85%E5%90%8E%E5%8F%B0%E7%9A%84localStorage%E5%91%BD%E5%90%8D%E4%B8%BAXstorage%EF%BC%8C%E8%AF%B7%E6%A0%B9%E6%8D%AE%E5%B7%B2%E6%9C%89%E7%9A%84%E6%8E%A5%E5%8F%A3%EF%BC%8C%E6%9D%A5%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0-setItem-key-value-time-%E5%92%8C-getItem-key-%E7%9A%84%E6%96%B9%E6%B3%95%E3%80%82"><span class="toc-number">1.0.160.</span> <span class="toc-text">13LocalStorage用于浏览器保存持久数据接口，已有保存数据接口setItem(key, value)和获取数据接口getItem(key)。因项目需要我们需要为这个localStorage的数据保存添加一个有效时间time（单位：秒），满足在有效时间内，key-value有效，超过有效时间 即time秒后失效。我们把这个改装后台的localStorage命名为Xstorage，请根据已有的接口，来实现函数.setItem(key, value, time)和.getItem(key)的方法。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20flex-grow%E9%BB%98%E8%AE%A4%E5%80%BC%E6%98%AF0%EF%BC%9B%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E4%B8%AD%EF%BC%8C%E5%AD%90%E5%85%83%E7%B4%A0%E7%9A%84float%E3%80%81clear%E3%80%81vertical-align%E5%B1%9E%E6%80%A7%E6%97%A0%E6%95%88%EF%BC%9B%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80%E7%9A%84%E5%AE%9A%E4%B9%89%E6%98%AF%E5%8F%96%E5%86%B3%E4%BA%8E%E5%AE%B9%E5%99%A8%E5%85%83%E7%B4%A0%E7%9A%84display%E5%B1%9E%E6%80%A7%E7%AD%89%E4%BA%8Eflex%E6%88%96inline-flex%E6%9D%A5%E5%86%B3%E5%AE%9A%E7%9A%84"><span class="toc-number">1.0.161.</span> <span class="toc-text">20flex-grow默认值是0；弹性布局中，子元素的float、clear、vertical-align属性无效；弹性布局的定义是取决于容器元素的display属性等于flex或inline-flex来决定的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24%E8%AF%B7%E4%BD%BF%E7%94%A8ES5%E5%92%8CESNext%E5%88%86%E5%88%AB%E5%AE%9E%E7%8E%B0%E4%B8%80%E7%A7%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">1.0.162.</span> <span class="toc-text">24请使用ES5和ESNext分别实现一种继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28js%E8%AF%B7%E4%BD%BF%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AE%9E%E7%8E%B0%E5%8C%B9%E9%85%8D%E7%BD%91%E5%9D%80%EF%BC%88%E4%BB%8Ehttp-www-xxx-com-a-1%E4%B8%ADwww-xxx-com%EF%BC%8C%E5%8D%8F%E8%AE%AE%E5%A4%B4%E5%8C%85%E5%90%ABhttp-https-ftp"><span class="toc-number">1.0.163.</span> <span class="toc-text">***28js请使用正则表达式实现匹配网址（从http:&#x2F;&#x2F;www.xxx.com&#x2F;?a&#x3D;1中www.xxx.com，协议头包含http&#x2F;https&#x2F;ftp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31%E8%AF%B7%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%95%B0%E7%BB%84-a-2-a-1-a-0-a-10-a-2-1-%E6%8C%89%E5%B1%9E%E6%80%A7a%E4%B8%BA%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E5%9F%BA%E5%87%86%E8%BF%9B%E8%A1%8C%E8%BF%87%E6%BB%A4%EF%BC%8C%E8%BF%87%E6%BB%A4%E6%8E%89%E5%85%B6%E4%B8%AD%E5%B1%9E%E6%80%A7a%E4%B8%BA%E6%B5%AE%E7%82%B9%E6%95%B0%E7%9A%84%E9%A1%B9"><span class="toc-number">1.0.164.</span> <span class="toc-text">31请实现对数组[{a:2},{a:1},{a:0},{a:10},{a:2.1}]按属性a为浮点数的基准进行过滤，过滤掉其中属性a为浮点数的项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-lt-base-input-v-model-%E2%80%9DlovingVue%E2%80%9D-gt-lt-base-input-gt-%EF%BC%8C%E5%81%87%E5%A6%82base-input%E6%98%AF%E4%BD%A0%E5%B0%81%E8%A3%85%E7%9A%84%E7%BB%84%E4%BB%B6%EF%BC%8C%E5%9C%A8%E5%86%85%E9%83%A8%E5%A6%82%E4%BD%95%E6%8E%A5%E6%94%B6%E5%A4%96%E9%83%A8%E4%BC%A0%E8%BF%9B%E5%8E%BB%E7%9A%84lovingVue%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%86%85%E9%83%A8%E5%A6%82%E4%BD%95%E6%9B%B4%E6%96%B0%E5%A4%96%E9%83%A8lovingVue%E7%9A%84%E5%80%BC%EF%BC%9F%EF%BC%9B%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8B%E7%BB%84%E4%BB%B6%E4%B8%AD%E7%88%B6%E5%AD%90%E9%97%B4%E9%80%9A%E8%AE%AF%EF%BC%9F%EF%BC%88https-blog-csdn-net-bigbear00007-article-details-104887792%EF%BC%89%EF%BC%9B%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%EF%BC%9F"><span class="toc-number">1.0.165.</span> <span class="toc-text">37&lt;base-input v-model&#x3D;”lovingVue”&gt;&lt;&#x2F;base-input&gt;，假如base-input是你封装的组件，在内部如何接收外部传进去的lovingVue，以及内部如何更新外部lovingVue的值？；介绍一下组件中父子间通讯？（https:&#x2F;&#x2F;blog.csdn.net&#x2F;bigbear00007&#x2F;article&#x2F;details&#x2F;104887792）；如何解决跨域问题？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38%E6%A0%B9%E6%8D%AE%E4%BB%A5%E4%B8%8Bxml%E8%AF%B7%E5%86%99%E5%87%BA%E5%AF%B9%E5%BA%94%E7%9A%84json"><span class="toc-number">1.0.166.</span> <span class="toc-text">38根据以下xml请写出对应的json</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47Vue%E4%B8%AD%E7%BB%99data%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B1%9E%E6%80%A7%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%B1%9E%E6%80%A7%E6%97%B6%E4%BC%9A%E5%8F%91%E7%94%9F%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F-set"><span class="toc-number">1.0.167.</span> <span class="toc-text">47Vue中给data中的对象属性添加一个新的属性时会发生什么，如何解决？($set())</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#49%E5%86%99%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81%EF%BC%8C%E4%BD%BF%E7%94%A8vue%E5%AE%9E%E7%8E%B0%E7%BB%84%E4%BB%B6%E5%86%85%E9%83%A8%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%EF%BC%8C%E4%BE%8B%E5%A6%82%E6%9C%89%E4%B8%80%E4%B8%AA%E8%BE%93%E5%85%A5%E6%A1%86%E7%BB%84%E4%BB%B6%EF%BC%8C%E7%94%A8%E6%88%B7%E8%BE%93%E5%85%A5%E6%97%B6%EF%BC%8C%E5%90%8C%E6%AD%A5%E7%88%B6%E7%BB%84%E4%BB%B6%E9%A1%B5%E9%9D%A2%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">1.0.168.</span> <span class="toc-text">49写一段代码，使用vue实现组件内部双向数据绑定，例如有一个输入框组件，用户输入时，同步父组件页面的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#61%E6%A8%A1%E5%9D%97%E5%8C%96CSS%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%8CNative-CSS-LESS-SCSS%E4%B8%8D%E5%90%8C%E7%9A%84%E5%AE%9E%E7%8E%B0%EF%BC%8C%E4%BC%98%E5%8A%BF%E5%92%8C%E9%97%AE%E9%A2%98%EF%BC%88CSS%E6%A8%A1%E5%9D%97%E5%8C%96%E7%9A%84%E5%91%BD%E5%90%8D%E9%97%AE%E9%A2%98%E3%80%81%E6%9D%83%E9%87%8D%E9%97%AE%E9%A2%98%E3%80%81%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98%EF%BC%89"><span class="toc-number">1.0.169.</span> <span class="toc-text">61模块化CSS的方法，Native CSS&#x2F;LESS&#x2F;SCSS不同的实现，优势和问题（CSS模块化的命名问题、权重问题、变量问题）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%94%A8-%EF%BC%8C%E5%AE%9E%E7%8E%B0%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%95%B0%E7%BB%84%E7%9A%84add-strA-strB"><span class="toc-number">1.0.170.</span> <span class="toc-text">63不直接用+-&#x2F;，实现字符串数组的add(strA, strB)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#66%E6%89%8B%E5%86%99%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E7%9A%84promise"><span class="toc-number">1.0.171.</span> <span class="toc-text">66手写实现一个基本功能的promise</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#68%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%85%B7%E5%A4%87%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E7%9A%84%E4%BA%8B%E4%BB%B6%E7%9B%91%E5%90%AC%E5%99%A8%EF%BC%8CaddEventListener-dispatchEvent-removeEventListener"><span class="toc-number">1.0.172.</span> <span class="toc-text">68实现一个具备基础功能的事件监听器，addEventListener dispatchEvent removeEventListener</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#69%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%9A%E8%BE%93%E5%87%BA%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E5%85%83%E7%B4%A0"><span class="toc-number">1.0.173.</span> <span class="toc-text">69编程题：输出旋转数组的最小元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70%E7%BC%96%E7%A8%8B%E9%A2%98%EF%BC%9A%E7%BB%99%E5%AE%9A%E6%95%B0%E7%BB%84arr%EF%BC%8C%E8%AE%BE%E6%95%B0%E7%BB%84%E9%95%BF%E5%BA%A6%E4%B8%BAn%EF%BC%8Carr%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%80%BC%E9%83%BD%E4%B8%BA%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B8%94%E4%B8%8D%E9%87%8D%E5%A4%8D%E3%80%82%E6%AF%8F%E4%B8%AA%E5%80%BC%E4%BB%A3%E8%A1%A8%E4%B8%80%E7%A7%8D%E9%9D%A2%E5%80%BC%E7%9A%84%E8%B4%A7%E5%B8%81%EF%BC%8C%E6%AF%8F%E7%A7%8D%E9%9D%A2%E5%80%BC%E7%9A%84%E8%B4%A7%E5%B8%81%E5%8F%AF%E4%BB%A5%E4%BD%BF%E7%94%A8%E4%BB%BB%E6%84%8F%E5%BC%A0%EF%BC%8C%E5%86%8D%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E6%95%B4%E6%95%B0aim%EF%BC%8C%E4%BB%A3%E8%A1%A8%E8%A6%81%E6%89%BE%E7%9A%84%E9%92%B1%E6%95%B0%EF%BC%8C%E6%B1%82%E6%8D%A2%E9%92%B1%E7%9A%84%E6%96%B9%E6%B3%95%E6%95%B0%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%8D%E3%80%82%E7%94%B1%E4%BA%8E%E6%96%B9%E6%B3%95%E7%9A%84%E7%A7%8D%E6%95%B0%E6%AF%94%E8%BE%83%E5%A4%A7%EF%BC%8C%E6%89%80%E4%BB%A5%E8%A6%81%E6%B1%82%E8%BE%93%E5%87%BA%E5%AF%B9109-710-9-7109-7%E8%BF%9B%E8%A1%8C%E5%8F%96%E6%A8%A1%E5%90%8E%E7%9A%84%E7%AD%94%E6%A1%88%E3%80%82-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%9A%84%E9%A2%98%EF%BC%8C%E8%80%81%E9%9A%BE%E4%BA%86"><span class="toc-number">1.0.174.</span> <span class="toc-text">***70编程题：给定数组arr，设数组长度为n，arr中所有的值都为正整数且不重复。每个值代表一种面值的货币，每种面值的货币可以使用任意张，再给定一个整数aim，代表要找的钱数，求换钱的方法数有多少种。由于方法的种数比较大，所以要求输出对109+710^9+7109+7进行取模后的答案。(动态规划的题，老难了)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#73%E5%B0%86%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84rgb%E9%A2%9C%E8%89%B2%E8%BD%AC%E6%8D%A2%E4%B8%BA16%E8%BF%9B%E5%88%B6"><span class="toc-number">1.0.175.</span> <span class="toc-text">73将字符串中的rgb颜色转换为16进制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74%E6%A0%B9%E6%8D%AE%E5%8C%85%E5%90%8D%EF%BC%8C%E5%9C%A8%E6%8C%87%E5%AE%9A%E7%A9%BA%E9%97%B4%E4%B8%AD%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.0.176.</span> <span class="toc-text">74根据包名，在指定空间中创建对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#76%E6%9C%89-n-%E4%B8%AA%E5%9F%8E%E5%B8%82%EF%BC%8C%E5%85%B6%E4%B8%AD%E4%B8%80%E4%BA%9B%E5%BD%BC%E6%AD%A4%E7%9B%B8%E8%BF%9E%EF%BC%8C%E5%8F%A6%E4%B8%80%E4%BA%9B%E6%B2%A1%E6%9C%89%E7%9B%B8%E8%BF%9E%E3%80%82%E5%A6%82%E6%9E%9C%E5%9F%8E%E5%B8%82-a-%E4%B8%8E%E5%9F%8E%E5%B8%82-b-%E7%9B%B4%E6%8E%A5%E7%9B%B8%E8%BF%9E%EF%BC%8C%E4%B8%94%E5%9F%8E%E5%B8%82-b-%E4%B8%8E%E5%9F%8E%E5%B8%82-c-%E7%9B%B4%E6%8E%A5%E7%9B%B8%E8%BF%9E%EF%BC%8C%E9%82%A3%E4%B9%88%E5%9F%8E%E5%B8%82-a-%E4%B8%8E%E5%9F%8E%E5%B8%82-c-%E9%97%B4%E6%8E%A5%E7%9B%B8%E8%BF%9E%E3%80%82"><span class="toc-number">1.0.177.</span> <span class="toc-text">76有 n 个城市，其中一些彼此相连，另一些没有相连。如果城市 a 与城市 b 直接相连，且城市 b 与城市 c 直接相连，那么城市 a 与城市 c 间接相连。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89%E6%96%AD%E5%BC%80%E9%93%BE%E6%8E%A5%E5%9B%9B%E6%AC%A1%E6%8F%A1%E2%BC%BF"><span class="toc-number">1.0.178.</span> <span class="toc-text">89断开链接四次握⼿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#94%E8%A1%A8%E5%8D%95%E5%8F%AF%E4%BB%A5%E8%B7%A8%E5%9F%9F%E5%90%97-%E5%8F%AF%E4%BB%A5"><span class="toc-number">1.0.179.</span> <span class="toc-text">94表单可以跨域吗 可以</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98-%E7%9B%91%E5%90%ACinput%E7%9A%84%E5%93%AA%E4%B8%AA%E4%BA%8B%E4%BB%B6%EF%BC%8C%E5%9C%A8%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E8%A7%A6%E5%8F%91"><span class="toc-number">1.0.180.</span> <span class="toc-text">98 监听input的哪个事件，在什么时候触发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#100mixin-%E5%92%8C-mixins-%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.181.</span> <span class="toc-text">100mixin 和 mixins 区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#101%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.0.182.</span> <span class="toc-text">101工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#125%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0repeatStr-%EF%BC%8C%E4%BD%BF%E7%94%A8%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84repeat-%E6%96%B9%E6%B3%95%E6%9D%A5%E5%B0%86%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9B%E8%A1%8C%E4%B8%8D%E6%96%AD%E9%87%8D%E5%A4%8D%EF%BC%8C%E7%84%B6%E5%90%8E%E8%B6%85%E8%BF%8720%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84%E9%83%A8%E5%88%86%E5%B0%B1%E6%88%AA%E6%96%AD%E8%88%8D%E5%BC%83%EF%BC%8C%E4%B9%9F%E5%B0%B1%E6%98%AF%E6%9C%80%E7%BB%88%E8%BF%94%E5%9B%9E%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB20%E4%B8%AA%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%82"><span class="toc-number">1.0.183.</span> <span class="toc-text">125编写一个函数repeatStr()，使用字符串的repeat()方法来将任意一个字符串进行不断重复，然后超过20个字符的部分就截断舍弃，也就是最终返回一个包含20个字符的字符串。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#126%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0shieldStr-%EF%BC%8C%E7%94%A8%E4%BA%8E%E6%8E%A5%E6%94%B6%E4%B8%80%E4%B8%AA%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E5%9C%B0%E5%9D%80%EF%BC%8C%E7%84%B6%E5%90%8E%E5%B0%86-%E5%89%8D%E9%9D%A2%E6%89%80%E6%9C%89%E7%9A%84%E5%AD%97%E7%AC%A6%E5%B1%8F%E8%94%BD%E6%8E%89%E3%80%82%E6%AF%94%E5%A6%82%EF%BC%8C-x6c-118-x79-101-115-x74-x75-100-x79-x40-x66-111-120-109-x61-105-108-46-x63-111-x6d-%E5%B0%86%E8%A2%AB%E5%B1%8F%E8%94%BD%E4%B8%BA%EF%BC%9A-foxmail-com%E3%80%82"><span class="toc-number">1.0.184.</span> <span class="toc-text">126编写一个函数shieldStr()，用于接收一个电子邮件地址，然后将@前面所有的字符屏蔽掉。比如，&amp;#x6c;&amp;#118;&amp;#x79;&amp;#101;&amp;#115;&amp;#x74;&amp;#x75;&amp;#100;&amp;#x79;&amp;#x40;&amp;#x66;&amp;#111;&amp;#120;&amp;#109;&amp;#x61;&amp;#105;&amp;#108;&amp;#46;&amp;#x63;&amp;#111;&amp;#x6d;将被屏蔽为：**********@foxmail.com。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#127"><span class="toc-number">1.0.185.</span> <span class="toc-text">127</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#128"><span class="toc-number">1.0.186.</span> <span class="toc-text">128</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#135%E4%BA%8C%E5%8F%89%E6%A0%91%E6%B7%B1%E5%BA%A6"><span class="toc-number">1.0.187.</span> <span class="toc-text">135二叉树深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#136%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E6%98%AF-Map%E6%88%96%E8%80%85Set%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.188.</span> <span class="toc-text">136如何判断一个对象是 Map或者Set数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#139-%E5%AF%B9%E8%B1%A1a-b-%E5%AD%98%E5%9C%A8%E7%9B%B8%E5%90%8C%E7%9A%84key%E5%80%BC%EF%BC%8Cb%E8%A6%86%E7%9B%96a%E5%B1%9E%E6%80%A7%E5%80%BC%EF%BC%8C%E5%A6%82%E6%9E%9Ca%EF%BC%8Cb%E7%9B%B8%E5%90%8C%E7%9A%84key%E5%AF%B9%E5%BA%94%E7%9A%84%E5%80%BC%E5%9D%87%E4%B8%BA%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%88%99%E5%86%8D%E6%AC%A1%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%90%88%E5%B9%B6"><span class="toc-number">1.0.189.</span> <span class="toc-text">139 对象a, b 存在相同的key值，b覆盖a属性值，如果a，b相同的key对应的值均为对象，则再次进行对象合并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#143%E7%BB%99%E4%BD%A0%E4%B8%80%E4%B8%AA%E5%8C%85%E5%90%AB-n-%E4%B8%AA%E6%95%B4%E6%95%B0%E7%9A%84%E6%95%B0%E7%BB%84-nums%EF%BC%8C%E5%88%A4%E6%96%AD-nums-%E4%B8%AD%E6%98%AF%E5%90%A6%E5%AD%98%E5%9C%A8%E4%B8%89%E4%B8%AA%E5%85%83%E7%B4%A0-a%EF%BC%8Cb%EF%BC%8Cc-%EF%BC%8C%E4%BD%BF%E5%BE%97-a-b-c-0-%EF%BC%9F%E8%AF%B7%E4%BD%A0%E6%89%BE%E5%87%BA%E6%89%80%E6%9C%89%E5%92%8C%E4%B8%BA-0-%E4%B8%94%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E4%B8%89%E5%85%83%E7%BB%84%E3%80%82"><span class="toc-number">1.0.190.</span> <span class="toc-text">143给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c &#x3D; 0 ？请你找出所有和为 0 且不重复的三元组。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E5%89%8D%E7%AB%AF%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9BSEO"><span class="toc-number">1.0.191.</span> <span class="toc-text">1 前端需要注意哪些SEO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-HTML5-%E7%9A%84%E7%A6%BB%E7%BA%BF%E5%82%A8%E5%AD%98%E6%80%8E%E4%B9%88%E4%BD%BF%E2%BD%A4%EF%BC%8C%E2%BC%AF%E4%BD%9C%E5%8E%9F%E7%90%86%E8%83%BD%E4%B8%8D%E8%83%BD%E8%A7%A3%E9%87%8A%E2%BC%80%E4%B8%8B%EF%BC%9F"><span class="toc-number">1.0.192.</span> <span class="toc-text">2 HTML5 的离线储存怎么使⽤，⼯作原理能不能解释⼀下？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-HTML%E5%85%A8%E5%B1%80%E5%B1%9E%E6%80%A7-global-attribute-%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.0.193.</span> <span class="toc-text">4 HTML全局属性(global attribute)有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-HTML5-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AA%E9%9C%80%E8%A6%81%E5%86%99-lt-DOCTYPE-HTML-gt"><span class="toc-number">1.0.194.</span> <span class="toc-text">5 HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%A6%82%E4%BD%95%E5%9C%A8%E2%BB%9A%E2%BE%AF%E4%B8%8A%E5%AE%9E%E7%8E%B0%E2%BC%80%E4%B8%AA%E5%9C%86%E5%BD%A2%E7%9A%84%E5%8F%AF%E7%82%B9%E5%87%BB%E5%8C%BA%E5%9F%9F%EF%BC%9F"><span class="toc-number">1.0.195.</span> <span class="toc-text">6 如何在⻚⾯上实现⼀个圆形的可点击区域？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-viewport%E9%87%8C%E7%9A%84%E9%85%8D%E7%BD%AE%EF%BC%8C%E5%BB%B6%E4%BC%B8%E6%8F%90%E9%97%AE%EF%BC%8C%E6%80%8E%E6%A0%B7%E5%A4%84%E7%90%86%E7%A7%BB%E5%8A%A8%E7%AB%AF1px%E8%A2%AB%E6%B8%B2%E6%9F%93%E6%88%902px%E9%97%AE%E9%A2%98"><span class="toc-number">1.0.196.</span> <span class="toc-text">7 viewport里的配置，延伸提问，怎样处理移动端1px被渲染成2px问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-div-css%E7%9A%84%E5%B8%83%E5%B1%80%E8%BE%83table%E5%B8%83%E5%B1%80%E6%9C%89%E4%BB%80%E4%B9%88%E4%BC%98%E7%82%B9%EF%BC%9F"><span class="toc-number">1.0.197.</span> <span class="toc-text">8 div+css的布局较table布局有什么优点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-web%E5%BC%80%E5%8F%91%E4%B8%AD%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA%E7%9A%84%E2%BD%85%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B"><span class="toc-number">1.0.198.</span> <span class="toc-text">10 web开发中会话跟踪的⽅法有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-link-%E4%B8%8E-import-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.199.</span> <span class="toc-text">11 link 与 @import 的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFFOUC-%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D"><span class="toc-number">1.0.199.1.</span> <span class="toc-text">什么是FOUC?如何避免</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E5%9C%A8%E2%BD%B9%E2%BB%9A%E4%B8%AD%E7%9A%84%E5%BA%94%E8%AF%A5%E4%BD%BF%E2%BD%A4%E5%A5%87%E6%95%B0%E8%BF%98%E6%98%AF%E5%81%B6%E6%95%B0%E7%9A%84%E5%AD%97%E4%BD%93%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E5%91%A2%EF%BC%9F"><span class="toc-number">1.0.200.</span> <span class="toc-text">13 在⽹⻚中的应该使⽤奇数还是偶数的字体？为什么呢？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-stylus-sass-less%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.201.</span> <span class="toc-text">16 stylus&#x2F;sass&#x2F;less区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-postcss%E7%9A%84%E4%BD%9C%E2%BD%A4"><span class="toc-number">1.0.202.</span> <span class="toc-text">17 postcss的作⽤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E4%BC%AA%E7%B1%BB%E5%92%8C%E4%BC%AA%E5%85%83%E7%B4%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.203.</span> <span class="toc-text">18 伪类和伪元素的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19%E8%AF%B7%E2%BD%A4CSS%E5%86%99%E2%BC%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E5%B9%BB%E7%81%AF%E2%BD%9A%E6%95%88%E6%9E%9C%E2%BB%9A%E2%BE%AF"><span class="toc-number">1.0.204.</span> <span class="toc-text">19请⽤CSS写⼀个简单的幻灯⽚效果⻚⾯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E5%A6%82%E4%BD%95%E4%BD%BF%E2%BD%A4CSS%E5%AE%9E%E7%8E%B0%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%EF%BC%9F"><span class="toc-number">1.0.205.</span> <span class="toc-text">21 如何使⽤CSS实现硬件加速？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E2%BC%A9%E4%BA%8E12px%E7%9A%84%E5%AD%97%E4%BD%93%E6%95%88%E6%9E%9C"><span class="toc-number">1.0.206.</span> <span class="toc-text">22 如何实现⼩于12px的字体效果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-XML%E5%92%8CJSON%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.0.207.</span> <span class="toc-text">25 XML和JSON的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-offsetWidth-offsetHeight-clientWidth-clientHeight%E4%B8%8EscrollWidth-scrollHeight%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.0.208.</span> <span class="toc-text">30 offsetWidth&#x2F;offsetHeight,clientWidth&#x2F;clientHeight与scrollWidth&#x2F;scrollHeight的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-Node%E7%9A%84%E5%BA%94%E2%BD%A4%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.</span> <span class="toc-text">31 Node的应⽤场景</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#32-eval%E6%98%AF%E5%81%9A%E4%BB%80%E4%B9%88%E7%9A%84"><span class="toc-number">1.1.1.</span> <span class="toc-text">32 eval是做什么的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.2.</span> <span class="toc-text">33 同步和异步的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34-%E8%AF%B4%E8%AF%B4%E4%B8%A5%E6%A0%BC%E6%A8%A1%E5%BC%8F%E7%9A%84%E9%99%90%E5%88%B6"><span class="toc-number">1.1.3.</span> <span class="toc-text">34 说说严格模式的限制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#35-%E4%BB%80%E4%B9%88%E6%98%AF%E2%BE%AF%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E5%8F%8A%E2%BE%AF%E5%90%91%E8%BF%87%E7%A8%8B%E7%BC%96%E7%A8%8B%EF%BC%8C%E5%AE%83%E4%BB%AC%E7%9A%84%E5%BC%82%E5%90%8C%E5%92%8C%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.4.</span> <span class="toc-text">35 什么是⾯向对象编程及⾯向过程编程，它们的异同和优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#37-%E8%B0%88%E2%BC%80%E8%B0%88%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.1.5.</span> <span class="toc-text">37 谈⼀谈箭头函数与普通函数的区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#38JS%E5%8A%A8%E7%94%BB%E4%B8%8ECSS%E5%8A%A8%E7%94%BB%E5%8C%BA%E5%88%AB%E5%8F%8A%E7%9B%B8%E5%BA%94%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.6.</span> <span class="toc-text">38JS动画与CSS动画区别及相应实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#39-gulp%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.1.7.</span> <span class="toc-text">39 gulp是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#41%E5%BF%AB%E9%80%9F%E7%9A%84%E8%AE%A9%E2%BC%80%E4%B8%AA%E6%95%B0%E7%BB%84%E4%B9%B1%E5%BA%8F"><span class="toc-number">1.1.8.</span> <span class="toc-text">41快速的让⼀个数组乱序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43%E5%B8%8C%E6%9C%9B%E8%8E%B7%E5%8F%96%E5%88%B0%E2%BB%9A%E2%BE%AF%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84checkbox%E6%80%8E%E4%B9%88%E5%81%9A"><span class="toc-number">1.1.9.</span> <span class="toc-text">43希望获取到⻚⾯中所有的checkbox怎么做</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#44Javascript%E4%B8%ADcallee%E5%92%8Ccaller%E7%9A%84%E4%BD%9C%E2%BD%A4%EF%BC%9F"><span class="toc-number">1.1.10.</span> <span class="toc-text">44Javascript中callee和caller的作⽤？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#45-addEventListener-%E5%92%8CattachEvent-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.11.</span> <span class="toc-text">45 addEventListener()和attachEvent()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#47-Javascript%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.1.12.</span> <span class="toc-text">47 Javascript全局函数和全局变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#48%E6%80%8E%E4%B9%88%E5%88%A4%E6%96%AD%E4%B8%A4%E4%B8%AA%E5%AF%B9%E8%B1%A1%E7%9B%B8%E7%AD%89%EF%BC%9F"><span class="toc-number">1.1.13.</span> <span class="toc-text">48怎么判断两个对象相等？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#50-%E6%B7%B1%E6%B5%85%E6%8B%B7%E2%BB%89"><span class="toc-number">1.1.14.</span> <span class="toc-text">50 深浅拷⻉</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#51-%E9%98%B2%E6%8A%96-%E8%8A%82%E6%B5%81"><span class="toc-number">1.1.15.</span> <span class="toc-text">51 防抖&#x2F;节流</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#52%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87"><span class="toc-number">1.1.16.</span> <span class="toc-text">52变量提升</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#53%E8%AF%B7%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A-mvvm"><span class="toc-number">1.1.17.</span> <span class="toc-text">53请简单实现双向数据绑定 mvvm</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#63%E7%BC%96%E5%86%99%E2%BC%80%E4%B8%AA%E2%BD%85%E6%B3%95-%E6%B1%82%E2%BC%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%97%E8%8A%82%E2%BB%93%E5%BA%A6%EF%BC%8C%E5%81%87%E8%AE%BE%EF%BC%9A%E2%BC%80%E4%B8%AA%E8%8B%B1%E2%BD%82%E5%AD%97%E7%AC%A6%E5%8D%A0%E2%BD%A4%E2%BC%80%E4%B8%AA%E5%AD%97%E8%8A%82%EF%BC%8C%E2%BC%80%E4%B8%AA%E4%B8%AD%E2%BD%82%E5%AD%97%E7%AC%A6%E5%8D%A0%E2%BD%A4%E4%B8%A4%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">1.1.18.</span> <span class="toc-text">63编写⼀个⽅法 求⼀个字符串的字节⻓度，假设：⼀个英⽂字符占⽤⼀个字节，⼀个中⽂字符占⽤两个字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#64bind%E7%9A%84%E2%BD%A4%E6%B3%95%EF%BC%8C%E4%BB%A5%E5%8F%8A%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0bind%E7%9A%84%E5%87%BD%E6%95%B0%E5%92%8C%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E7%82%B9"><span class="toc-number">1.1.19.</span> <span class="toc-text">64bind的⽤法，以及如何实现bind的函数和需要注意的点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#67-%E5%AE%9A%E4%B9%89%E2%BC%80%E4%B8%AAlog%E2%BD%85%E6%B3%95%EF%BC%8C%E8%AE%A9%E5%AE%83%E5%8F%AF%E4%BB%A5%E4%BB%A3%E7%90%86console-log%E7%9A%84%E2%BD%85%E6%B3%95"><span class="toc-number">1.1.20.</span> <span class="toc-text">67 定义⼀个log⽅法，让它可以代理console.log的⽅法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#70%E5%86%99%E2%BC%80%E4%B8%AA-function-%EF%BC%8C%E6%B8%85%E9%99%A4%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%89%8D%E5%90%8E%E7%9A%84%E7%A9%BA%E6%A0%BC"><span class="toc-number">1.1.21.</span> <span class="toc-text">70写⼀个 function ，清除字符串前后的空格</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#71%E5%AE%9E%E7%8E%B0%E6%AF%8F%E9%9A%94%E2%BC%80%E7%A7%92%E9%92%9F%E8%BE%93%E5%87%BA1-2-3%E2%80%A6%E6%95%B0%E5%AD%97"><span class="toc-number">1.1.22.</span> <span class="toc-text">71实现每隔⼀秒钟输出1,2,3…数字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#72%E5%AE%9E%E7%8E%B0%E2%BC%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%8C%E5%88%A4%E6%96%AD%E8%BE%93%E2%BC%8A%E6%98%AF%E4%B8%8D%E6%98%AF%E5%9B%9E%E2%BD%82%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.1.23.</span> <span class="toc-text">72实现⼀个函数，判断输⼊是不是回⽂字符串</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#74%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1"><span class="toc-number">1.1.24.</span> <span class="toc-text">74负载均衡</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#75CDN"><span class="toc-number">1.1.25.</span> <span class="toc-text">75CDN</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#78%E5%89%8D%E5%90%8E%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%B7%AE%E5%88%AB"><span class="toc-number">1.1.26.</span> <span class="toc-text">78前后端路由差别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#79%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9%E9%87%8D%E6%9E%84%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.27.</span> <span class="toc-text">79谈谈你对重构的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#80%E4%BB%80%E4%B9%88%E6%A0%B7%E7%9A%84%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E6%98%AF%E5%A5%BD%E7%9A%84"><span class="toc-number">1.1.28.</span> <span class="toc-text">80什么样的前端代码是好的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#87-gt-true"><span class="toc-number">1.1.29.</span> <span class="toc-text">87 [] &#x3D;&#x3D; ![] &#x2F;&#x2F; -&gt; true</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#89%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86"><span class="toc-number">1.1.30.</span> <span class="toc-text">89什么是事件代理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#91%E5%BE%88%E5%A4%9A%E2%BC%88%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E6%98%AF%EF%BC%8C%E9%87%8D%E7%BB%98%E5%92%8C%E5%9B%9E%E6%B5%81%E5%85%B6%E5%AE%9E%E5%92%8C-Event-loop-%E6%9C%89%E5%85%B3%E3%80%82"><span class="toc-number">1.1.31.</span> <span class="toc-text">91很多⼈不知道的是，重绘和回流其实和 Event loop 有关。</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#92%E2%80%99a%E2%80%99-%E2%80%98b%E2%80%99-gt-%E2%80%9CaNaN%E2%80%9D"><span class="toc-number">1.1.32.</span> <span class="toc-text">92’a’ + + ‘b’ &#x2F;&#x2F; -&gt; “aNaN”</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#97-%E9%A2%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.1.33.</span> <span class="toc-text">97 预加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#98%E9%A2%84%E6%B8%B2%E6%9F%93"><span class="toc-number">1.1.34.</span> <span class="toc-text">98预渲染</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#99%E6%87%92%E6%89%A7%E2%BE%8F%E4%B8%8E%E6%87%92%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.1.35.</span> <span class="toc-text">99懒执⾏与懒加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#102%E5%AF%86%E7%A0%81%E5%AE%89%E5%85%A8"><span class="toc-number">1.1.36.</span> <span class="toc-text">102密码安全</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#103this-%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">1.1.37.</span> <span class="toc-text">103this 对象的理解</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#104%E5%A6%82%E4%BD%95%E6%B4%BE%E5%8F%91%E4%BA%8B%E4%BB%B6"><span class="toc-number">1.1.38.</span> <span class="toc-text">104如何派发事件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#105%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.39.</span> <span class="toc-text">105运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#109%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95promise"><span class="toc-number">1.1.40.</span> <span class="toc-text">109实现简单promise</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#114-instanceof%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">114. instanceof的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#115-Object-create%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">115. Object.create的基本实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#123-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%8F%8C%E5%90%91%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%EF%BC%88%E7%9C%8Bes6%EF%BC%89"><span class="toc-number">1.4.</span> <span class="toc-text">123. 实现一个双向数据绑定（看es6）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#133"><span class="toc-number">1.4.1.</span> <span class="toc-text">133</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#135%E4%BD%A0%E5%AF%B9line-height%E6%98%AF%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E7%9A%84"><span class="toc-number">1.4.2.</span> <span class="toc-text">135你对line-height是如何理解的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#137%E5%A6%82%E6%9E%9C%E9%9C%80%E8%A6%81%E6%89%8B%E5%8A%A8%E5%86%99%E5%8A%A8%E7%94%BB%EF%BC%8C%E4%BD%A0%E8%AE%A4%E4%B8%BA%E6%9C%80%E5%B0%8F%E6%97%B6%E9%97%B4%E9%97%B4%E9%9A%94%E6%98%AF%E5%A4%9A%E4%B9%85"><span class="toc-number">1.4.3.</span> <span class="toc-text">137如果需要手动写动画，你认为最小时间间隔是多久</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#139position%E8%B7%9Fdisplay%E3%80%81overflow%E3%80%81float%E8%BF%99%E4%BA%9B%E7%89%B9%E6%80%A7%E7%9B%B8%E4%BA%92%E5%8F%A0%E5%8A%A0%E5%90%8E%E4%BC%9A%E6%80%8E%E4%B9%88%E6%A0%B7%EF%BC%9F"><span class="toc-number">1.4.4.</span> <span class="toc-text">139position跟display、overflow、float这些特性相互叠加后会怎么样？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#141-CSS%E9%87%8C%E7%9A%84visibility%E5%B1%9E%E6%80%A7%E6%9C%89%E4%B8%AAcollapse%E5%B1%9E%E6%80%A7%E5%80%BC%EF%BC%9F%E5%9C%A8%E4%B8%8D%E5%90%8C%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E4%BB%A5%E5%90%8E%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">1.4.5.</span> <span class="toc-text">141 CSS里的visibility属性有个collapse属性值？在不同浏览器下以后什么区别？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#142%E5%85%A8%E5%B1%8F%E6%BB%9A%E5%8A%A8%E7%9A%84%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E7%94%A8%E5%88%B0%E4%BA%86CSS%E7%9A%84%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%EF%BC%9F"><span class="toc-number">1.4.6.</span> <span class="toc-text">142全屏滚动的原理是什么？用到了CSS的哪些属性？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#145%E5%85%B3%E4%BA%8E%E6%B5%AE%E5%8A%A8%EF%BC%8C%E4%BB%A5%E4%B8%8B%E6%98%AF%E6%AD%A3%E7%A1%AE%E7%9A%84%E8%AF%B4%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.7.</span> <span class="toc-text">145关于浮动，以下是正确的说法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#146%E5%85%B3%E4%BA%8E%E4%B8%8A%E9%9D%A2%E4%B8%A4%E8%A1%8C%E4%BB%A3%E7%A0%81%E6%98%BE%E7%A4%BA%E7%BB%93%E6%9E%9C%E8%AF%B4%E6%B3%95%E6%AD%A3%E7%A1%AE%E5%92%8C%E9%94%99%E8%AF%AF%E7%9A%84%E6%98%AF"><span class="toc-number">1.4.8.</span> <span class="toc-text">146关于上面两行代码显示结果说法正确和错误的是</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#147%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%BA%9B%E6%96%B9%E6%B3%95%E5%8F%AF%E4%BB%A5%E4%BC%98%E5%8C%96%E6%BB%9A%E5%8A%A8%E6%80%A7%E8%83%BD%EF%BC%9F"><span class="toc-number">1.4.9.</span> <span class="toc-text">147以下哪些方法可以优化滚动性能？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#148%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-css-%E5%9C%A8%E6%A0%87%E9%A2%98%E5%85%83%E7%B4%A0-lt-h2-gt-%E5%89%8D%E6%8F%92%E5%85%A5%E5%9B%BE%E5%83%8F%E6%96%87%E4%BB%B6"><span class="toc-number">1.4.10.</span> <span class="toc-text">148如何使用 css 在标题元素&lt;h2&gt;前插入图像文件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#149Background-position%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.11.</span> <span class="toc-text">149Background-position属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#150"><span class="toc-number">1.4.12.</span> <span class="toc-text">150</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#151"><span class="toc-number">1.4.13.</span> <span class="toc-text">151</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#152-%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%90%8E%EF%BC%8Carray%E7%9A%84%E7%BB%93%E6%9E%9C%E6%98%AF%EF%BC%9F"><span class="toc-number">1.4.14.</span> <span class="toc-text">152 以下代码执行后，array的结果是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#154%E6%9C%89var-d-new-Date-apos-2018-05-09-apos-%EF%BC%8C%E5%8F%AF%E4%BB%A5%E8%AE%BE%E7%BD%AE%E4%B8%BA6%E6%9C%88%E4%BB%BD%E7%9A%84%E6%93%8D%E4%BD%9C%E6%98%AF%EF%BC%9F"><span class="toc-number">1.4.15.</span> <span class="toc-text">154有var d &#x3D; new Date(&amp;apos;2018-05-09&amp;apos;)，可以设置为6月份的操作是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#155"><span class="toc-number">1.4.16.</span> <span class="toc-text">155</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#156-1"><span class="toc-number">1.4.17.</span> <span class="toc-text">156</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#159"><span class="toc-number">1.4.18.</span> <span class="toc-text">159</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#160"><span class="toc-number">1.4.19.</span> <span class="toc-text">160</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#161"><span class="toc-number">1.4.20.</span> <span class="toc-text">161</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#163"><span class="toc-number">1.4.21.</span> <span class="toc-text">163</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#164-1"><span class="toc-number">1.4.22.</span> <span class="toc-text">164</span></a></li><li class="toc-item toc-level-3"><a class="toc-link"><span class="toc-number">1.4.23.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#167%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4first-paint%E5%92%8C%E5%8F%AF%E4%BA%A4%E4%BA%92%E6%97%B6%E9%97%B4dom-ready%E7%9A%84%E5%85%B3%E7%B3%BB%E6%98%AF%EF%BC%9F"><span class="toc-number">1.4.24.</span> <span class="toc-text">167白屏时间first paint和可交互时间dom ready的关系是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#168-1"><span class="toc-number">1.4.25.</span> <span class="toc-text">168</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#169-1"><span class="toc-number">1.4.26.</span> <span class="toc-text">169</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#170-1"><span class="toc-number">1.4.27.</span> <span class="toc-text">170</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#171typeof-Date-now-%E7%9A%84%E5%80%BC%E6%98%AF%EF%BC%9Anumber"><span class="toc-number">1.4.28.</span> <span class="toc-text">171typeof Date.now() 的值是：number</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#172-1"><span class="toc-number">1.4.29.</span> <span class="toc-text">172</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#173"><span class="toc-number">1.4.30.</span> <span class="toc-text">173</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#174"><span class="toc-number">1.4.31.</span> <span class="toc-text">174</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#175"><span class="toc-number">1.4.32.</span> <span class="toc-text">175</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#176"><span class="toc-number">1.4.33.</span> <span class="toc-text">176</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#177"><span class="toc-number">1.4.34.</span> <span class="toc-text">177</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#179-1"><span class="toc-number">1.4.35.</span> <span class="toc-text">179</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#180-1"><span class="toc-number">1.4.36.</span> <span class="toc-text">180</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#182%E4%BB%A5%E4%B8%8B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E4%B8%8D%E4%BC%9A%E5%87%BA%E7%8E%B0%E9%94%99%E8%AF%AF%E7%9A%84%E6%98%AF%EF%BC%9F"><span class="toc-number">1.4.37.</span> <span class="toc-text">182以下表达式不会出现错误的是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#183%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%B8%AA%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%E6%98%AFtrue%EF%BC%9F"><span class="toc-number">1.4.38.</span> <span class="toc-text">183以下哪个表达式的值是true？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#184"><span class="toc-number">1.4.39.</span> <span class="toc-text">184</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#186%E8%AF%B4%E6%B3%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%98%AF"><span class="toc-number">1.4.40.</span> <span class="toc-text">186说法正确的是</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#187%E8%AF%B7%E9%98%85%E8%AF%BB%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.41.</span> <span class="toc-text">187请阅读以下代码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#188-1"><span class="toc-number">1.4.42.</span> <span class="toc-text">188</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#189-1"><span class="toc-number">1.4.43.</span> <span class="toc-text">189</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#190%E4%B8%8D%E6%94%AF%E6%8C%81%E5%86%92%E6%B3%A1%E7%9A%84%E4%BA%8B%E4%BB%B6%E6%9C%89abort-resize-error-load-unload-mouseenter-mouseleave-blur-focus"><span class="toc-number">1.4.44.</span> <span class="toc-text">190不支持冒泡的事件有abort resize error load unload mouseenter mouseleave blur focus</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#191-1"><span class="toc-number">1.4.45.</span> <span class="toc-text">191</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#192%E4%BB%A5%E4%B8%8B%E8%BF%99%E4%BA%9B%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E5%80%BC%E4%B8%BA0"><span class="toc-number">1.4.46.</span> <span class="toc-text">192以下这些表达式的值为0</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#193Ajax%E5%92%8CFlash%E6%AF%94%E8%BE%83"><span class="toc-number">1.4.47.</span> <span class="toc-text">193Ajax和Flash比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#194%E4%BB%A5%E4%B8%8BJs%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BE%93%E5%87%BA%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%88%EF%BC%89"><span class="toc-number">1.4.48.</span> <span class="toc-text">194以下Js程序的输出是什么（）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#195-1"><span class="toc-number">1.4.49.</span> <span class="toc-text">195</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#196"><span class="toc-number">1.4.50.</span> <span class="toc-text">196</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#197"><span class="toc-number">1.4.51.</span> <span class="toc-text">197</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#198%E8%AF%B7%E7%BB%99%E5%87%BA%E8%BF%99%E6%AE%B5%E4%BB%A3%E7%A0%81%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C"><span class="toc-number">1.4.52.</span> <span class="toc-text">198请给出这段代码的运行结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#199"><span class="toc-number">1.4.53.</span> <span class="toc-text">199</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#200%E5%86%99%E5%87%BA%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BB%93%E6%9E%9C"><span class="toc-number">1.4.54.</span> <span class="toc-text">200写出程序运行的结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#201%E4%BB%A5%E4%B8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E5%90%8E%EF%BC%8Ca-x-%E5%92%8C-b-x-%E7%9A%84%E7%BB%93%E6%9E%9C%E5%88%86%E5%88%AB%E6%98%AF%EF%BC%9F"><span class="toc-number">1.4.55.</span> <span class="toc-text">201以下代码执行后，a.x 和 b.x 的结果分别是？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#203"><span class="toc-number">1.4.56.</span> <span class="toc-text">203</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#204%E8%A7%A3%E9%87%8A%E5%9E%8B%E8%AF%AD%E8%A8%80%E7%9A%84%E7%89%B9%E6%80%A7%E6%98%AF%EF%BC%9F%E9%9D%9E%E7%8B%AC%E7%AB%8B%E6%80%A7%E3%80%81%E6%95%88%E7%8E%87%E4%BD%8E"><span class="toc-number">1.4.57.</span> <span class="toc-text">204解释型语言的特性是？非独立性、效率低</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#206"><span class="toc-number">1.4.58.</span> <span class="toc-text">206</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#211%E4%BB%A5%E4%B8%8B%E5%93%AA%E4%BA%9B%E6%BB%A1%E8%B6%B3regexp-test-%E2%80%98abc%E2%80%99-true"><span class="toc-number">1.4.59.</span> <span class="toc-text">211以下哪些满足regexp.test(‘abc’) &#x3D;&#x3D;&#x3D; true</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#213%E4%B8%BA%E4%BB%80%E4%B9%88%E5%88%A9%E7%94%A8%E5%A4%9A%E4%B8%AA%E5%9F%9F%E5%90%8D%E6%9D%A5%E5%AD%98%E5%82%A8%E7%BD%91%E7%AB%99%E8%B5%84%E6%BA%90%E4%BC%9A%E6%9B%B4%E6%9C%89%E6%95%88%EF%BC%9F"><span class="toc-number">1.4.60.</span> <span class="toc-text">213为什么利用多个域名来存储网站资源会更有效？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#214%E7%9F%A5%E9%81%93%E4%BB%80%E4%B9%88%E6%98%AF%E5%BE%AE%E6%A0%BC%E5%BC%8F%E5%90%97%EF%BC%9F%E8%B0%88%E8%B0%88%E7%90%86%E8%A7%A3%E3%80%82%E5%9C%A8%E5%89%8D%E7%AB%AF%E6%9E%84%E5%BB%BA%E4%B8%AD%E5%BA%94%E8%AF%A5%E8%80%83%E8%99%91%E5%BE%AE%E6%A0%BC%E5%BC%8F%E5%90%97%EF%BC%9F"><span class="toc-number">1.4.61.</span> <span class="toc-text">214知道什么是微格式吗？谈谈理解。在前端构建中应该考虑微格式吗？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#215%E5%9C%A8-css-js-%E4%BB%A3%E7%A0%81%E4%B8%8A%E7%BA%BF%E4%B9%8B%E5%90%8E%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E7%BB%8F%E5%B8%B8%E4%BC%9A%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD%EF%BC%8C%E4%BB%8E%E7%94%A8%E6%88%B7%E5%88%B7%E6%96%B0%E7%BD%91%E9%A1%B5%E5%BC%80%E5%A7%8B%EF%BC%8C-%E4%B8%80%E6%AC%A1-js-%E8%AF%B7%E6%B1%82%E4%B8%80%E8%88%AC%E6%83%85%E5%86%B5%E4%B8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E5%9C%B0%E6%96%B9%E4%BC%9A%E6%9C%89%E7%BC%93%E5%AD%98%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">1.4.62.</span> <span class="toc-text">215在 css&#x2F;js 代码上线之后开发人员经常会优化性能，从用户刷新网页开始， 一次 js 请求一般情况下有哪些地方会有缓存处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#216CSS-%E4%B8%AD%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%AE%9A%E4%B9%89%EF%BC%8C%E4%BD%BF%E5%BE%97%E4%B8%80%E4%B8%AA-DOM-%E5%85%83%E7%B4%A0%E4%B8%8D%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%AF%E8%A7%86%E8%8C%83%E5%9B%B4-%E5%86%85%EF%BC%9F"><span class="toc-number">1.4.63.</span> <span class="toc-text">216CSS 中可以通过哪些属性定义，使得一个 DOM 元素不显示在浏览器可视范围 内？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#217%E4%BB%80%E4%B9%88%E6%98%AF-Css-Hack%EF%BC%9Fie6-7-8-%E7%9A%84-hack-%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.64.</span> <span class="toc-text">217什么是 Css Hack？ie6,7,8 的 hack 分别是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#218rgba-%E5%92%8C-opacity-%E7%9A%84%E9%80%8F%E6%98%8E%E6%95%88%E6%9E%9C%E6%9C%89%E4%BB%80%E4%B9%88%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.4.65.</span> <span class="toc-text">218rgba()和 opacity 的透明效果有什么不同？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#219css-%E4%B8%AD%E5%8F%AF%E4%BB%A5%E8%AE%A9%E6%96%87%E5%AD%97%E5%9C%A8%E5%9E%82%E7%9B%B4%E5%92%8C%E6%B0%B4%E5%B9%B3%E6%96%B9%E5%90%91%E4%B8%8A%E9%87%8D%E5%8F%A0%E7%9A%84%E4%B8%A4%E4%B8%AA%E5%B1%9E%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.66.</span> <span class="toc-text">219css 中可以让文字在垂直和水平方向上重叠的两个属性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#220"><span class="toc-number">1.4.67.</span> <span class="toc-text">220</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#223%E6%9C%89-1-%E5%88%B0-10w-%E8%BF%99%E4%B8%AA-10w-%E4%B8%AA%E6%95%B0%EF%BC%8C%E5%8E%BB%E9%99%A4-2-%E4%B8%AA%E5%B9%B6%E6%89%93%E4%B9%B1%E6%AC%A1%E5%BA%8F%EF%BC%8C%E5%A6%82%E4%BD%95%E6%89%BE%E5%87%BA%E9%82%A3%E4%B8%A4%E4%B8%AA%E6%95%B0"><span class="toc-number">1.4.68.</span> <span class="toc-text">223有 1 到 10w 这个 10w 个数，去除 2 个并打乱次序，如何找出那两个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#229"><span class="toc-number">1.4.69.</span> <span class="toc-text">229</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#231%E9%A1%B5%E9%9D%A2%E7%BC%96%E7%A0%81%E5%92%8C%E8%A2%AB%E8%AF%B7%E6%B1%82%E7%9A%84%E8%B5%84%E6%BA%90%E7%BC%96%E7%A0%81%E5%A6%82%E6%9E%9C%E4%B8%8D%E4%B8%80%E8%87%B4%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86%EF%BC%9F"><span class="toc-number">1.4.70.</span> <span class="toc-text">231页面编码和被请求的资源编码如果不一致如何处理？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#234-javascript-%E7%9A%84%E6%9C%AC%E5%9C%B0%E5%AF%B9%E8%B1%A1%EF%BC%8C%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%AE%BF%E4%B8%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.4.71.</span> <span class="toc-text">234.javascript 的本地对象，内置对象和宿主对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#236%E7%94%A8-js-%E5%AE%9E%E7%8E%B0%E5%8D%83%E4%BD%8D%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-number">1.4.72.</span> <span class="toc-text">236用 js 实现千位分隔符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#242%E6%83%B3%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%AF%B9%E9%A1%B5%E9%9D%A2%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E6%8B%96%E6%9B%B3%EF%BC%9F%E5%A6%82%E4%BD%95%E5%81%9A%EF%BC%9F"><span class="toc-number">1.4.73.</span> <span class="toc-text">242想实现一个对页面某个节点的拖曳？如何做？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#250%E5%A4%96%E9%83%A8-JS-%E6%96%87%E4%BB%B6%E5%87%BA%E7%8E%B0%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%EF%BC%8C%E4%BC%9A%E5%87%BA%E7%8E%B0%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%8C%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">1.4.74.</span> <span class="toc-text">250外部 JS 文件出现中文字符，会出现什么问题，怎么解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#251%E8%B0%88%E8%B0%88%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%86%85%E6%A0%B8%EF%BC%8C%E5%B9%B6%E4%B8%94%E8%AF%B4%E4%B8%80%E4%B8%8B%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E6%A0%B8%EF%BC%9F"><span class="toc-number">1.4.75.</span> <span class="toc-text">251谈谈浏览器的内核，并且说一下什么是内核？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#253"><span class="toc-number">1.4.76.</span> <span class="toc-text">253</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#254-reduce-%E6%B1%87%E6%80%BB%EF%BC%9A%E4%B8%80%E5%A0%86%E5%87%BA%E6%9D%A5%E4%B8%80%E4%B8%AA"><span class="toc-number">1.4.77.</span> <span class="toc-text">254 reduce 汇总：一堆出来一个</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#255"><span class="toc-number">1.4.78.</span> <span class="toc-text">255</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#256-generator%E7%94%9F%E6%88%90%E5%99%A8"><span class="toc-number">1.4.79.</span> <span class="toc-text">256 generator生成器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#257"><span class="toc-number">1.4.80.</span> <span class="toc-text">257</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#259%E5%88%9B%E5%BB%BA%E5%87%BD%E6%95%B0%E6%9C%893%E7%A7%8D%EF%BC%9A"><span class="toc-number">1.4.81.</span> <span class="toc-text">259创建函数有3种：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#260%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%9B%9B%E9%83%A8%E6%9B%B2%EF%BC%9A"><span class="toc-number">1.4.82.</span> <span class="toc-text">260类的继承四部曲：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%E5%9B%9B%E9%83%A8%E6%9B%B2%EF%BC%9A"><span class="toc-number">1.4.83.</span> <span class="toc-text">类的继承四部曲：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#261%E5%A4%9A%E6%80%81"><span class="toc-number">1.4.84.</span> <span class="toc-text">261多态</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E8%BD%BD"><span class="toc-number">1.4.84.1.</span> <span class="toc-text">方法重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">1.4.84.2.</span> <span class="toc-text">方法重写</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#262%E5%B0%81%E8%A3%85"><span class="toc-number">1.4.85.</span> <span class="toc-text">262封装</span></a></li></ol></li></ol></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">Archive</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">Tag</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">Cate</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 84
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2023 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/04</span><a class="archive-post-title" href= "/2023/03/04/CSS%E6%8E%92%E5%BA%8F/" >CSS排序</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/07</span><a class="archive-post-title" href= "/2023/01/07/Sass%E3%80%81Less%E3%80%81CSS-Modules%E3%80%81CSS-in-JS%EF%BC%88Emotion%E3%80%81styled-components%EF%BC%89/" >Sass、Less、CSS Modules、CSS in JS（Emotion、styled-components）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/01</span><a class="archive-post-title" href= "/2023/01/01/Git%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4%E3%80%81branch%E3%80%81tag/" >Git常见命令、branch、tag</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2022 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/30</span><a class="archive-post-title" href= "/2022/12/30/js%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" >js数据结构与算法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/28</span><a class="archive-post-title" href= "/2022/12/28/ts/" >ts</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/16</span><a class="archive-post-title" href= "/2022/01/16/Ajax/" >Ajax</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/16</span><a class="archive-post-title" href= "/2022/01/16/Express%E6%A1%86%E6%9E%B6/" >Express框架</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/16</span><a class="archive-post-title" href= "/2022/01/16/node-js/" >node.js</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/19</span><a class="archive-post-title" href= "/2021/12/19/JS%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E5%85%85/" >JS知识点补充</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2021/10/24/weka%E8%BD%AF%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%8CCBR%E9%9D%9E%E5%81%B6%E7%84%B6%E6%80%A7%E8%A7%84%E5%88%92/" >weka软件的使用，CBR非偶然性规划</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/05</span><a class="archive-post-title" href= "/2021/06/05/%E4%B8%80%E4%BA%8C%E9%9D%A2-CSS%E7%9B%92%E6%A8%A1%E5%9E%8B/" >一二面_CSS盒模型</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/05</span><a class="archive-post-title" href= "/2021/06/05/%E4%B8%80%E4%BA%8C%E9%9D%A2-DOM%E4%BA%8B%E4%BB%B6%E7%B1%BB/" >一二面_DOM事件类</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/05</span><a class="archive-post-title" href= "/2021/06/05/%E4%B8%80%E4%BA%8C%E9%9D%A2-HTTP%E5%8D%8F%E8%AE%AE%E7%B1%BB/" >一二面_HTTP协议类</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/20</span><a class="archive-post-title" href= "/2021/02/20/VUE%E9%A1%B9%E7%9B%AE%E6%8C%89%E9%9C%80%E5%BC%95%E5%85%A5ELEMENT-UI%EF%BC%8C%E4%BF%AE%E6%94%B9-BABELRC%E6%96%87%E4%BB%B6%E4%B9%8B%E5%90%8E%E6%8A%A5%E9%94%99/" >VUE项目按需引入ELEMENT-UI，修改.BABELRC文件之后报错</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/20</span><a class="archive-post-title" href= "/2021/02/20/react%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BB%84%E4%BB%B6/" >react中创建组件</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/20</span><a class="archive-post-title" href= "/2021/02/20/react%E6%8A%A5%E9%94%99%EF%BC%9ATypeError-Class-extends-value-undefined-is-not-a-constructor-or-null/" >react报错：TypeError: Class extends value undefined is not a constructor or null</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/20</span><a class="archive-post-title" href= "/2021/02/20/yarn-command-not-found/" >yarn: command not found</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href= "/2021/02/09/Vue-cli%E6%90%AD%E5%BB%BA%E5%A5%BD%E9%BB%98%E8%AE%A4%E9%A1%B9%E7%9B%AE%E5%90%8E%E4%BD%BF%E7%94%A8%E8%B7%AF%E7%94%B1%E5%8A%9F%E8%83%BD%EF%BC%8C%E6%8A%A5%E9%94%99Can%E2%80%99t%20resolve%20%E2%80%98vue-router%E2%80%99%20in/" >Vue-cli搭建好默认项目后使用路由功能，报错Can’t resolve ‘vue-router’ in</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href= "/2021/02/09/Vue%E9%A1%B9%E7%9B%AE%E6%B5%8F%E8%A7%88%E5%99%A8%E5%86%85Console%E4%B8%AD%E6%98%BE%E7%A4%BA-HMR-Waiting-for-update-signal-from-WDS%E2%80%A6%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" >Vue项目浏览器内Console中显示[HMR] Waiting for update signal from WDS…的解决方案</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/05</span><a class="archive-post-title" href= "/2021/02/05/VScode%E5%88%9D%E6%AC%A1%E4%BD%BF%E7%94%A8%E6%97%B6%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8Chtml%E6%96%87%E4%BB%B6%E5%88%B0%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8A/" >VScode初次使用时如何运行html文件到浏览器上</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/05</span><a class="archive-post-title" href= "/2021/02/05/vue%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%83%A8%E5%88%86%E5%8A%9F%E8%83%BD%E5%9C%A8vscode%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/" >vue项目中部分功能在vscode中的使用方法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/05</span><a class="archive-post-title" href= "/2021/02/05/vscode%E7%9A%84%E4%BB%A3%E7%A0%81%E4%B8%8A%E4%BC%A0%E5%88%B0%E6%85%95%E8%AF%BE%E7%BD%91%E4%BB%93%E5%BA%93%E6%97%B6%E4%B8%8A%E4%BC%A0%E4%B8%8D%E6%88%90%E5%8A%9F-%E6%85%95%E8%AF%BE%E7%BD%91%E9%AB%98%E4%BB%BF%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE/" >vscode的代码上传到慕课网仓库时上传不成功--慕课网高仿小米商城项目</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/04</span><a class="archive-post-title" href= "/2021/02/04/vscode%E3%80%81sublime%E6%80%8E%E4%B9%88%E5%9C%A8%E7%A9%BA%E7%99%BD%E8%84%9A%E6%9C%AC%E4%B8%AD%E5%BF%AB%E9%80%9F%E7%94%9F%E6%88%90html5%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E6%A0%BC%E5%BC%8F/" >vscode、sublime怎么在空白脚本中快速生成html5标准模板格式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/04</span><a class="archive-post-title" href= "/2021/02/04/vscode%E8%BD%AF%E4%BB%B6%E4%B8%AD%E7%9A%84html%E6%96%87%E4%BB%B6%E7%9A%84%E5%B8%B8%E7%94%A8%E7%9A%84%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F/" >vscode软件中的html文件的常用的快捷方式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/04</span><a class="archive-post-title" href= "/2021/02/04/better-scroll%E6%BB%9A%E5%8A%A8%E5%A4%B1%E6%95%88%EF%BC%88%E5%8E%BB%E5%93%AA%E7%BD%91%E5%84%BF%E9%A1%B9%E7%9B%AE%E7%A7%BB%E5%8A%A8%E7%AB%AF%EF%BC%89/" >better-scroll滚动失效（去哪网儿项目移动端）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/04</span><a class="archive-post-title" href= "/2021/02/04/VsCode%E4%B8%ADGit%E8%B7%AF%E5%BE%84%E7%9A%84%E8%AE%BE%E7%BD%AE/" >VsCode中git路径的设置（window系统）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/04</span><a class="archive-post-title" href= "/2021/01/04/CSS%E4%B8%AD%E6%96%87%E5%AD%97%E5%9C%A8%E6%B0%B4%E5%B9%B3%E5%92%8C%E7%AB%96%E7%9B%B4%E6%96%B9%E5%90%91%E4%B8%8A%E9%87%8D%E5%8F%A0/" >CSS中文字在水平和竖直方向上重叠</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/04</span><a class="archive-post-title" href= "/2021/01/04/js%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%8E%E6%95%B0%E5%AD%97%E7%9B%B8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4/" >js字符串与数字相加减</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/25</span><a class="archive-post-title" href= "/2020/12/25/Vue%E7%BB%9F%E4%B8%80%E6%A0%B7%E5%BC%8F%EF%BC%88reset-css%E5%92%8Cborder-css%EF%BC%89/" >Vue统一样式（reset.css和border.css）</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/18</span><a class="archive-post-title" href= "/2020/12/18/RegExp%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" >RegExp正则表达式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/15</span><a class="archive-post-title" href= "/2020/12/15/C++%E7%9A%84OpenCV%E4%BD%8E%E7%89%88%E6%9C%AC%E7%9A%84CvvImage-cpp%E5%92%8Ccvvimage-h%E6%96%87%E4%BB%B6/" >C++的OpenCV低版本的CvvImage.cpp和cvvimage.h文件</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/15</span><a class="archive-post-title" href= "/2020/12/15/JS%E4%B8%AD%E7%9A%84%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E6%B5%85%E6%B5%85%E4%BA%86%E8%A7%A3/" >JS中的面向对象浅浅了解</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/06</span><a class="archive-post-title" href= "/2020/12/06/ES6%E6%80%BB%E7%BB%93%E6%95%B4%E7%90%86/" >ES6总结整理</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/2020/09/27/HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88%E4%BA%8C%EF%BC%89/" >HEXO博客的搭建及环境配置（二）</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/13</span><a class="archive-post-title" href= "/2020/12/13/JavaScript%E7%9F%A5%E8%AF%86%E7%82%B9%E6%89%A9%E5%B1%95/" >JavaScript知识点扩展</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/08</span><a class="archive-post-title" href= "/2020/11/08/Sass%E6%80%BB%E7%BB%93/" >Sass总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/28</span><a class="archive-post-title" href= "/2020/09/28/hexo%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%8F%92%E5%85%A5%E7%9A%84%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/" >hexo博客中插入的图片不显示</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2020/09/27/hexo%E7%82%B9%E5%87%BB%E5%8D%9A%E5%AE%A2%E5%90%8E%E6%A0%87%E9%A2%98%E4%B8%8D%E6%98%BE%E7%A4%BA/" >hexo点击博客后标题不显示</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2020/09/27/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE/" >JavaScript原型链</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2020/09/27/Typora%E3%80%81Makedown/" >Typora、Makedown</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2020/09/27/HEXO%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%90%AD%E5%BB%BA%E5%8F%8A%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%EF%BC%88%E4%B8%80%EF%BC%89/" >HEXO博客的搭建及环境配置（一）</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> Invalid date </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">Invalid date</span><a class="archive-post-title" href= "/2020/09/27/hexo%E4%B8%BB%E9%A2%98%E4%BF%AE%E6%94%B9/" >hexo主题修改</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2023 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">03/04</span><a class="archive-post-title" href= "/2023/03/04/%E8%BD%AE%E8%AF%A2%E3%80%81%E9%95%BF%E8%BD%AE%E8%AF%A2comet%E3%80%81%E9%95%BF%E8%BF%9E%E6%8E%A5SSE%E3%80%81websocket/" >轮询、长轮询comet、长连接SSE、websocket</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2022 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/30</span><a class="archive-post-title" href= "/2022/12/30/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%89%93%E5%8C%85%E5%90%8E%E5%8E%8B%E7%BC%A9/" >前端项目打包后压缩</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/28</span><a class="archive-post-title" href= "/2022/12/28/%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96/" >代码优化</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">01/16</span><a class="archive-post-title" href= "/2022/01/16/%E5%88%9B%E5%BB%BAUmiJS%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%8A%A5%E9%94%99-%E6%96%87%E4%BB%B6%E5%90%8D%E3%80%81%E7%9B%AE%E5%BD%95%E5%90%8D%E6%88%96%E5%8D%B7%E6%A0%87%E8%AF%AD%E6%B3%95%E4%B8%8D%E6%AD%A3%E7%A1%AE/" >创建UmiJS项目时报错--文件名、目录名或卷标语法不正确</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2021 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/21</span><a class="archive-post-title" href= "/2021/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93-MySQL%E7%9A%84%E4%BA%8B%E5%8A%A1/" >数据库-MySQL的事务</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/21</span><a class="archive-post-title" href= "/2021/11/21/%E6%95%B0%E6%8D%AE%E5%BA%93-mysql%E6%9F%A5%E8%AF%A2%E7%BB%83%E4%B9%A0/" >数据库-mysql查询练习</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/14</span><a class="archive-post-title" href= "/2021/11/14/%E6%95%B0%E6%8D%AE%E5%BA%93-%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E5%A4%A7%E8%AE%BE%E8%AE%A1%E8%8C%83%E5%BC%8F/" >数据库-数据库三大设计范式</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/14</span><a class="archive-post-title" href= "/2021/11/14/%E6%95%B0%E6%8D%AE%E5%BA%93-%E4%BD%BF%E7%94%A8%E7%BB%88%E7%AB%AF%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93/" >数据库-使用终端操作数据库</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">11/07</span><a class="archive-post-title" href= "/2021/11/07/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%8E%92%E5%BA%8F/" >数据结构与算法--排序</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95--%E9%93%BE%E8%A1%A8%EF%BC%88Linked%20list%EF%BC%89-JS/" >数据结构与算法--链表（Linked list）--JS</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95--%E9%98%9F%E5%88%97%EF%BC%88Queue%EF%BC%89-JS/" >数据结构与算法--队列（Queue）--JS</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2021/10/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" >前端面试题总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%93%88%E5%B8%8C%E8%A1%A8-JS/" >数据结构与算法--哈希表--JS</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E5%9B%BE%EF%BC%88Graph%EF%BC%89-JS/" >数据结构与算法-图（Graph）-JS</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E6%A0%91%EF%BC%88Tree%EF%BC%89-JS/" >数据结构与算法-树（Tree）-JS</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-%E9%9B%86%E5%90%88%EF%BC%88Set%EF%BC%89-JS/" >数据结构与算法--集合（Set）--JS</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">10/24</span><a class="archive-post-title" href= "/2021/10/24/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95--%E6%A0%88%EF%BC%88Stack%EF%BC%89--JS/" >数据结构与算法--栈（Stack）--JS</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/27</span><a class="archive-post-title" href= "/2021/06/27/%E6%89%8B%E5%86%99Promise-all%E5%92%8CPromise-race/" >手写Promise.all和Promise.race</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span><a class="archive-post-title" href= "/2021/06/08/%E4%B8%89%E5%9B%9B%E9%9D%A2-%E4%B8%9A%E5%8A%A1%E8%83%BD%E5%8A%9B%E5%9B%A2%E9%98%9F%E5%8D%8F%E4%BD%9C%E8%83%BD%E5%8A%9B%E4%B8%8E%E5%B8%A6%E4%BA%BA%E8%83%BD%E5%8A%9B/" >三四面_业务能力团队协作能力与带人能力</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span><a class="archive-post-title" href= "/2021/06/08/%E4%BA%8C%E4%B8%89%E9%9D%A2-%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6%E7%B1%BB/" >二三面_渲染机制类</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span><a class="archive-post-title" href= "/2021/06/08/%E4%BA%8C%E4%B8%89%E9%9D%A2-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E7%B1%BB/" >二三面_运行机制类</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span><a class="archive-post-title" href= "/2021/06/08/%E4%BA%8C%E4%B8%89%E9%9D%A2-%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7%E7%B1%BB/" >二三面_错误监控类</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span><a class="archive-post-title" href= "/2021/06/08/%E4%BA%8C%E4%B8%89%E9%9D%A2-%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD/" >二三面_页面性能</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span><a class="archive-post-title" href= "/2021/06/08/%E7%BB%88%E9%9D%A2%EF%BC%88HR%E9%9D%A2%EF%BC%89-%E8%81%8C%E4%B8%9A%E7%AB%9E%E4%BA%89%E5%8A%9B%E5%92%8C%E8%81%8C%E4%B8%9A%E8%A7%84%E5%88%92/" >终面（HR面）_职业竞争力和职业规划</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/08</span><a class="archive-post-title" href= "/2021/06/08/%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/" >面试总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/07</span><a class="archive-post-title" href= "/2021/06/07/%E7%AE%97%E6%B3%95%E9%A2%98%E6%80%BB%E7%BB%93/" >算法题总结</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/05</span><a class="archive-post-title" href= "/2021/06/05/%E4%B8%80%E4%BA%8C%E9%9D%A2-%E5%8E%9F%E5%9E%8B%E9%93%BE/" >一二面_原型链</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/05</span><a class="archive-post-title" href= "/2021/06/05/%E4%B8%80%E4%BA%8C%E9%9D%A2-%E7%AE%97%E6%B3%95%E7%B1%BB/" >一二面_算法类</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/05</span><a class="archive-post-title" href= "/2021/06/05/%E4%B8%80%E4%BA%8C%E9%9D%A2-%E5%AE%89%E5%85%A8%E7%B1%BB/" >一二面_安全类</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/05</span><a class="archive-post-title" href= "/2021/06/05/%E4%B8%80%E4%BA%8C%E9%9D%A2-%E9%80%9A%E8%AE%AF%E7%B1%BB/" >一二面_通讯类</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/05</span><a class="archive-post-title" href= "/2021/06/05/%E4%B8%80%E4%BA%8C%E9%9D%A2-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" >一二面_面向对象</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/05</span><a class="archive-post-title" href= "/2021/06/05/%E4%B8%8A%E4%BC%A0%E5%8D%9A%E5%AE%A2%E5%88%B0github%E6%97%B6%E5%87%BA%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98-Failed-to-connect-to-github-com-port-443-Timed-out/" >上传博客到github时出现的问题 Failed to connect to github.com port 443: Timed out </a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/05</span><a class="archive-post-title" href= "/2021/06/05/%E4%B8%80%E4%BA%8C%E9%9D%A2-%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80/" >一二面_页面布局</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/20</span><a class="archive-post-title" href= "/2021/02/20/%E4%BD%BF%E7%94%A8styled-components%E6%8A%A5%E9%94%99-Attempted-import-error-injectGlobal-is-not-exported-from-styled-components/" >使用styled-components报错 Attempted import error: injectGlobal is not exported from styled-components</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/20</span><a class="archive-post-title" href= "/2021/02/20/%E6%85%95%E8%AF%BE%E7%BD%91%E5%B0%8F%E7%B1%B3%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE9-1-%E5%95%86%E5%93%81%E8%AF%A6%E6%83%85%E4%BA%A4%E4%BA%92%E5%AE%9E%E7%8E%B0%E8%AF%BE%E7%A8%8B%E4%B8%AD%E9%80%89%E6%8B%A9%E7%89%88%E6%9C%AC%E5%87%BA%E7%8E%B0%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98/" >慕课网小米商城项目9-1_商品详情交互实现课程中选择版本出现的小问题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href= "/2021/02/09/%E4%BD%BF%E7%94%A8sass%E6%97%B6%EF%BC%8C%E6%8A%A5%E9%94%99TypeError-this-getResolve-is-not-a-function-at-Object-loader/" >使用sass时，报错TypeError: this.getResolve is not a function at Object.loader</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href= "/2021/02/09/%E4%BD%BF%E7%94%A8swiper%E6%8F%92%E4%BB%B6%E6%97%B6%EF%BC%8C%E6%8A%A5%E9%94%99Can-t-resolve-swiper-dist-css-swiper-css-in/" >使用swiper插件时，报错Can't resolve 'swiper/dist/css/swiper.css' in</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/09</span><a class="archive-post-title" href= "/2021/02/09/%E4%BD%BF%E7%94%A8swiper%E6%8F%92%E4%BB%B6%E6%97%B6%EF%BC%8C%E6%8A%A5%E9%94%99did-you-register-the-component-correctly-For-recursive-components-make-sure-to-provide-the-name-option/" >使用swiper插件时，报错did you register the component correctly? For recursive components, make sure to provide the name option</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/05</span><a class="archive-post-title" href= "/2021/02/05/%E8%BF%90%E8%A1%8Cvue%E9%A1%B9%E7%9B%AE%E6%97%B6%E6%8A%A5%E9%94%99The-template-root-requires-exactly-one-element/" >运行vue项目时报错The template root requires exactly one element</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/04</span><a class="archive-post-title" href= "/2021/02/04/%EF%BC%88tinypng%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%EF%BC%89%E8%A7%A3%E5%86%B3CSDN%E4%B8%8A%E4%BC%A0%E4%B8%8D%E4%BA%86%E8%BF%87%E5%A4%A7%E7%9A%84%E5%9B%BE%E7%89%87%E9%97%AE%E9%A2%98/" >（tinypng图片压缩）解决CSDN上传不了过大的图片问题</a>
        </li>
    
    
    
    
    
        </ul>
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">12/20</span><a class="archive-post-title" href= "/2020/12/20/%E5%AF%B9%E8%B1%A1/" >对象</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">09/27</span><a class="archive-post-title" href= "/2020/09/27/%E7%85%9C%E6%88%90%E2%80%99studio/" >煜成’studio</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/",
        author: "Nice"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/lib/jquery.min.js">\x3C/script>')
        }
    </script>
    <script src="/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/scripts/share.js" async></script>    
     
    </body>
</html>


